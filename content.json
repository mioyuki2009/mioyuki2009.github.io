{"meta":{"title":"waterpool","subtitle":null,"description":null,"author":"mioyuki2009","url":"http://gloriaswaterpool.com","root":"/"},"pages":[{"title":"About","date":"2022-07-23T03:12:46.290Z","updated":"2022-07-23T03:12:46.290Z","comments":true,"path":"about/index.html","permalink":"http://gloriaswaterpool.com/about/index.html","excerpt":"","text":"nevermore"},{"title":"Categories","date":"2022-07-23T03:12:46.290Z","updated":"2022-07-23T03:12:46.290Z","comments":true,"path":"categories/index.html","permalink":"http://gloriaswaterpool.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2022-07-23T03:12:46.306Z","updated":"2022-07-23T03:12:46.306Z","comments":true,"path":"tags/index.html","permalink":"http://gloriaswaterpool.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"学习一个操作系统-3","slug":"学习一个操作系统-3","date":"2018-12-05T06:53:39.000Z","updated":"2022-07-23T03:12:46.275Z","comments":true,"path":"2018/12/05/学习一个操作系统-3/","link":"","permalink":"http://gloriaswaterpool.com/2018/12/05/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3/","excerpt":"继续上次的","text":"继续上次的 这次实现一个保护模式，全部代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586%include &quot;pm.inc&quot;org 07c00h jmp LABEL_BEGIN[SECTION .gdt]; GDT; 段基址 段界限 属性 LABEL_GDT: Descriptor 0, 0, 0 ;空描述符LABEL_DESC_CODE32:Descriptor 0, SegCode32Len - 1, DA_C + DA_32;非一致代码段LABEL_DESC_VIDEO: Descriptor 0B8000h, 0ffffh, DA_DRW ;显存首地址; GDT结束GdtLen equ $ - LABEL_GDT ;GDT长度GdtPtr dw GdtLen - 1 ;GDT界限 dd 0 ;GDT基地址; GDT选择子SelectorCode32 equ LABEL_DESC_CODE32 - LABEL_GDTSelectorVideo equ LABEL_DESC_VIDEO - LABEL_GDT; END of [SECTION .gdt][SECTION .a16][BITS 16]LABEL_BEGIN: mov ax, cs mov ds, ax mov es, ax mov ss, ax mov sp, 0100h ; 初始化32位代码段描述符 xor eax, eax mov ax, cs shl eax, 4 add eax, LABEL_SEG_CODE32 mov word [LABEL_DESC_CODE32 + 2], ax shr eax, 16 mov byte [LABEL_DESC_CODE32 + 4], al mov byte [LABEL_DESC_CODE32 + 7], ah ; 为加载GDTR做准备 xor eax, eax mov ax, ds shl eax, 4 add eax, LABEL_GDT ; eax &lt;- gdt 基地址 mov dword [GdtPtr + 2], eax ; [GdtPtr + 2] &lt;- gdt 基地址 ; 加载 GDTR lgdt [GdtPtr] ; 关中断 cli ; 打开地址线A20 in al, 92h or al, 00000010b out 92h,al ; 准备切换到保护模式 mov eax, cr0 or eax, 1 mov cr0, eax ; 真正进入保护模式 jmp dword SelectorCode32:0 ; 执行这一句会把SelectorCode32装入cs ; 并跳转到Code32Selector:0处; END of [SECTION .s16][SECTION .s32] ; 32位代码段， 由实模式跳入。[BITS 32]LABEL_SEG_CODE32: mov ax, SelectorVideo mov gs, ax ; 视频段选择子（目的） mov edi, (80 *11 + 79) * 2 ; 屏幕第11行，第79列。 mov ah, 0Ch ; 0000: 黑底 1100:红字 mov al, &#x27;p&#x27; mov [gs:edi], ax ; 到此停止 jmp $SegCode32Len equ $ - LABEL_SEG_CODE32; END of [SECTION .s32] 下面简单解释一下：首先include \"pm.inc\"和注释一样，这里面包含一些常量，宏和相关说明，没有的可以在这里获取。 然后和之前一样org 07c00h，之后jmp到需要执行的代码。 现在看[SECTION .gdt]这个段，这里SECTION定义了一个gdt段，SECTION并没有什么特别的语义，仅仅是一种组织代码和存储的方式，这里这样做是为了之后很好的扩展，要了解更多可以查看这个。开始就用Descriptor定义了3个结构，Descriptor在”pm.inc”中定义，定义如下： 123456789101112131415; 宏 ------------------------------------------------------------------------------------------------------;; 描述符; usage: Descriptor Base, Limit, Attr; Base: dd; Limit: dd (low 20 bits available); Attr: dw (lower 4 bits of higher byte are always 0)%macro Descriptor 3 dw %2 &amp; 0FFFFh ; 段界限 1 (2 字节) dw %1 &amp; 0FFFFh ; 段基址 1 (2 字节) db (%1 &gt;&gt; 16) &amp; 0FFh ; 段基址 2 (1 字节) dw ((%2 &gt;&gt; 8) &amp; 0F00h) | (%3 &amp; 0F0FFh) ; 属性 1 + 段界限 2 + 属性 2 (2 字节) db (%1 &gt;&gt; 24) &amp; 0FFh ; 段基址 3 (1 字节)%endmacro ; 共 8 字节; 可以看到就是定义了一个8字节的结构，宏的语法格式为%macro 宏名称 参数个数，所以这里很明显了，就是定义了一个Descriptor，3参数的结构，之后的%1，%2，%3分别为第一个，第二个，第三个参数，之前也提到db，dw，dd分别为1字节，2字节，4字节，现在就可以分别解释了。第一行表示取第二个参数的0-15位（2个字节的大小）作为宏的第一、二个字节第二行表示取第一个参数的0-15位（2个字节的大小）作为宏的第三、四个字节第三行先把第一个参数右移16位（2字节）最低位就变成了之前的第16位，在和0FF求与，就是取第一个参数的16-23位，作为宏的第五个字节。第四行“|”号前半部分，参数2右移8位（1字节）最低为变为之前的第8位，和0F00求与，0F00为1的位置为第8-11位，在原始的第二个参数中就变成了16-19位（（8-11）+8）。后半部分第三个参数和0F0FF求与，就是第三个参数的0-7位及12-15位，之后前后部分求或得到宏的第六七字节，可以看到，这里的0-7位都是第三个参数的，所以认为宏的第六字节就是第三个参数的第0-7位，而第七字节就是这里的第8-15位就是两个参数的组合。第五行第一个参数先右移24位，低位变成原来的第24位，然后与0FF求与，就是第一个参数的24-31位作为第宏的第八个字节。 ps：汇编语言中，一般所说的第一个字节是指按照存贮地址偏移量最小的字节，对应数据的最低位字节；而通信协议中，串行传输时，是从一个帧的首部开始依次传送，一般从高位数起；16位寄存器传输32位数值，根据32为数值的存储顺序，低位字在前，高位字在后，所以应该是先传低16位，后传高16位数据。 我们的代码中，这里的3个参数分别为段基址，段界限，属性，所以得到的宏的结构应该是这样的： 在IA32下，cpu有两种工作模式，实模式和保护模式，直观地看，当pc上电，开始时cpu是工作在实模式下的，经过某种机制后，才进入保护模式，在保护模式下，cpu有着巨大的寻址能力。Intel8086是16位的cpu，有16位的寄存器，16位的数据总线以及20位的地址总线和1MB的寻址能力。从80386开始，Intel的cpu进入32位时代。有32位地址总线，所以寻址空间可达4GB，这时需要新的方法来解决8086是16位的cpu，只能访问地址在1M以下的内存称为常规内存，我们把地址在1M以上的内存称为扩展内存。实模式下有着16位的寄存器&#x2F;16位数据总线&#x2F;20位地址总线。一个地址有段和偏移两部分组成，物理地址的计算公式为：物理地址physicaladdress&#x3D;段值segment * 16 + 偏移offset 其中段值和偏移都是16位的从80386开始，进入32位cpu时代，有32位地址总线。但是，地址并没有用寄存器直接指定，仍然采用了“段+偏移”的模式。虽然段值仍然由原来的16位cs&#x2F;ds等寄存器指定，但此时这些寄存器中存放的不再是段基址，而是一个索引：从这个索引，可以找到一个表项，里面存放了段基址等很多属性，这个表项称为段描述符，这个表就称为GDT。这就是保护模式寻址了。也就是说GDT的作用是用来提供段式存储机制，这种机制是通过段寄存器和GDT中的描述符（也就是我们这里的Descriptor）共同提供的。 所以，这里的3个参数，所谓的段基址就是存放该段的起始地址，而段界限指段内的最大偏移，所以一定要在段长度的基础上再减1，这就是这里SegCode32Len - 1的由来了，关于SegCode32Len，可以在代码最后看到SegCode32Len equ $ - LABEL_SEG_CODE32，所以SegCode32Len就是$ - LABEL_SEG_CODE32，而$表示的就是当前的偏移地址，而这一句是紧接着LABEL_SEG_CODE32之后的，$ - LABEL_SEG_CODE32就是表示他的长度了。关于他的属性很复杂，会在后面一点解释。 之后就是LABEL_DESC_VIDEO的描述子，关于这里的参数问题，可以看这里。 之后又定义了两个结构，GdtLen作为Gdt长度，语义和之前说的SegCode32Len类似，GdtPtr结构，包含一个GDT界限和GDT基址。 然后是两个选择子SelectorCode32和SelectorVideo，具体的定义就是相应的描述符相对于GDT的偏移，再看代码就很直观了。 现在跳过16位的代码段，先看32位的代码段，这里的[BITS 32]指定了这一段的代码是32位代码段，即保护模式段： 12mov ax, SelectorVideomov gs, ax 这两句将段寄存器gs的值变成了SelectorVideo，由上面的解释可以看到SelectorVideo就是LABEL_DESC_VIDEO相对于GDT的偏移，这里GDT的基址为0，基本就可以认为gs现在就是对应显存的描述符LABEL_DESC_VIDEO。 1234mov edi, (80 *11 + 79) * 2 ; 屏幕第11行，第79列。mov ah, 0Ch ; 0000: 黑底 1100:红字mov al, &#x27;p&#x27;mov [gs:edi], ax 二三行分别指定了写入的字体和颜色分别写入ax的高低位，第一行就是就是位置了，这里通过计算在gs段偏移多少来设置地址，在屏幕上，一行一般是80个字符；每个字符的显示需要两个字节，一个字节是显示字符的ascii，一个字节的显示用的颜色（字符颜色+背景色）。这些数据在显示缓存里是按行排列的，先是第0行，然后是第1行，所以第11行的起始地址就是80*2*11了，这一行的第79列字符就是再加上79*2了，整个就是80*2*11+79* 2=(80*11+79)*2了。之后将ax的值写入这个位置就能达到显示的目的了。 现在来看16位的代码： 12345mov ax, csmov ds, axmov es, axmov ss, axmov sp, 0100h 首先是初始化相关段寄存器和对堆栈初始化，就是对ss和sp赋值了。 123456789; 初始化32位代码段描述符xor eax, eaxmov ax, csshl eax, 4add eax, LABEL_SEG_CODE32mov word [LABEL_DESC_CODE32 + 2], axshr eax, 16mov byte [LABEL_DESC_CODE32 + 4], almov byte [LABEL_DESC_CODE32 + 7], ah eax就是ax的32位版本了。这段代码首先将LABEL_SEG_CODE32的物理地址（即[SECTION .s32]段的物理地址）赋给eax，然后把他分成三部分分别赋给描述符LABEL_DESC_CODE32的三个位置，不太理解的话可以与描述符的代码比较，这里的[LABEL_DESC_CODE32 + 2]相当于在LABEL_DESC_CODE32描述符之后的两个字节的位置，就是LABEL_DESC_CODE的三四字节，就是上图中段基址的位置，也是描述符代码中dw %1 & 0FFFFh这一行，shr eax, 16表示eax右移16位，之后同理，总之就是赋值了LABEL_DESC_CODE32描述符中段基址的部分。由于LABEL_DESC_CODE32段界限和属性已经指定，所以现在LABEL_DESC_CODE32的初始化已全部完成。 1lgdt [GdtPtr] 这一句的作用是将GdtPtr指示的6个字节加载到寄存器gdtr中，这里我们设计的GdtPtr和gdtr的结构完全一样。 下面一句话是关中断，之所以关中断，是因为保护模式下中断处理的机制是不同的，不关中断会出现错误。 1234; 打开地址线A20in al, 92hor al, 00000010bout 92h,al 这一句是打开A20地址线。A20地址线并不是打开保护模式的关键，只是在保护模式下，不打开A20地址线，你将无法访问到所有的内存（具体参考下面的第5点）1、用于80286与8086兼容2、用于80286处于实模式下时，防止用户程序访问到100000h~10FFEFh之间的内存（高端内存）3、8086模式，A20关闭的情况下，访问超过1MB内存时，会自动回卷4、8086模式下，A20打开的情况下，访问超过1MB内存，就真实的访问5、保护模式下，A20关闭（始终为0），则用户的地址只能是：0 - (1MB-1), 2 - (3MB-1), 4 - (5MB-1)，我们可以这样设想，A20为个位数（以1MB为单位），如果它始终为0，你永远不可能让这个数变成奇数6、保护模式下，A20开启，则可以访问全地址，没有奇偶MB的问题。 这里的in和out语义分别是： in DES, SRC： 从src端口读取1字节数据到DES OUT DES, SRC： 将SRC的值写入DES端口打开A20地址线的方法有很多，这里我们使用操作端口92h的方法：1、端口0x92控制A20信号线，即操作0x92端口就能开启和禁止寻址超过1M时的环绕。2、or al,00000010b 就是将从端口0x92读入数据的二进制码的第二位置1，从而实现开启A20地址。因为A20信号的第二位就是用于控制开启&#x2F;禁止A20地址的。 之后是切换到保护模式的准备工作： 1234; 准备切换到保护模式mov eax, cr0or eax, 1mov cr0, eax 寄存器cr0的第0位是PE位，此位为0时，CPU运行于实模式，为1时，CPU运行于保护模式。这里将更改为1，就运行在保护模式下了。但是此时cs寄存器（代码段寄存器）的值仍然是实模式下的值，现在需要把代码段选择子装入cs中： 123; 真正进入保护模式jmp dword SelectorCode32:0 ; 执行这一句会把SelectorCode32装入cs ; 并跳转到Code32Selector:0处 之前说到SelectorCode32就是代码段选择子的地址，所以直接跳转就行，不过这里是16位的段，但是目标地址是32位的，所以加个dword变成32位的。 现在代码部分解释完毕，解释一下之前跳过的属性的部分吧：关于描述符的简单格式这里只给一个图，详细一点的可以参考这个。 我们这里的代码段的属性是DA_C + DA_32，这两个也是在pm.inc中定义的： 123456789101112131415161718192021222324252627282930313233343536373839;----------------------------------------------------------------------------; 描述符类型值说明; 其中:; DA_ : Descriptor Attribute; D : 数据段; C : 代码段; S : 系统段; R : 只读; RW : 读写; A : 已访问; 其它 : 可按照字面意思理解;----------------------------------------------------------------------------DA_32 EQU 4000h ; 32 位段DA_LIMIT_4K EQU 8000h ; 段界限粒度为 4K 字节DA_DPL0 EQU 00h ; DPL = 0DA_DPL1 EQU 20h ; DPL = 1DA_DPL2 EQU 40h ; DPL = 2DA_DPL3 EQU 60h ; DPL = 3;----------------------------------------------------------------------------; 存储段描述符类型值说明;----------------------------------------------------------------------------DA_DR EQU 90h ; 存在的只读数据段类型值DA_DRW EQU 92h ; 存在的可读写数据段属性值DA_DRWA EQU 93h ; 存在的已访问可读写数据段类型值DA_C EQU 98h ; 存在的只执行代码段属性值DA_CR EQU 9Ah ; 存在的可执行可读代码段属性值DA_CCO EQU 9Ch ; 存在的只执行一致代码段属性值DA_CCOR EQU 9Eh ; 存在的可执行可读一致代码段属性值;----------------------------------------------------------------------------; 系统段描述符类型值说明;----------------------------------------------------------------------------DA_LDT EQU 82h ; 局部描述符表段类型值DA_TaskGate EQU 85h ; 任务门类型值DA_386TSS EQU 89h ; 可用 386 任务状态段类型值DA_386CGate EQU 8Ch ; 386 调用门类型值DA_386IGate EQU 8Eh ; 386 中断门类型值DA_386TGate EQU 8Fh ; 386 陷阱门类型值;---------------------------------------------------------------------------- 可以看到DA_C是98h，对应的二进制是10011000b。也就是说，P位是1表明这个段在内存中，S位是1表明这个段是代码段或者数据段，TYPE&#x3D;8表明这个段是个代码段，而且是只执行的代码段。DA_32是4000h，由于这个段是代码段，D位是1表明这个段是32位的代码段。所以这个段是存在的只执行的32位代码段，DPL为0。 现在代码部分解释完毕，是时候运行了。和之前一样用nasm将代码编译为pmtest.bin，这里有点不同，之前我们是把bin文件直接写入到引导扇区，但是引导扇区空间有限，要是我们的程序之后大于512字节就不好了，所以现在有了另一个办法。步骤如下：1、首先去freedos官网下一个freedos的软盘img镜像，命名为freedos.img。2、和之前一样用bximage生成一个软盘镜像，命名为pm.img3、修改我们的bochsrc，将之前的floppya那一行更改为： 123floppya: 1_44=freedos.img, status=insertedfloppyb: 1_44=pm.img, status=insertedboot: a 4、启动bochs，在freedos启动后格式化B:盘（format b:）。5、因为现在要编译为.com文件，将代码org 07c00h更改为org 0100h进行编译：nasm pmtest1.asm -o pmtest1.com6、将pmtest1.com复制到虚拟软盘pm.img上： 123sudo mount -o loop pm.img /mnt/floppysudo cp pmtest1.com /mnt/floppy/sudo umount /mnt/floppy 7、到freedos中执行如下命令： 1B:\\pmtest1.com 如果成功可以看到如下所示的样子，一个红色的字母p出现在中间右侧：","categories":[{"name":"os","slug":"os","permalink":"http://gloriaswaterpool.com/categories/os/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://gloriaswaterpool.com/tags/linux/"}]},{"title":"学习一个操作系统-2","slug":"学习一个操作系统-2","date":"2018-12-04T01:10:11.000Z","updated":"2022-07-23T03:12:46.275Z","comments":true,"path":"2018/12/04/学习一个操作系统-2/","link":"","permalink":"http://gloriaswaterpool.com/2018/12/04/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2/","excerpt":"继续上次的","text":"继续上次的 上次是使用qemu进行模拟的，但是原书中使用的bochs，觉得还是保持一致比较好 首先安装bochs： 1pacman -S bochs 然后输入命令进行软盘映像的创建： 1bximage 得到下图所示： 第一个输入1，因为我们需要创建一个映像，第二个输入fd作为软盘创建，之后的输入默认就行，直接回车就行。之后会在目录下得到一个a.img文件。现在可以将之前的引导扇区写入这个文件了： 1dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc 相比上一次多了一个conv参数，如果不用的话软盘映像文件会被截断（truncated），因为boot.bin比a.img要小。 之后需要实现一个bochs的配置文件bochsrc： 123456789101112megs=32romimage: file=/usr/share/bochs/file=BIOS-bochs-latestvgaromimage: file=/usr/share/bochs/VGABIOS-lgpl-latestfloppya: 1_44=a.img, status=insertedlog: bochsout.txtmouse: enable=0keyboard: keymap=/usr/share/bochs/keymaps/x11-pc-de.map 第一行设置模拟的物理内存，meg会将’guest’和’host’内存都设置为32mb 第二三行是设置rom，和真机一样，Bochs也需要系统BIOS和VGA BIOS才能在打开电源或硬件复位后初始化机器，这里就是这两个的位置，这个是bochs安装的默认目录，如果有新的更改可以参考这里。 第四行是软盘文件，状态设置为插入（inserted）。第五行是输入文件，将相关信息输出到文件中。 第六行是鼠标设置为禁用第七行是键盘设置，这里设置为us键盘布局。 设置好了之后使用bochs -f bochsrc启动模拟： 这里选择默认的6开始模拟： 这里每一个&lt;bochs:num&gt;之后都是一个调试命令，简单解释一下：b 0x7c00 在0x7c00处打一个断点c 继续执行到断点处，没有断点则一直运行r 查看数据寄存器和标志寄存器ps:现版本的bochs没有dump_cpu了,可以用r，fp，mmx，sse，dreg，sreg，creg命令组合来代替。x &#x2F;64xb 0x7c00 从0x7c00以16进制显示之后64个地址的内容n 单步执行，遇到函数则跳过trace-reg on 让bochs每走一步都显示主要寄存器的值 如果有不清晰的，可以使用help命令查询 最后使用c命令，就可以看到和之前一样的结果了：","categories":[{"name":"os","slug":"os","permalink":"http://gloriaswaterpool.com/categories/os/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://gloriaswaterpool.com/tags/linux/"}]},{"title":"学习一个操作系统-1","slug":"学习一个操作系统-1","date":"2018-12-03T01:19:01.000Z","updated":"2022-07-23T03:12:46.275Z","comments":true,"path":"2018/12/03/学习一个操作系统-1/","link":"","permalink":"http://gloriaswaterpool.com/2018/12/03/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/","excerpt":"学习一个操作系统，参考《Orange’S：一个操作系统的实现》","text":"学习一个操作系统，参考《Orange’S：一个操作系统的实现》 按照书中的顺序，先写个小小的引导扇区：我所在的环境是manjaro虚拟机manjaro下默认好像是没有qemu和nasm的，所以安装一下： 12pacman -S qemupacman -S nasm 然后就可以编写了： 123456789101112131415161718org 7c00hmov ax, csmov ds, axmov es, axcall DispStrjmp $DispStr: mov ax, BootMessage mov bp, ax mov cx, 16 mov ax, 1300h mov bx, 000ch mov dl, 0 int 10h retBootMessage: db &quot;Hello, OS world&quot;times 510-($-$$) db 0dw 0xaa55 下面一点点解释：在计算机开机时会进行加电自检（POST），然后寻找启动盘，如果从软盘启动，会检查软盘的0面0磁道1扇区，如果是0xaa55结束，则认为他是一个引导扇区。所以最后设置了0xaa55的结束标志，定义他为一个引导扇区，并且其中的执行代码要少于512字节。ps:有关dd dw db 都是定义变量用的不同之处在于dd表示一个双字，就是四个字节36位，每次读取数据时，读完一个偏移量加4dw在汇编中表示一个字，就是两个字节16位，每次读取数据时，读完一个偏移量加2db在汇编中表示一个byte，就是一个字节8位，每次读取数据时，读完一个偏移量加1在表示字符串的时候通常使用db，如果使用dw或dd可能字符串会颠倒，这是是由于他们存储方式的原因，具体原因可以参考这个。 启动时，主引导记录会存入内存地址0x7C00，就是说bios发现了引导扇区后，会将这512字节的内容装载到内存为7c00的位置，org的意思就是开始执行的时候，将某段机器语言装载到内存中的哪个地址，这样就可以在7c00进行执行了。 二三四行是为了将ds（数据段寄存器）和es（附加段寄存器）两个段指向与cs（代码段寄存器，对应于内存中的存放代码的内存区域，用来存放内存代码段区域的入口地址（段基址））相同的段，以便以后操作时能定位到正确位置，由于段寄存器不能直接mov，所以这里需要通用寄存器ax进行中转，mov DST,SRC就是把SRC送到DST中。 call DispStr就是调用DispStr子程序，相关功能就是显示字符串“Hello, OS world”，之后jmp $进入无限循环。 DispStr：第一行显而易见会将BootMessage的地址传给ax，而BootMessage就只定义了一个“Hello, OS world”字符串，所以这里ax的地址就是“Hello, OS world”的首地址了。 之后就是打印显示的工作了，这里需要用到int 10h中断，他是BIOS对显示器和屏幕所提供的服务程序。可以参考int 10的相关说明，这里我们的需求是打印显示字符串，所以用到的是这个，这里简单说明一下： 123456789101112131415161718192021222324252627AH = 13hAL = write mode (see bit settings below) = 0 string is chars only, attribute in BL, cursor not moved = 1 string is chard only, attribute in BL, cursor moved = 2 string contains chars and attributes, cursor not moved = 3 string contains chars and attributes, cursor movedBH = video page numberBL = attribute if mode 0 or 1 (AL bit 1=0)CX = length of string (ignoring attributes)DH = row coordinateDL = column coordinateES:BP = pointer to stringBit settings for write mode (register AL):|7|6|5|4|3|2|1|0| AL | | | | | | | `---- 0=don&#x27;t move cursor, 1=move cursor | | | | | | `----- 0=BL has attributes, 1=string has attributes `---------------- unusedreturns nothing- BEL, BS, CR, LF are treated as ASCII control codes- wraps data and scrolls if unable to fit data on one line ES:BP需要指向要显示的字符串指针，之前我们将字符串指针指向了ax，所以这里把bp指向ax就行：mov bp, axCX为字符串的长度，这里为16：mov cx, 16 AH，AL分别为AX寄存器的高8位和低8位。这个中断需要AH为13，AL为相关模式，这里用1，所以mov ax, 01301h就是设置AH为13，AL为01 BH，BL同理，即为BX寄存器的高8位和低8位，分别设置视频页号和属性（这里就是颜色）我们还没有对视频分页，这里视频页号取0就行，BL取0c（黑底红字）：mov bx, 000ch DH和DL分别为行列坐标，这里设置列坐标为0：mov dl, 0 最后调用int 10中断：int 10h最后使用ret转移，结束了这一部分子程序。 之后的times 510-($-$$) db 0$代表当前行行首的标号 $$代表当前段的起始汇编地址，times语义为重复这句代码就表示将0这个字节重读510-($-$$)遍，就是一直填充0直到程序有510个字节，这样加上最后的结束标志0xaa55占用的2个字节，一共刚好512字节了。 现在分别执行： 123nasm boot.asm -o boot.bindd if=boot.bin of=boot.img bs=512 count=1qemu-system-x86_64 -fda boot.img -boot a -m 64 -localtime 第一行是nasm src -o des命令，进行src汇编代码编译为des目标文件第二行是dd指令，在指定大小内对一个文件进行拷贝，并在拷贝的同时进行指定的转换。参数很好理解，具体可以参考这个的说明。第三行是qemu仿真器，可以简单理解为虚拟机，这里用到的参数-fda&#x2F;-fdb “文件名” 使用“文件名”作为磁盘0&#x2F;1镜像；-boot [a|d|c] 使用磁盘a，光盘d，或者硬盘c启动；-m容量指定内存的大小，单位是MB；-localtime使用qemu默认的UTC。 运行成功的话可以看到这个：","categories":[{"name":"os","slug":"os","permalink":"http://gloriaswaterpool.com/categories/os/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://gloriaswaterpool.com/tags/linux/"}]},{"title":"学习一个vulkan(30)-多重采样","slug":"学习一个vulkan-30-多重采样","date":"2018-12-01T01:48:21.000Z","updated":"2022-07-23T03:12:46.228Z","comments":true,"path":"2018/12/01/学习一个vulkan-30-多重采样/","link":"","permalink":"http://gloriaswaterpool.com/2018/12/01/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-30-%E5%A4%9A%E9%87%8D%E9%87%87%E6%A0%B7/","excerpt":"继续上一次的","text":"继续上一次的 介绍我们的程序现在可以加载纹理的多个细节级别了，在渲染图像远离相机的时候进行相应的修复。现在图像更平滑，但仔细观察后，您会发现沿着绘制几何形状边缘的会有锯齿。当我们渲染四边形时，这在我们的一个早期程序中尤为明显： 这种糟糕的效果称为混叠（aliasing），这是有限的像素用于渲染的导致结果。由于没有无限分辨率的显示器，因此从某种程度上来说它总会发生。有很多方法可以解决这个问题，在本章中我们将重点讨论一个比较流行的方法：多重采样抗锯齿（MSAA）。 在普通渲染中，是基于单个采样点确定像素颜色的，在大多数情况下，该采样点都是屏幕上的目标像素的中心。如果绘制线的一部分通过某个像素但未覆盖采样点，则该像素将留空，从而导致锯齿状的“阶梯”效果。 MSAA所做的是它使用每个像素的多个采样点（因此得名）来确定其最终颜色。正如所预料的那样，更多的样本会带来更好的结果，但是它的计算成本也更高。 获取采样数量让我们从确定硬件可以使用的采样数量开始。大多数现代GPU支持至少8个采样点，但能不保证这个数字在任何地方都是相同的。我们将通过添加新的类成员来查询： 123...VkSampleCountFlagBits msaaSamples = VK_SAMPLE_COUNT_1_BIT;... 默认情况下，我们每个像素只使用一个样本，这相当于没有多重采样，在这种情况下，最终图像将保持不变。可以从与我们选择的物理设备关联的VkPhysicalDeviceProperties中提取确切的最大样本数。我们正在使用深度缓冲区，因此我们必须同时考虑颜色和深度的样本计数，其中较低的一个将是我们可以支持的最大值。 添加一个为我们获取此信息的函数： 1234567891011121314VkSampleCountFlagBits getMaxUsableSampleCount() &#123; VkPhysicalDeviceProperties physicalDeviceProperties; vkGetPhysicalDeviceProperties(physicalDevice, &amp;physicalDeviceProperties); VkSampleCountFlags counts = std::min(physicalDeviceProperties.limits.framebufferColorSampleCounts, physicalDeviceProperties.limits.framebufferDepthSampleCounts); if (counts &amp; VK_SAMPLE_COUNT_64_BIT) &#123; return VK_SAMPLE_COUNT_64_BIT; &#125; if (counts &amp; VK_SAMPLE_COUNT_32_BIT) &#123; return VK_SAMPLE_COUNT_32_BIT; &#125; if (counts &amp; VK_SAMPLE_COUNT_16_BIT) &#123; return VK_SAMPLE_COUNT_16_BIT; &#125; if (counts &amp; VK_SAMPLE_COUNT_8_BIT) &#123; return VK_SAMPLE_COUNT_8_BIT; &#125; if (counts &amp; VK_SAMPLE_COUNT_4_BIT) &#123; return VK_SAMPLE_COUNT_4_BIT; &#125; if (counts &amp; VK_SAMPLE_COUNT_2_BIT) &#123; return VK_SAMPLE_COUNT_2_BIT; &#125; return VK_SAMPLE_COUNT_1_BIT;&#125; 我们会使用此函数在物理设备选择过程中设置msaaSamples变量，为此，我们还必须稍微修改pickPhysicalDevice函数： 1234567891011void pickPhysicalDevice() &#123; ... for (const auto&amp; device : devices) &#123; if (isDeviceSuitable(device)) &#123; physicalDevice = device; msaaSamples = getMaxUsableSampleCount(); break; &#125; &#125; ...&#125; 设置渲染目标在MSAA中，每个像素在屏幕外缓冲区中进行采样，然后将其渲染到屏幕上。这个新缓冲区与我们渲染的常规图像略有不同-它们必须能够为每个像素存储多个采样点。一旦创建了多重采样缓冲区，就必须将其解析为默认的帧缓冲区（每个像素只存储一个采样点）。这就是为什么我们必须创建一个额外的渲染目标并修改我们当前的绘制过程。我们只需要一个渲染目标，因为一次只有一个绘制操作是活动的，就像深度缓冲一样。添加以下类成员： 12345...VkImage colorImage;VkDeviceMemory colorImageMemory;VkImageView colorImageView;... 这个新图像必须存储每个像素所需的采样数，因此我们需要在图像创建过程中将此数字传递给VkImageCreateInfo。在createImage函数添加一个numSamples参数： 1234void createImage(uint32_t width, uint32_t height, uint32_t mipLevels, VkSampleCountFlagBits numSamples, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory) &#123; ... imageInfo.samples = numSamples; ... 现在，使用VK_SAMPLE_COUNT_1_BIT更新对此函数的所有调用-随着程序实现的进展，我们将使用适当的值替换它： 123createImage(swapChainExtent.width, swapChainExtent.height, 1, VK_SAMPLE_COUNT_1_BIT, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);...createImage(texWidth, texHeight, mipLevels, VK_SAMPLE_COUNT_1_BIT, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory); 我们现在将创建一个多重采样颜色缓冲区。添加一个createColorResources函数，注意我们在这里使用msaaSamples作为createImage的函数参数。我们这里只使用一个mip级别，因为在每个像素具有多个样本的图像的情况下，Vulkan规范强制执行此操作，另外，此颜色缓冲区也不需要mipmap，因为它不会用作纹理： 12345678void createColorResources() &#123; VkFormat colorFormat = swapChainImageFormat; createImage(swapChainExtent.width, swapChainExtent.height, 1, msaaSamples, colorFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, colorImage, colorImageMemory); colorImageView = createImageView(colorImage, colorFormat, VK_IMAGE_ASPECT_COLOR_BIT, 1); transitionImageLayout(colorImage, colorFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, 1);&#125; 为了保持一致性，在createDepthResources之前调用该函数： 123456void initVulkan() &#123; ... createColorResources(); createDepthResources(); ...&#125; 您可能会注意到新创建的彩色图像使用从VK_IMAGE_LAYOUT_UNDEFINED到VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL的转换方式，这是我们处理的新变化。考虑这一点，需要更改transitionImageLayout函数： 12345678910111213void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, uint32_t mipLevels) &#123; ... else if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL) &#123; barrier.srcAccessMask = 0; barrier.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; destinationStage = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT; &#125; else &#123; throw std::invalid_argument(&quot;unsupported layout transition!&quot;); &#125; ...&#125; 现在我们已经有了一个多重采样颜色缓冲区，现在是时候处理深度了。修改createDepthResources并更新深度缓冲区使用的采样数： 12345void createDepthResources() &#123; ... createImage(swapChainExtent.width, swapChainExtent.height, 1, msaaSamples, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory); ...&#125; 我们现在已经创建了几个新的Vulkan资源，所以我们不要忘记在清理它们： 123456void cleanupSwapChain() &#123; vkDestroyImageView(device, colorImageView, nullptr); vkDestroyImage(device, colorImage, nullptr); vkFreeMemory(device, colorImageMemory, nullptr); ...&#125; 更新recreateSwapChain，以便在调整窗口大小时以正确的分辨率重新创建新的彩色图像： 1234567void recreateSwapChain() &#123; ... createGraphicsPipeline(); createColorResources(); createDepthResources(); ...&#125; 我们完成了最初的MSAA设置，现在我们需要在我们的图形管道，帧缓冲，渲染通道中开始使用这个新资源并查看结果！ 添加新附件我们先来处理渲染过程。修改createRenderPass并更新颜色和深度附件创建信息的结构： 1234567void createRenderPass() &#123; ... colorAttachment.samples = msaaSamples; colorAttachment.finalLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; ... depthAttachment.samples = msaaSamples; ... 您会注意到我们已将finalLayout从VK_IMAGE_LAYOUT_PRESENT_SRC_KHR更改为VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL，那是因为多重采样图像是无法直接呈现的。我们首先需要将它们解析为常规图像。在深度缓冲区并没有这个需求，因为它不会在那里呈现。因此，我们只需添加一个新的颜色附件，即所谓的解析附件： 1234567891011...VkAttachmentDescription colorAttachmentResolve = &#123;&#125;;colorAttachmentResolve.format = swapChainImageFormat;colorAttachmentResolve.samples = VK_SAMPLE_COUNT_1_BIT;colorAttachmentResolve.loadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;colorAttachmentResolve.storeOp = VK_ATTACHMENT_STORE_OP_STORE;colorAttachmentResolve.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;colorAttachmentResolve.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;colorAttachmentResolve.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;colorAttachmentResolve.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;... 现在必须指示渲染过程将多重采样的彩色图像解析为常规附件。创建一个新的附件引用，该引用将指向将用作解析目标的颜色缓冲区： 12345...VkAttachmentReference colorAttachmentResolveRef = &#123;&#125;;colorAttachmentResolveRef.attachment = 2;colorAttachmentResolveRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;... 将pResolveAttachments子通道结构成员设置为指向新创建的附件引用。这可以让渲染过程定义一个多重采样解析操作，让我们能够将图像渲染到屏幕： 123...subpass.pResolveAttachments = &amp;colorAttachmentResolveRef;... 现在使用新的颜色附件来更新渲染通道信息结构： 123...std::array&lt;VkAttachmentDescription, 3&gt; attachments = &#123;colorAttachment, depthAttachment, colorAttachmentResolve&#125;;... 在渲染过程完成后，修改createFrameBuffers并将新图像视图添加到列表中： 123456789void createFrameBuffers() &#123; ... std::array&lt;VkImageView, 3&gt; attachments = &#123; colorImageView, depthImageView, swapChainImageViews[i] &#125;; ...&#125; 最后，通过修改createGraphicsPipeline告知新创建的管道需要使用多个采样： 12345void createGraphicsPipeline() &#123; ... multisampling.rasterizationSamples = msaaSamples; ...&#125; 现在运行您的程序，您可以看到以下内容： 就像使用mipmapping一样，差异可能不会立即表现出来。仔细看看你会注意到屋顶上的边缘不再是锯齿状的，整个图像看起来比原版更平滑。 当靠近其中一个边缘时，差异会更明显： 质量改进我们当前的MSAA实现存在某些缺陷，这可能会在更复杂的场景中影响输出图像的质量。例如，我们目前还没有解决由着色器混叠引起的潜在问题，即MSAA只会使几何体的边缘变得平滑，而不是进行内部填充。当要呈现平滑多边形时这可能是一个比较好的解决方法，但如果应用的纹理包含高对比度颜色，则仍会有锯齿产生。解决此问题的一种方法是启用样本着色，这将进一步提高图像质量，但需要额外的性能开销： 123456789101112void createLogicalDevice() &#123; ... deviceFeatures.sampleRateShading = VK_TRUE; // enable sample shading feature for the device ...&#125;void createGraphicsPipeline() &#123; ... multisampling.sampleShadingEnable = VK_TRUE; // enable sample shading in the pipeline multisampling.minSampleShading = .2f; // min fraction for sample shading; closer to one is smoother ...&#125; 在本示例中，我们将禁用样本着色，但在某些情况下，质量改进可能会很明显： 总结到达这一步需要做很多工作，但现在你终于有了一个比较好的Vulkan程序基础。您现在拥有的Vulkan基本知识应足以开始探索更多功能，例如： 推送常量（Push constants） 实例渲染（Instanced rendering） 动态一致化（Dynamic uniforms） 单独的图像和采样器描述符（Separate images and sampler descriptors） 管道缓存（Pipeline cache） 多线程命令缓冲区生成（Multi-threaded command buffer generation） 多子通道（Multiple subpasses） 计算着色器（Compute shaders） 目前的程序可以通过多种方式进行扩展，例如添加Blinn-Phong照明（Blinn-Phong lighting），后期处理效果（post-processing effects）和阴影映射（shadow mapping）。您应该能够从其他API的教程中了解这些效果是如何工作的，尽管Vulkan要求十分明确的指明各个过程，但许多概念都是相似的。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(29)-生成Mipmap","slug":"学习一个vulkan-29-生成Mipmap","date":"2018-11-30T01:11:41.000Z","updated":"2022-07-23T03:12:46.212Z","comments":true,"path":"2018/11/30/学习一个vulkan-29-生成Mipmap/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/30/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-29-%E7%94%9F%E6%88%90Mipmap/","excerpt":"继续上一次的","text":"继续上一次的 介绍我们的程序现在可以加载和渲染3D模型了。在本章中，我们将添加另一个功能，即生成mipmap。Mipmap广泛用于游戏和渲染软件，Vulkan让我们可以完全操作它们的创建过程。 Mipmap是预先计算的缩小版图像，每个新图像的宽度和高度都是前一个图像的一半。Mipmap用作细节级别（Level of Detail，LOD）的形式。远离相机的物体将从较小的mip图像中采样纹理。使用较小的图像可提高渲染速度并能够避免产生莫尔图案之类的伪影（artifacts）。下面是一个mipmaps的示例： 图像创建在Vulkan中，每个mip图像都存储在VkImage的不同mip级别（mip levels）中。Mip级别0是原始图像，级别0之后的mip级别通常称为mip链（mip chain）。 创建VkImage时指定mip级别的数量，到目前为止，我们始终将此值设置为1。我们需要根据图像的尺寸计算mip级别的数量。首先，添加一个类成员来存储这个数字： 1234...uint32_t mipLevels;VkImage textureImage;... 一旦我们在createTextureImage中加载纹理，就可以找到mipLevels的值： 1234int texWidth, texHeight, texChannels;stbi_uc* pixels = stbi_load(TEXTURE_PATH.c_str(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha);...mipLevels = static_cast&lt;uint32_t&gt;(std::floor(std::log2(std::max(texWidth, texHeight)))) + 1; 这里计算了mip链中的级别数。max函数选择最大尺寸，log2函数计算该维度除以2的次数。floor函数处理最大维度不是2的幂的情况，添加1以使原始图像具有mip级别。 要使用此值，需要更改createImage，createImageView和transitionImageLayout函数，以允许我们指定mip级别的数量。在函数中添加mipLevels参数： 12345void createImage(uint32_t width, uint32_t height, uint32_t mipLevels, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory) &#123; ... imageInfo.mipLevels = mipLevels; ...&#125; 1234VkImageView createImageView(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags, uint32_t mipLevels) &#123; ... viewInfo.subresourceRange.levelCount = mipLevels; ... 1234void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout, uint32_t mipLevels) &#123; ... barrier.subresourceRange.levelCount = mipLevels; ... 更新对这些函数的所有调用以使用正确的值： 123createImage(swapChainExtent.width, swapChainExtent.height, 1, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);...createImage(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory); 12345swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT, 1);...depthImageView = createImageView(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT, 1);...textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_ASPECT_COLOR_BIT, mipLevels); 123transitionImageLayout(depthImage, depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, 1);...transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels); 生成Mipmap我们的纹理图像现在具有多个mip级别，但是临时缓冲区只能用于填充mip级别0，其他级别仍未定义。为了填补这些级别，我们需要从我们拥有的单个级别来生成数据。我们将使用vkCmdBlitImage命令。此命令执行复制，缩放和筛选操作，我们将多次调用它来将数据位块传输（blit）到纹理图像的每个级别。 VkCmdBlit被认为是传输操作，因此我们必须告知Vulkan我们用作传输的源和目标的纹理图像。将VK_IMAGE_USAGE_TRANSFER_SRC_BIT添加到createTextureImage中纹理图像的用法标志中： 123...createImage(texWidth, texHeight, mipLevels, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);... 与其他图像操作一样，vkCmdBlitImage依赖于其操作的图像的布局，我们可以将整个图像转换为VK_IMAGE_LAYOUT_GENERAL，但这很可能很慢。为获得最佳性能，源映像应位于VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL中，目标映像应位于VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL中。Vulkan允许我们独立转换图像的每个mip级别。每个 一次只处理两个mip级别，因此我们可以在blit命令间歇的时候将级别转换为的最佳布局。 transitionImageLayout只对整个图像执行布局转换，因此我们还需要编写一些管道屏障命令。删除createTextureImage中现有的转换为VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL的代码： 12345...transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels); copyBufferToImage(stagingBuffer, textureImage, static_cast&lt;uint32_t&gt;(texWidth), static_cast&lt;uint32_t&gt;(texHeight));//transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps... 这将使纹理图像的每个级别都保留在VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL。在读取blit命令完成后，每个级别将转换为VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL。 我们现在要编写生成mipmap的函数： 123456789101112131415void generateMipmaps(VkImage image, int32_t texWidth, int32_t texHeight, uint32_t mipLevels) &#123; VkCommandBuffer commandBuffer = beginSingleTimeCommands(); VkImageMemoryBarrier barrier = &#123;&#125;; barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; barrier.image = image; barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; barrier.subresourceRange.baseArrayLayer = 0; barrier.subresourceRange.layerCount = 1; barrier.subresourceRange.levelCount = 1; endSingleTimeCommands(commandBuffer);&#125; 我们将进行多次转换，因此我们将重用此VkImageMemoryBarrier。对于所有屏障，上面设置的字段都将保持不变。每次转换需要更改的是subresourceRange.miplevel，oldLayout，newLayout，srcAccessMask和dstAccessMask。 123456int32_t mipWidth = texWidth;int32_t mipHeight = texHeight;for (uint32_t i = 1; i &lt; mipLevels; i++) &#123;&#125; 该循环将记录每个VkCmdBlitImage命令。请注意，循环变量从1开始，而不是0。 1234567891011barrier.subresourceRange.baseMipLevel = i - 1;barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier); 首先，我们将i-1级别转换为VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL，此转换将等待前一个blit命令或vkCmdCopyBufferToImage填充级别i-1完成。当前的blit命令也将等待此转换完成。 12345678910111213VkImageBlit blit = &#123;&#125;;blit.srcOffsets[0] = &#123; 0, 0, 0 &#125;;blit.srcOffsets[1] = &#123; mipWidth, mipHeight, 1 &#125;;blit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;blit.srcSubresource.mipLevel = i - 1;blit.srcSubresource.baseArrayLayer = 0;blit.srcSubresource.layerCount = 1;blit.dstOffsets[0] = &#123; 0, 0, 0 &#125;;blit.dstOffsets[1] = &#123; mipWidth &gt; 1 ? mipWidth / 2 : 1, mipHeight &gt; 1 ? mipHeight / 2 : 1, 1 &#125;;blit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;blit.dstSubresource.mipLevel = i;blit.dstSubresource.baseArrayLayer = 0;blit.dstSubresource.layerCount = 1; 接下来，我们指定将在blit操作中使用的区域。源mip级别为i-1，目标mip级别为i。srcOffsets数组的两个元素确定数据中进行blit的3D区域，dstOffsets确定数据将被blit到的区域。dstOffsets[1]的X和Y维度需要除以2，因为每个mip级别是前一级别的一半。srcOffsets[1]和dstOffsets[1]的Z维度必须为1，因为2D图像的深度为1。 12345vkCmdBlitImage(commandBuffer, image, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;blit, VK_FILTER_LINEAR); 现在，我们记录blit命令。请注意，textureImage会用作srcImage和dstImage参数。这是因为我们是在同一图像的不同级别之间进行blitting的。源mip级别刚刚转换为VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL，目标级别仍然是来自createTextureImage中的VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL。 最后一个参数允许我们指定要在blit中使用的VkFilter，我们在制作VkSampler时具有相同的过滤选项，我们使用VK_FILTER_LINEAR来启用插值。 12345678910barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier); 此屏障将mip级别i-1转换为VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL。此转换等待当前blit命令完成，而所有采样操作都将等待此转换完成。 1234 ... if (mipWidth &gt; 1) mipWidth /= 2; if (mipHeight &gt; 1) mipHeight /= 2;&#125; 在循环结束时，我们将当前的mip尺寸除以2。我们在每次除法之前都要检查各个维度，以确保维度的值永远不会变为0。这处理了图像不是方形的情况，在这种情况下其中一个mip尺寸将在另一个尺寸之前达到1，发生这种情况时，对于所有剩余的级别，该维度都应保持为1。 1234567891011121314 barrier.subresourceRange.baseMipLevel = mipLevels - 1; barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL; barrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT; vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier); endSingleTimeCommands(commandBuffer);&#125; 在我们结束命令缓冲区之前，我们再插入一个管道屏障。此屏障将最后一个mip级别从VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL转换为VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL。这不是由循环处理的，因为最后一个mip级别从不进行blit操作。 最后，在createTextureImage中添加对generateMipmaps的调用： 12345transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, mipLevels); copyBufferToImage(stagingBuffer, textureImage, static_cast&lt;uint32_t&gt;(texWidth), static_cast&lt;uint32_t&gt;(texHeight));//transitioned to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL while generating mipmaps...generateMipmaps(textureImage, texWidth, texHeight, mipLevels); 现在我们的纹理图像的mipmap现在已经填充完毕了。 线性过滤支持使用像vkCmdBlitImage这样的内置函数生成所有mip级别非常方便，但遗憾的是并不能保证所有平台都支持。它需要我们的纹理图像格式支持线性过滤，这一点可以使用vkGetPhysicalDeviceFormatProperties函数进行检查。我们将为generateMipmaps函数添加一个检查。 首先添加一个指定图像格式的附加参数： 12345678910void createTextureImage() &#123; ... generateMipmaps(textureImage, VK_FORMAT_R8G8B8A8_UNORM, texWidth, texHeight, mipLevels);&#125;void generateMipmaps(VkImage image, VkFormat imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels) &#123; ...&#125; 在generateMipmaps函数中，使用vkGetPhysicalDeviceFormatProperties来获取纹理图像格式的属性： 1234567void generateMipmaps(VkImage image, VkFormat imageFormat, int32_t texWidth, int32_t texHeight, uint32_t mipLevels) &#123; // Check if image format supports linear blitting VkFormatProperties formatProperties; vkGetPhysicalDeviceFormatProperties(physicalDevice, imageFormat, &amp;formatProperties); ... VkFormatProperties结构有三个名为linearTilingFeatures，optimalTilingFeatures和bufferFeatures的字段，每个字段都描述了相应格式的使用方式，具体取决于它的使用方式。我们使用的是最佳平铺格式来创建纹理图像，因此我们需要检查optimalTilingFeatures。可以使用VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT检查对线性过滤功能的支持： 123if (!(formatProperties.optimalTilingFeatures &amp; VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT)) &#123; throw std::runtime_error(&quot;texture image format does not support linear blitting!&quot;);&#125; 在这种情况下有两种选择。您可以实现一个函数，搜索某个常见的支持线性blitting的纹理图像格式，或者您可以使用像stb_image_resize这样的库在软件中自己实现mipmap的生成，然后可以按照加载原始图像的方式将每个mip级别加载到图像中。 应该注意的是，实际上在运行时生成mipmap级别是不常见的。通常它们被预生成并存储在基本级别旁边的纹理文件中以提高加载速度。实现在软件中调整大小并从文件加载多个级别是留给读者的练习。 采样当VkImage保存mipmap数据时，VkSampler控制渲染时读取数据的方式。Vulkan允许我们指定minLod，maxLod，mipLodBias和mipmapMode（“Lod”表示“细节级别”）。采样纹理时，采样器根据以下伪代码进行mip级别的选择： 12345678910lod = getLodLevelFromScreenSize(); //smaller when the object is close, may be negativelod = clamp(lod + mipLodBias, minLod, maxLod);level = clamp(floor(lod), 0, texture.mipLevels - 1); //clamped to the number of mip levels in the textureif (mipmapMode == VK_SAMPLER_MIPMAP_MODE_NEAREST) &#123; color = sample(level);&#125; else &#123; color = blend(sample(level), sample(level + 1));&#125; 如果samplerInfo.mipmapMode是VK_SAMPLER_MIPMAP_MODE_NEAREST，则lod选择要从中采样的mip级别。如果mipmap模式是VK_SAMPLER_MIPMAP_MODE_LINEAR，则lod用于选择要采样的两个mip级别，然后对这些级别进行采样，并将结果线性混合。 采样操作也受到lod的影响： 12345if (lod &lt;= 0) &#123; color = readTexture(uv, magFilter);&#125; else &#123; color = readTexture(uv, minFilter);&#125; 如果物体靠近相机，则使用magFilter作为滤镜，如果物体离相机较远，则使用minFilter。通常lod是非负的，关闭相机时值为0。mipLodBias让我们强迫Vulkan可以使用比通常使用的值更低的lod和level。 要查看运行的结果，我们需要为textureSampler选择相应的值。我们已经将minFilter和magFilter设置为使用VK_FILTER_LINEAR了。现在只需要为minLod，maxLod，mipLodBias和mipmapMode选择值。 12345678void createTextureSampler() &#123; ... samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR; samplerInfo.minLod = 0; // Optional samplerInfo.maxLod = static_cast&lt;float&gt;(mipLevels); samplerInfo.mipLodBias = 0; // Optional ...&#125; 为了允许使用所有范围的mip级别，我们将minLod设置为0，并将maxLod设置为mip级别的数量。我们不需要更改lod值，因此将mipLodBias设置为0。 现在运行程序，可以看到以下内容： 差异并不明显，因为我们的场景非常简单。如果仔细观察，还是会有细微差别。 最明显的区别是木牌上的文字。使用mipmap时，文字会平滑处理。如果没有mipmaps，那么文字就会有莫尔条纹的粗糙边缘和间隙。 您可以使用采样器设置来查看它们如何影响mipmapping。例如，通过更改minLod，您可以强制采样器不使用最低的mip级别： 1samplerInfo.minLod = static_cast&lt;float&gt;(mipLevels / 2); 这些设置将生成此图像： 这是当物体远离相机时将使用的更高mip级别的方式。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(28)-加载模型","slug":"学习一个vulkan-28-加载模型","date":"2018-11-29T01:05:55.000Z","updated":"2022-07-23T03:12:46.212Z","comments":true,"path":"2018/11/29/学习一个vulkan-28-加载模型/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/29/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-28-%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/","excerpt":"继续上一次的","text":"继续上一次的 介绍您的程序现在可以渲染纹理3D网格了，但是顶点和索引数组中的几何形状现在不是很有趣。在本章中，我们将扩展程序以从实际模型文件中加载顶点和索引，来使图形卡实际上做一些工作。 许多图形API教程在这样的章节中让读者编写自己的OBJ加载器。这样做的问题是任何有趣的3D应用程序可能需要某种功能，但是该文件格式不支持，比如骨骼动画skeletal animation。我们将在本章中从OBJ模型加载网格数据，但我们将更多地关注网格数据与程序本身的集成，而不是从文件中加载网格数据的细节。 库我们将使用tinyobjloader库从OBJ文件加载顶点和面。它很有效并且很容易集成，因为它是像stb_image这样的单个文件库。转到上面链接的存储库并将tiny_obj_loader.h文件下载到库目录中的文件夹。确保使用master分支中的文件版本，因为最新的官方发行版已过时。Visual Studio将其中包含tiny_obj_loader.h的目录添加到Additional Include Directories路径。 Makefile将tiny_obj_loader.h的目录添加到GCC的include目录中： 1234567VULKAN_SDK_PATH = /home/user/VulkanSDK/x.x.x.x/x86_64STB_INCLUDE_PATH = /home/user/libraries/stbTINYOBJ_INCLUDE_PATH = /home/user/libraries/tinyobjloader...CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/include -I$(STB_INCLUDE_PATH) -I$(TINYOBJ_INCLUDE_PATH) 样本网格在本章中，我们还不会启用照明功能，这有助于使用具有照明烘焙到纹理中的样本模型。查找此类模型的简便方法是在Sketchfab上查询，该站点上的许多模型都以OBJ格式提供，并具有许可许可。 在本教程中，我决定使用Escadrone的Chalet Hippolyte Chassande Baroz模型。我调整了模型的大小和方向，以便将其用作当前几何体的替代品。 chalet.obj chalet.jpg 它有五十万个三角形，所以可以成为我们应用程序的一个很好的基准。在这里随意使用自己的模型文件，但是要确保它们是由一种材质构成的，尺寸约为1.5 x1.5x1.5。如果它比这个大，那么你将不得不改变视图矩阵。将模型文件放在shaders和textures旁边的新models目录中，并将纹理图像放在textures目录中。 在程序中新建两个新的配置变量来定义模型和纹理路径： 12345const int WIDTH = 800;const int HEIGHT = 600;const std::string MODEL_PATH = &quot;models/chalet.obj&quot;;const std::string TEXTURE_PATH = &quot;textures/chalet.jpg&quot;; 并更新createTextureImage以使用这个路径变量： 1stbi_uc* pixels = stbi_load(TEXTURE_PATH.c_str(), &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha); 加载顶点和索引我们现在要从模型文件加载顶点和索引，所以你现在应该删除全局vertices和indices数组。将它们替换为非const的容器作为类成员： 1234std::vector&lt;Vertex&gt; vertices;std::vector&lt;uint32_t&gt; indices;VkBuffer vertexBuffer;VkDeviceMemory vertexBufferMemory; 您应该将索引的类型从uint16_t更改为uint32_t，因为将会有比65535更多的顶点。记得还要更改vkCmdBindIndexBuffer参数： 1vkCmdBindIndexBuffer(commandBuffers[i], indexBuffer, 0, VK_INDEX_TYPE_UINT32); tinyobjloader库的包含方式与STB库相同。包含tiny_obj_loader.h文件并确保在源文件中定义TINYOBJLOADER_IMPLEMENTATION以包含函数体避免链接器错误： 12#define TINYOBJLOADER_IMPLEMENTATION#include &lt;tiny_obj_loader.h&gt; 我们现在要编写一个loadModel函数，该函数利用这个库来使用网格中的顶点数据填充顶点和索引容器。应该在创建顶点和索引缓冲区之前调用它： 12345678910111213void initVulkan() &#123; ... loadModel(); createVertexBuffer(); createIndexBuffer(); ...&#125;...void loadModel() &#123;&#125; 通过调用tinyobj::LoadObj函数将模型加载到库的数据结构中： 12345678910void loadModel() &#123; tinyobj::attrib_t attrib; std::vector&lt;tinyobj::shape_t&gt; shapes; std::vector&lt;tinyobj::material_t&gt; materials; std::string warn, err; if (!tinyobj::LoadObj(&amp;attrib, &amp;shapes, &amp;materials, &amp;warn, &amp;err, MODEL_PATH.c_str())) &#123; throw std::runtime_error(warn + err); &#125;&#125; OBJ文件由位置，法线，纹理坐标和面组成。面由任意数量的顶点组成，其中每个顶点通过索引来引用位置，法线，纹理坐标或他们的组合。这使得不仅可以重用整个顶点，还可以重用单个属性。 attrib容器在其attrib.vertices，attrib.normals和attrib.texcoords向量中保存了所有的位置，法线和纹理坐标。shapes容器包含了所有单独的对象及其面，每个面由顶点数组组成，每个顶点包含位置，法线和纹理坐标属性的索引。OBJ模型还可以定义每个面的材质和纹理，但我们将忽略它们。 err字符串包含错误，warn字符串包含加载文件时发生的警告，如缺少材料定义。如果LoadObj函数返回false，则仅加载失败。如上所述，OBJ文件中的面实际上可以包含任意数量的顶点，而我们的应用程序只能渲染三角形，幸运的是，LoadObj有一个可选参数来自动对这些面进行三角测量，默认情况下启用它。 我们将把文件中的所有面组合到一个单一模型中，所以只需遍历所有形状： 123for (const auto&amp; shape : shapes) &#123;&#125; 三角测量功能已经确保了每个面有三个顶点，所以我们现在可以直接迭代顶点并将它们直接转储到我们的顶点向量中： 12345678for (const auto&amp; shape : shapes) &#123; for (const auto&amp; index : shape.mesh.indices) &#123; Vertex vertex = &#123;&#125;; vertices.push_back(vertex); indices.push_back(indices.size()); &#125;&#125; 为简单起见，我们假设每个顶点现在都是唯一的，因此只做简单的自动增量索引。index变量的类型为tinyobj::index_t，它包含了vertex_index，normal_index和texcoord_index成员。我们需要使用这些索引来查找attrib数组中的实际顶点属性： 123456789101112vertex.pos = &#123; attrib.vertices[3 * index.vertex_index + 0], attrib.vertices[3 * index.vertex_index + 1], attrib.vertices[3 * index.vertex_index + 2]&#125;;vertex.texCoord = &#123; attrib.texcoords[2 * index.texcoord_index + 0], attrib.texcoords[2 * index.texcoord_index + 1]&#125;;vertex.color = &#123;1.0f, 1.0f, 1.0f&#125;; 不幸的是，attrib.vertices数组是一个float值数组，而不是glm::vec3类型，所以你需要将索引乘以3。类似地，每个条目有两个纹理坐标分量。0，1，2的偏移分别用于访问X，Y和Z分量，或者在纹理坐标系访问U和V分量。 现在运行程序并启用优化（例如，Visual Studio中的Release模式和GCC的-O3编译器标志），这是必要的，否则加载模型将非常缓慢。您应该可以看到如下内容： 太棒了，几何体看起来是正确的，但纹理是怎么了？这是由于Vulkan中纹理坐标的原点是左上角，而OBJ格式则是左下角。通过翻转纹理坐标的垂直分量可以解决这个问题： 1234vertex.texCoord = &#123; attrib.texcoords[2 * index.texcoord_index + 0], 1.0f - attrib.texcoords[2 * index.texcoord_index + 1]&#125;; 当您再次运行程序时，您现在应该可以看到正确的结果： 所有这些努力终于开始得到回报了。 顶点重复数据删除不幸的是，我们还没有真正利用到索引缓冲区的优势。vertices向量包含大量重复的顶点数据，因为许多顶点包含在了多个三角形中。我们应该只保留唯一的顶点并使用索引缓冲区在它们出现时重用它们。实现此目的的一种简单方法是使用map或unordered_map来跟踪唯一顶点和相应的索引： 1234567891011121314151617181920#include &lt;unordered_map&gt;...std::unordered_map&lt;Vertex, uint32_t&gt; uniqueVertices = &#123;&#125;;for (const auto&amp; shape : shapes) &#123; for (const auto&amp; index : shape.mesh.indices) &#123; Vertex vertex = &#123;&#125;; ... if (uniqueVertices.count(vertex) == 0) &#123; uniqueVertices[vertex] = static_cast&lt;uint32_t&gt;(vertices.size()); vertices.push_back(vertex); &#125; indices.push_back(uniqueVertices[vertex]); &#125;&#125; 每次我们从OBJ文件中读取一个顶点时，我们都会检查是否已经看到过具有完全相同位置和纹理坐标的顶点。如果没有，我们将它添加到vertices并将其索引存储在uniqueVertices容器中。之后，我们将新顶点的索引添加到indices。如果我们之前已经看到完全相同的顶点，那么我们在uniqueVertices中查找其索引并将该索引存储在索引中。 该程序现在无法编译，因为使用像我们的Vertex结构这样的用户定义类型作为哈希表中的键还需要我们实现两个函数：等号测试和哈希计算。前者很容易通过重载Vertex结构中的&#x3D;&#x3D;运算符来实现： 123bool operator==(const Vertex&amp; other) const &#123; return pos == other.pos &amp;&amp; color == other.color &amp;&amp; texCoord == other.texCoord;&#125; Vertex的哈希函数是通过为std::hash指定模板特化来实现的。散列函数是一个复杂的主题，但cppreference.com建议使用以下方法组合结构的字段以创建质量比较高的散列函数： 123456789namespace std &#123; template&lt;&gt; struct hash&lt;Vertex&gt; &#123; size_t operator()(Vertex const&amp; vertex) const &#123; return ((hash&lt;glm::vec3&gt;()(vertex.pos) ^ (hash&lt;glm::vec3&gt;()(vertex.color) &lt;&lt; 1)) &gt;&gt; 1) ^ (hash&lt;glm::vec2&gt;()(vertex.texCoord) &lt;&lt; 1); &#125; &#125;;&#125; 这段代码应放在Vertex结构之外。需要使用以下标头包含GLM类型的哈希函数： 12#define GLM_ENABLE_EXPERIMENTAL#include &lt;glm/gtx/hash.hpp&gt; 散列函数在gtx文件夹中定义，这意味着它在技术上仍然是GLM的实验扩展。因此，您需要定义GLM_ENABLE_EXPERIMENTAL才能使用它。这意味着API可能会在未来新版本的GLM中进行更改，但实际上却非常稳定。 您现在应该能够成功编译并运行您的程序。如果你检查顶点的大小，那么你会发现它已经从1,500,000缩小到265,645！这意味着每个顶点在平均会在约6个三角形中重复使用。这这样做无疑为我们节省了大量的GPU内存。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(27)-深度缓冲","slug":"学习一个vulkan-27-深度缓冲","date":"2018-11-28T02:02:38.000Z","updated":"2022-07-23T03:12:46.212Z","comments":true,"path":"2018/11/28/学习一个vulkan-27-深度缓冲/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/28/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-27-%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%86%B2/","excerpt":"继续上一次的","text":"继续上一次的 介绍到目前为止我们使用的几何体被虽然投射到3D空间中，但它仍然是完全平坦的。在本章中，我们将向位置添加Z坐标以为3D网格做准备。我们将使用这个第三个坐标在当前正方形上方放置一个正方形，来查看几何未按深度排序时出现的问题。 三维几何更改Vertex结构以使用3D矢量表示位置，并更新相应的VkVertexInputAttributeDescription中的格式： 123456789101112131415161718struct Vertex &#123; glm::vec3 pos; glm::vec3 color; glm::vec2 texCoord; ... static std::array&lt;VkVertexInputAttributeDescription, 3&gt; getAttributeDescriptions() &#123; std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions = &#123;&#125;; attributeDescriptions[0].binding = 0; attributeDescriptions[0].location = 0; attributeDescriptions[0].format = VK_FORMAT_R32G32B32_SFLOAT; attributeDescriptions[0].offset = offsetof(Vertex, pos); ... &#125;&#125;; 接下来，更新顶点着色器以接受并转换3D坐标作为输入，不要忘记之后重新编译它。 123456789layout(location = 0) in vec3 inPosition;...void main() &#123; gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 1.0); fragColor = inColor; fragTexCoord = inTexCoord;&#125; 最后，更新vertices容器以包含Z坐标： 123456const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;-0.5f, -0.5f, 0.0f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, -0.5f, 0.0f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f, 0.0f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;, &#123;1.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f, 0.0f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;&#125;; 如果您现在运行您的应用程序，那么您会看到与以前完全相同的结果。是时候添加一些额外的几何体来使场景更有趣，并展示我们将在本章中需要解决的问题了。复制顶点以定义当前正方形下方的位置，如下所示： 使用-0.5f的Z坐标并为额外的正方形添加适当的索引： 12345678910111213141516const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;-0.5f, -0.5f, 0.0f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, -0.5f, 0.0f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f, 0.0f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;, &#123;1.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f, 0.0f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, -0.5f, -0.5f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, -0.5f, -0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f, -0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;, &#123;1.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f, -0.5f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;&#125;;const std::vector&lt;uint16_t&gt; indices = &#123; 0, 1, 2, 2, 3, 0, 4, 5, 6, 6, 7, 4&#125;; 现在运行你的程序，你会看到类似Escher插图的东西： 问题是下方的片段被绘制在上方的片段上，这仅仅是因为它是后出现在索引数组中的。有两种方法可以解决这个问题： 按从后到前的深度排序依次绘制 使用深度缓冲区进行深度测试 第一种方法通常用于绘制透明对象，因为与顺序无关的透明度是一个难以解决问题。然而，更常见地是使用深度缓冲（depth buffer）解决按深度排序片段的问题。深度缓冲区是一个附加附件，用于存储每个位置的深度，就像颜​​色附件存储每个位置的颜色一样。每次光栅化器生成片段时，深度测试将检查新片段是否比前一片段更接近，如果没有的话，则会被丢弃。通过深度测试的片段会将自己的深度写入深度缓冲区。可以从片段着色器中操纵此值，就像可以操纵颜色输出一样。 1234#define GLM_FORCE_RADIANS#define GLM_FORCE_DEPTH_ZERO_TO_ONE#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt; GLM生成的透视投影矩阵默认使用-1.0到1.0的OpenGL深度范围。我们需要使用GLM_FORCE_DEPTH_ZERO_TO_ONE定义将其配置为使用0.0到1.0的Vulkan范围。 深度图像和视图就像颜色附件一样，深度附件也是基于图像的，不同之处在于交换链不会自动为我们创建深度图像。我们只需要一个深度图像，因为一次只能运行一个绘图操作。深度图像也需要三个资源：图像，内存和图像视图。 123VkImage depthImage;VkDeviceMemory depthImageMemory;VkImageView depthImageView; 创建一个新函数createDepthResources来设置这些资源： 12345678910111213void initVulkan() &#123; ... createCommandPool(); createDepthResources(); createTextureImage(); ...&#125;...void createDepthResources() &#123;&#125; 创建深度图像非常简单。它应和交换链定义的颜色附件有相同的分辨率，适合深度附件的图像用法，最佳平铺方式和设备本地内存。唯一的问题是：深度图像的正确格式是什么？格式必须包含深度组件，由VK_FORMAT_中的_D ?? _表示。 与纹理图像不同，我们不一定需要特定的格式，因为我们不会直接从程序中访问纹素。它需要具有一个合适的精确度，在实际应用中至少要24位。有几种格式符合此要求： VK_FORMAT_D32_SFLOAT：32位浮点数深度 VK_FORMAT_D32_SFLOAT_S8_UINT：32位有符号浮点数深度和8位模板组件 VK_FORMAT_D24_UNORM_S8_UINT：24位浮点数深度和8位模板组件 模板组件用于模板测试，这是一项可与深度测试相结合的附加测试。我们将在以后的章节中讨论这个问题。 我们可以简单地选择VK_FORMAT_D32_SFLOAT格式，因为对它的支持非常普遍（参见硬件数据库），但是可能的话为我们的应用程序添加一些灵活性是很好的。我们将编写一个函数findSupportedFormat，它按照从最理想到最不理想的顺序获取候选格式列表，并检查哪个是第一个支持的： 123VkFormat findSupportedFormat(const std::vector&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features) &#123;&#125; 格式的支持取决于平铺模式和用法，因此我们还必须将这些作为参数包含在内。可以使用vkGetPhysicalDeviceFormatProperties函数查询格式的支持情况： 1234for (VkFormat format : candidates) &#123; VkFormatProperties props; vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &amp;props);&#125; VkFormatProperties结构包含三个字段： linearTilingFeatures：线性平铺支持 optimalTilingFeatures：最佳平铺支持 bufferFeatures：缓冲区支持 这里只有前两个是相关的，我们需要检查函数的tiling参数： 12345if (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) &#123; return format;&#125; else if (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) &#123; return format;&#125; 如果没有候选格式支持所需的用法，那么我们可以返回一个特殊值或只是抛出一个异常： 1234567891011121314VkFormat findSupportedFormat(const std::vector&lt;VkFormat&gt;&amp; candidates, VkImageTiling tiling, VkFormatFeatureFlags features) &#123; for (VkFormat format : candidates) &#123; VkFormatProperties props; vkGetPhysicalDeviceFormatProperties(physicalDevice, format, &amp;props); if (tiling == VK_IMAGE_TILING_LINEAR &amp;&amp; (props.linearTilingFeatures &amp; features) == features) &#123; return format; &#125; else if (tiling == VK_IMAGE_TILING_OPTIMAL &amp;&amp; (props.optimalTilingFeatures &amp; features) == features) &#123; return format; &#125; &#125; throw std::runtime_error(&quot;failed to find supported format!&quot;);&#125; 我们现在创建一个findDepthFormat辅助函数，以选择具有深度组件的格式，该深度组件支持用作深度附件： 1234567VkFormat findDepthFormat() &#123; return findSupportedFormat( &#123;VK_FORMAT_D32_SFLOAT, VK_FORMAT_D32_SFLOAT_S8_UINT, VK_FORMAT_D24_UNORM_S8_UINT&#125;, VK_IMAGE_TILING_OPTIMAL, VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT );&#125; 在这种情况下，请确保使用VK_FORMAT_FEATURE_标志而不是VK_IMAGE_USAGE_，所有这些候选格式都包含深度组件，但后两者也包含模板组件。虽然现在我们还没有使用它，但我们确实需要在使用这些格式的图像上执行布局转换时考虑到这一点。添加一个简单的辅助函数，告诉我们所选的深度格式是否包含模板组件： 123bool hasStencilComponent(VkFormat format) &#123; return format == VK_FORMAT_D32_SFLOAT_S8_UINT || format == VK_FORMAT_D24_UNORM_S8_UINT;&#125; 调用函数以从createDepthResources中查找深度格式： 1VkFormat depthFormat = findDepthFormat(); 我们现在拥有调用createImage和createImageView辅助函数所需的所有信息： 12createImage(swapChainExtent.width, swapChainExtent.height, depthFormat, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, depthImage, depthImageMemory);depthImageView = createImageView(depthImage, depthFormat); 但是，createImageView函数当前是假定子资源始终为VK_IMAGE_ASPECT_COLOR_BIT，因此我们需要将该字段转换为参数： 12345VkImageView createImageView(VkImage image, VkFormat format, VkImageAspectFlags aspectFlags) &#123; ... viewInfo.subresourceRange.aspectMask = aspectFlags; ...&#125; 更新对此函数的所有调用，确保正确无误： 12345swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat, VK_IMAGE_ASPECT_COLOR_BIT);...depthImageView = createImageView(depthImage, depthFormat, VK_IMAGE_ASPECT_DEPTH_BIT);...textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_ASPECT_COLOR_BIT); 这就是深度图像的创建了。我们并不需要映射它或将另一个图像复制到它，因为我们会在渲染过程的开头就清除它，就像颜色附件一样。但是，它仍然还是需要转换为适合深度附件使用的布局。我们可以在渲染过程中像颜色附件那样做，但在这里我选择使用管道屏障，因为转换只需要发生一次： 1transitionImageLayout(depthImage, depthFormat, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL); 未定义的布局可以用作初始布局，因为现有的深度图像内容并不重要。我们需要更新transitionImageLayout中的一些逻辑以使用正确的子资源： 123456789if (newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) &#123; barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT; if (hasStencilComponent(format)) &#123; barrier.subresourceRange.aspectMask |= VK_IMAGE_ASPECT_STENCIL_BIT; &#125;&#125; else &#123; barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;&#125; 虽然我们没有使用到模板组件，但我们还是需要将其包含在深度图像的布局转换中。 最后，添加正确的访问掩码和管道阶段： 123456789101112131415161718192021if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123; barrier.srcAccessMask = 0; barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;&#125; else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123; barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT; sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT; destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;&#125; else if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL) &#123; barrier.srcAccessMask = 0; barrier.dstAccessMask = VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT | VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT; sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; destinationStage = VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT;&#125; else &#123; throw std::invalid_argument(&quot;unsupported layout transition!&quot;);&#125; 深度缓冲区会被读取用来执行深度测试以查看片段是否可见，并且将在绘制新片段时写入。读取发生在VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT阶段，写入发生在VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT阶段。您应该选择与指定操作匹配的最早的管道阶段，以便在需要时可以作为深度附件使用。 渲染过程我们现在要修改createRenderPass以包含深度附件。首先创建VkAttachementDescription： 123456789VkAttachmentDescription depthAttachment = &#123;&#125;;depthAttachment.format = findDepthFormat();depthAttachment.samples = VK_SAMPLE_COUNT_1_BIT;depthAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;depthAttachment.storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;depthAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;depthAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;depthAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;depthAttachment.finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; format应与深度图像本身相同。这次我们不关心深度数据的存储（storeOp），因为它在绘制完成后就不会被使用了，这样硬件可以执行额外的优化。就像颜色缓冲区一样，我们不关心之前的深度的内容，因此我们可以使用VK_IMAGE_LAYOUT_UNDEFINED作为initialLayout。 123VkAttachmentReference depthAttachmentRef = &#123;&#125;;depthAttachmentRef.attachment = 1;depthAttachmentRef.layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL; 为第一个（也是唯一的）子通道添加对附件的引用： 12345VkSubpassDescription subpass = &#123;&#125;;subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;subpass.colorAttachmentCount = 1;subpass.pColorAttachments = &amp;colorAttachmentRef;subpass.pDepthStencilAttachment = &amp;depthAttachmentRef; 与颜色附件不同，子通道只能使用单个深度（+模板）附件，在多个缓冲区上进行深度测试实际上没有任何意义。 123456789std::array&lt;VkAttachmentDescription, 2&gt; attachments = &#123;colorAttachment, depthAttachment&#125;;VkRenderPassCreateInfo renderPassInfo = &#123;&#125;;renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;renderPassInfo.attachmentCount = static_cast&lt;uint32_t&gt;(attachments.size());renderPassInfo.pAttachments = attachments.data();renderPassInfo.subpassCount = 1;renderPassInfo.pSubpasses = &amp;subpass;renderPassInfo.dependencyCount = 1;renderPassInfo.pDependencies = &amp;dependency; 最后，更新VkRenderPassCreateInfo结构以引用这两个附件。 帧缓冲区下一步是修改帧缓冲区的创建以将深度图像绑定到深度附件。转到createFramebuffers并将深度图像视图指定为第二个附件： 12345678910111213std::array&lt;VkImageView, 2&gt; attachments = &#123; swapChainImageViews[i], depthImageView&#125;;VkFramebufferCreateInfo framebufferInfo = &#123;&#125;;framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO;framebufferInfo.renderPass = renderPass;framebufferInfo.attachmentCount = static_cast&lt;uint32_t&gt;(attachments.size());framebufferInfo.pAttachments = attachments.data();framebufferInfo.width = swapChainExtent.width;framebufferInfo.height = swapChainExtent.height;framebufferInfo.layers = 1; 每个交换链图像的颜色附件都不同，但所有这些图像都可以使用相同的深度图像，由于我们的信号量的关系，同一时间只有一个子通道运行。 您还需要将函数调用移动到createFramebuffers以确保在实际创建深度图像视图后调用它： 123456void initVulkan() &#123; ... createDepthResources(); createFramebuffers(); ...&#125; 清除值因为我们现在有多个有VK_ATTACHMENT_LOAD_OP_CLEAR的附件，转到createCommandBuffers并创建一个VkClearValue结构数组： 123456std::array&lt;VkClearValue, 2&gt; clearValues = &#123;&#125;;clearValues[0].color = &#123;0.0f, 0.0f, 0.0f, 1.0f&#125;;clearValues[1].depthStencil = &#123;1.0f, 0&#125;;renderPassInfo.clearValueCount = static_cast&lt;uint32_t&gt;(clearValues.size());renderPassInfo.pClearValues = clearValues.data(); 在Vulkan中，深度缓冲区中的深度范围为0.0到1.0，其中1.0位于远视平面，0.0位于近视平面。深度缓冲区中每个点的初始值应该是最远的深度，即1.0。 深度和模板状态深度附件现在可以使用了，但还需要在图形管道中启用深度测试。它是通过VkPipelineDepthStencilStateCreateInfo结构配置的： 1234VkPipelineDepthStencilStateCreateInfo depthStencil = &#123;&#125;;depthStencil.sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;depthStencil.depthTestEnable = VK_TRUE;depthStencil.depthWriteEnable = VK_TRUE; depthTestEnable字段指定是否应将新片段的深度与深度缓冲区进行比较，以查看是否应丢弃它们。depthWriteEnable字段指定是否应该将通过深度测试的新片段深度实际写入深度缓冲区，这对于绘制透明对象很有用。它们应该与之前渲染的不透明对象进行比较，但不会导致更远的透明对象不被绘制。 1depthStencil.depthCompareOp = VK_COMPARE_OP_LESS; depthCompareOp字段指定执行保留或者丢弃片段的比较细节。我们坚持更低深度&#x3D;更接近的惯例，所以新的片段的深度应该更小。 123depthStencil.depthBoundsTestEnable = VK_FALSE;depthStencil.minDepthBounds = 0.0f; // OptionaldepthStencil.maxDepthBounds = 1.0f; // Optional depthBoundsTestEnable，minDepthBounds和maxDepthBounds字段是可选的，用于深度范围测试，这允许您仅保留落在指定深度范围内的片元。我们不会使用该功能。 123depthStencil.stencilTestEnable = VK_FALSE;depthStencil.front = &#123;&#125;; // OptionaldepthStencil.back = &#123;&#125;; // Optional 最后三个字段配置模板缓冲区操作，我们在本教程中也不会使用它们。如果要使用这些操作，则必须确保深度&#x2F;模板图像的格式包含模板组件。 1pipelineInfo.pDepthStencilState = &amp;depthStencil; 更新VkGraphicsPipelineCreateInfo结构以引用我们刚填充的深度模板状态。如果渲染过程包含深度模板附件，则必须始终指定深度模板状态。 如果您现在运行程序，那么您应该看到几何体的片段现在已正确排序： 处理窗口尺寸变化调整窗口大小以匹配新的颜色附件分辨率时，深度缓冲区的分辨率也需要更改。在这种情况下，扩展recreateSwapChain函数以重新创建深度资源： 12345678910111213void recreateSwapChain() &#123; vkDeviceWaitIdle(device); cleanupSwapChain(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createDepthResources(); createFramebuffers(); createCommandBuffers();&#125; 清理操作应该在交换链清理功能中进行： 1234567void cleanupSwapChain() &#123; vkDestroyImageView(device, depthImageView, nullptr); vkDestroyImage(device, depthImage, nullptr); vkFreeMemory(device, depthImageMemory, nullptr); ...&#125; 恭喜，您的应用程序现在终于可以正确的渲染任意3D几何体了，我们将在下一章中通过绘制纹理模型来尝试。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(26)-纹理映射-组合图像采样器","slug":"学习一个vulkan-26-纹理映射-组合图像采样器","date":"2018-11-27T01:03:17.000Z","updated":"2022-07-23T03:12:46.212Z","comments":true,"path":"2018/11/27/学习一个vulkan-26-纹理映射-组合图像采样器/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/27/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-26-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84-%E7%BB%84%E5%90%88%E5%9B%BE%E5%83%8F%E9%87%87%E6%A0%B7%E5%99%A8/","excerpt":"继续上一次的","text":"继续上一次的 介绍我们在本教程的统一缓冲区章节中第一次了解到了描述符。在本章中，我们将介绍一种新类型的描述符：组合图像采样器（combined image sampler）。此描述符使着色器可以通过采样器对象访问图像资源，就是我们在上一章中创建的那种采样器。 我们将首先修改描述符布局，描述符池和描述符集用来包含新的组合图像采样器描述符。之后，我们将向Vertex中添加纹理坐标，并修改片段着色器以从纹理中读取颜色，而不是仅仅是插入顶点颜色。 更新描述符在createDescriptorSetLayout函数中为组合图像采样器添加VkDescriptorSetLayoutBinding对象，我们只需将它放在统一缓冲区后进行绑定： 123456789101112VkDescriptorSetLayoutBinding samplerLayoutBinding = &#123;&#125;;samplerLayoutBinding.binding = 1;samplerLayoutBinding.descriptorCount = 1;samplerLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;samplerLayoutBinding.pImmutableSamplers = nullptr;samplerLayoutBinding.stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT;std::array&lt;VkDescriptorSetLayoutBinding, 2&gt; bindings = &#123;uboLayoutBinding, samplerLayoutBinding&#125;;VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;;layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;layoutInfo.bindingCount = static_cast&lt;uint32_t&gt;(bindings.size());layoutInfo.pBindings = bindings.data(); 确保设置stageFlags以指示我们打算在片段着色器中使用组合图像采样器描述符，这就是要确定片段颜色的地方了。也可以在顶点着色器中使用纹理采样，例如通过高度图动态地变形顶点的网格。 如果您现在将运行带有验证层的应用程序，那么您将看到它抱怨描述符池无法使用此布局来分配描述符集，因为它还没有任何组合图像采样器描述符。转到createDescriptorPool函数并修改它来包含此描述符的VkDescriptorPoolSize： 1234567891011std::array&lt;VkDescriptorPoolSize, 2&gt; poolSizes = &#123;&#125;;poolSizes[0].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;poolSizes[0].descriptorCount = static_cast&lt;uint32_t&gt;(swapChainImages.size());poolSizes[1].type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;poolSizes[1].descriptorCount = static_cast&lt;uint32_t&gt;(swapChainImages.size());VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;;poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;poolInfo.poolSizeCount = static_cast&lt;uint32_t&gt;(poolSizes.size());poolInfo.pPoolSizes = poolSizes.data();poolInfo.maxSets = static_cast&lt;uint32_t&gt;(swapChainImages.size()); 最后一步是将实际图像和采样器资源绑定到描述符集中的描述符，转到createDescriptorSets函数。 12345678910111213for (size_t i = 0; i &lt; swapChainImages.size(); i++) &#123; VkDescriptorBufferInfo bufferInfo = &#123;&#125;; bufferInfo.buffer = uniformBuffers[i]; bufferInfo.offset = 0; bufferInfo.range = sizeof(UniformBufferObject); VkDescriptorImageInfo imageInfo = &#123;&#125;; imageInfo.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL; imageInfo.imageView = textureImageView; imageInfo.sampler = textureSampler; ...&#125; VkDescriptorImageInfo结构指定了组合图像采样器结构的资源，就像在VkDescriptorBufferInfo结构中指定统一缓冲区描述符的缓冲区资源一样。这是前一章中的对象汇集在一起​​的地方。 12345678910111213141516171819std::array&lt;VkWriteDescriptorSet, 2&gt; descriptorWrites = &#123;&#125;;descriptorWrites[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;descriptorWrites[0].dstSet = descriptorSets[i];descriptorWrites[0].dstBinding = 0;descriptorWrites[0].dstArrayElement = 0;descriptorWrites[0].descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;descriptorWrites[0].descriptorCount = 1;descriptorWrites[0].pBufferInfo = &amp;bufferInfo;descriptorWrites[1].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;descriptorWrites[1].dstSet = descriptorSets[i];descriptorWrites[1].dstBinding = 1;descriptorWrites[1].dstArrayElement = 0;descriptorWrites[1].descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;descriptorWrites[1].descriptorCount = 1;descriptorWrites[1].pImageInfo = &amp;imageInfo;vkUpdateDescriptorSets(device, static_cast&lt;uint32_t&gt;(descriptorWrites.size()), descriptorWrites.data(), 0, nullptr); 描述符必须与此图像信息一起更新，就像缓冲区一样，这次我们使用的是pImageInfo数组而不是pBufferInfo。描述符现在可以被着色器使用了。 纹理坐标纹理映射有一个重要的因素仍然缺失，那就是每个顶点的实际坐标。坐标确定了图像实际映射到几何体的方式。 1234567891011121314151617181920212223242526272829303132333435struct Vertex &#123; glm::vec2 pos; glm::vec3 color; glm::vec2 texCoord; static VkVertexInputBindingDescription getBindingDescription() &#123; VkVertexInputBindingDescription bindingDescription = &#123;&#125;; bindingDescription.binding = 0; bindingDescription.stride = sizeof(Vertex); bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX; return bindingDescription; &#125; static std::array&lt;VkVertexInputAttributeDescription, 3&gt; getAttributeDescriptions() &#123; std::array&lt;VkVertexInputAttributeDescription, 3&gt; attributeDescriptions = &#123;&#125;; attributeDescriptions[0].binding = 0; attributeDescriptions[0].location = 0; attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT; attributeDescriptions[0].offset = offsetof(Vertex, pos); attributeDescriptions[1].binding = 0; attributeDescriptions[1].location = 1; attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT; attributeDescriptions[1].offset = offsetof(Vertex, color); attributeDescriptions[2].binding = 0; attributeDescriptions[2].location = 2; attributeDescriptions[2].format = VK_FORMAT_R32G32_SFLOAT; attributeDescriptions[2].offset = offsetof(Vertex, texCoord); return attributeDescriptions; &#125;&#125;; 修改Vertex结构以包含纹理坐标的vec2，确保还添加了VkVertexInputAttributeDescription，以便我们可以在顶点着色器中使用访问纹理坐标作为输入。这是必要的，是为了能够将它们传递给片段着色器，以便在正方形的表面上进行插值。 123456const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;-0.5f, -0.5f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;, &#123;1.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, -0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;, &#123;0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;, &#123;0.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;, &#123;1.0f, 1.0f&#125;&#125;&#125;; 在本教程中，我将简单地使用从左上角的0,0到右下角的1,1的坐标来填充纹理。在这里可以尝试各种坐标。尝试使用低于0或者高于1的坐标来观察寻址模式的不同表现。 着色器最后一步是修改着色器以从纹理中采样颜色。我们首先需要修改顶点着色器以将纹理坐标传递给片段着色器： 123456789101112layout(location = 0) in vec2 inPosition;layout(location = 1) in vec3 inColor;layout(location = 2) in vec2 inTexCoord;layout(location = 0) out vec3 fragColor;layout(location = 1) out vec2 fragTexCoord;void main() &#123; gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0); fragColor = inColor; fragTexCoord = inTexCoord;&#125; 就像每个顶点的颜色，fragTexCoord值通过光栅化平滑的插值到矩形区域内。我们可以通过让片段着色器将纹理坐标输出为颜色来可视化： 1234567891011#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragColor;layout(location = 1) in vec2 fragTexCoord;layout(location = 0) out vec4 outColor;void main() &#123; outColor = vec4(fragTexCoord, 0.0, 1.0);&#125; 您应该可以看到如下图所示的内容。别忘了重新编译着色器！ 绿色通道表示水平坐标，红色通道表示垂直坐标。黑色和黄色角确认纹理坐标是从0,0到1,1正确的在正方形上进行插值。在着色器编程中使用颜色可视化数据相当于printf调试，因为也没有更好的选择了。 组合图像采样器描述符在GLSL中由均匀采样器表示。在片段着色器中添加对它的引用： 1layout(binding = 1) uniform sampler2D texSampler; 对于其他类型的图像，可以使用相似的sampler1D和sampler3D类型，确保在此处使用正确的绑定。 123void main() &#123; outColor = texture(texSampler, fragTexCoord);&#125; 使用内置的纹理函数对纹理进行采样，它需要一个采样器和坐标作为参数。采样器会自动处理后台中的过滤和转换。现在，您应该可以在运行应用程序时看到正方形上的纹理了： 尝试通过将纹理坐标缩放到大于1的值来尝试寻址模式。例如，使用VK_SAMPLER_ADDRESS_MODE_REPEAT时，可以使用下面的片段着色器生成下图中的结果： 123void main() &#123; outColor = texture(texSampler, fragTexCoord * 2.0);&#125; 您还可以使用顶点颜色来处理纹理颜色： 123void main() &#123; outColor = vec4(fragColor * texture(texSampler, fragTexCoord).rgb, 1.0);&#125; 我在这里将RGB和alpha通道分开以不缩放alpha通道。 您现在知道如何在着色器中访问图像了。当与帧缓冲区中的图像进行结合时，这是一个非常有效的技术。您可以使用这些图像作为输入来实现非常酷炫的效果，如3D世界中的后期处理和相机显示。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(25)-纹理映射-图像视图和采样器","slug":"学习一个vulkan-25-纹理映射-图像视图和采样器","date":"2018-11-26T01:07:43.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/26/学习一个vulkan-25-纹理映射-图像视图和采样器/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/26/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-25-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE%E5%92%8C%E9%87%87%E6%A0%B7%E5%99%A8/","excerpt":"继续上一次的","text":"继续上一次的 在本章节我们将为图形管线创建另外两个资源来对图像进行采样，第一个资源是我们在使用交换链图像时已经见过的，第二个资源是新的-它涉及着色器如何从图像中读取纹素。 纹理图像视图我们之前已经看到，使用交换链图像和帧缓冲，图像是通过图像视图而不是直接访问的。我们也需要为纹理图像创建这样的图像视图。 添加一个类成员来保存纹理图像的VkImageView，并创建一个新函数createTextureImageView，我们将在函数内进行创建： 1234567891011121314151617VkImageView textureImageView;...void initVulkan() &#123; ... createTextureImage(); createTextureImageView(); createVertexBuffer(); ...&#125;...void createTextureImageView() &#123;&#125; 此函数的代码可以直接使用createImageViews进行更改。唯一需要进行的两项更改是format和image： 12345678910VkImageViewCreateInfo viewInfo = &#123;&#125;;viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;viewInfo.image = textureImage;viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;viewInfo.format = VK_FORMAT_R8G8B8A8_UNORM;viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;viewInfo.subresourceRange.baseMipLevel = 0;viewInfo.subresourceRange.levelCount = 1;viewInfo.subresourceRange.baseArrayLayer = 0;viewInfo.subresourceRange.layerCount = 1; 这里没有了显式的viewInfo.components初始化，因为VK_COMPONENT_SWIZZLE_IDENTITY被定义为0。嘴好通过调用vkCreateImageView完成创建图像视图： 123if (vkCreateImageView(device, &amp;viewInfo, nullptr, &amp;textureImageView) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create texture image view!&quot;);&#125; 因为很多逻辑都是从createImageViews复制过来的，所以可以新建一个createImageView函数来封装该部分逻辑： 12345678910111213141516171819VkImageView createImageView(VkImage image, VkFormat format) &#123; VkImageViewCreateInfo viewInfo = &#123;&#125;; viewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; viewInfo.image = image; viewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; viewInfo.format = format; viewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; viewInfo.subresourceRange.baseMipLevel = 0; viewInfo.subresourceRange.levelCount = 1; viewInfo.subresourceRange.baseArrayLayer = 0; viewInfo.subresourceRange.layerCount = 1; VkImageView imageView; if (vkCreateImageView(device, &amp;viewInfo, nullptr, &amp;imageView) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create texture image view!&quot;); &#125; return imageView;&#125; createTextureImageView函数现在可以简化为： 123void createTextureImageView() &#123; textureImageView = createImageView(textureImage, VK_FORMAT_R8G8B8A8_UNORM);&#125; 而createImageViews可以简化为： 1234567void createImageViews() &#123; swapChainImageViews.resize(swapChainImages.size()); for (uint32_t i = 0; i &lt; swapChainImages.size(); i++) &#123; swapChainImageViews[i] = createImageView(swapChainImages[i], swapChainImageFormat); &#125;&#125; 确保在销毁图像本身前清理图像视图： 1234567void cleanup() &#123; cleanupSwapChain(); vkDestroyImageView(device, textureImageView, nullptr); vkDestroyImage(device, textureImage, nullptr); vkFreeMemory(device, textureImageMemory, nullptr); 采样着色器可以直接从图像中读取纹素，但是当它们用作纹理时，并不经常使用这种方式。纹理通常通过采样器访问，采样器将应用过滤和变换来计算得到的最终颜色。 这些过滤器有助于解决过采样等问题。就是一个映射到几何图形的纹理图像，拥有比纹素更多的片元的情况。如果您只是为每个片段中的纹理坐标选取最接近的纹素，那么您将获得与第一个图像类似的结果： 如果您通过线性插值组合了4个最接近的纹素，那么您将获得更平滑的结果，如右侧的结果。当然你的应用程序也可能有需要更符合左边风格的艺术风格要求（Minecraft），但在传统的图形应用中，右边是首选。当从纹理中读取颜色时，采样器对象会自动为您应用此过滤器。 欠采样会有相反的问题，就是在有更多的纹素而不是片元的情况下。比如对于棋盘的纹理进行采样，会导致在有锐角的地方产生失真。 如左图所示，纹理在远处变的模糊。解决方案是使用各向异性过滤，这个也可以由采样器自动应用。 除了这些滤波器，采样器还可以处理各种转换。它决定了当您尝试通过其寻址模式读取图像外部的纹素时会发生什么。下图显示了一些可能的转换： 我们现在将创建一个createTextureSampler函数来设置采样器对象。稍后我们将使用该采样器在着色器中读取纹理中的颜色。 12345678910111213void initVulkan() &#123; ... createTextureImage(); createTextureImageView(); createTextureSampler(); ...&#125;...void createTextureSampler() &#123;&#125; 采样器通过VkSamplerCreateInfo结构进行配置，该结构指定需要应用的所有过滤器和转换。 1234VkSamplerCreateInfo samplerInfo = &#123;&#125;;samplerInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;samplerInfo.magFilter = VK_FILTER_LINEAR;samplerInfo.minFilter = VK_FILTER_LINEAR; magFilter和minFilter字段指定如何插入放大或缩小纹素。放大会涉及上述的过采样问题，而缩小则涉及欠采样。选项为VK_FILTER_NEAREST或VK_FILTER_LINEAR，分别对应于上面图片中中显示的模式。 123samplerInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT;samplerInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT;samplerInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT; 可以使用addressMode字段为每个轴指定寻址模式。可用值列在下方，其中大部分都在上图中进行了演示。需要注意的是轴向在这里称为UVW而不是XYZ。这是纹理空间坐标系中的规定。 VK_SAMPLER_ADDRESS_MODE_REPEAT：超出图像尺寸时循环填充。 VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT：像循环填充类似，但是当超出尺寸时，反转坐标使用镜像来填充。 VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE：当超过图像尺寸的时候，采用边缘最近的颜色进行填充。 VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE：与边缘模式类似，但是使用与最近边缘相反的边缘进行填充。 VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER：当采样超过图像的尺寸时，返回一个纯色填充。 我们在这里使用哪种模式并不重要，因为在本教程中我们不会在图像之外进行采样。但是，循环模式可能是最常见的模式，因为它可以用于平铺地板和墙壁等纹理。 12samplerInfo.anisotropyEnable = VK_TRUE;samplerInfo.maxAnisotropy = 16; 这两个字段指定是否应使用各向异性过滤。除非有性能问题，否则没有理由不使用它。maxAnisotropy字段限制了可用于计算最终颜色的纹素样本量，值越低，性能越好，但效果越差。目前没有图形硬件可以使用超过16个采样器，因为超过16之后的差异可以忽略不计。samplerInfo.borderColor &#x3D; VK_BORDER_COLOR_INT_OPAQUE_BLACK;borderColor字段指定采样范围超过图像时候返回的颜色，与之对应的是边缘寻址模式。可以以float或int格式返回黑色，白色或透明，这里不能指定随便什么颜色。 1samplerInfo.unnormalizedCoordinates = VK_FALSE; unnormalizedCoordinates字段指定要用于处理图像中纹素的坐标系。如果此字段为VK_TRUE，则可以简单地使用范围是[0,texWidth)和[0,texHeight)的坐标系。如果是VK_FALSE，意味着每个轴向纹素都是[0,1)的范围。真实的应用都是使用归一化的坐标系，因为这样可以在同一坐标系中使用不同分辨率的纹理。 12samplerInfo.compareEnable = VK_FALSE;samplerInfo.compareOp = VK_COMPARE_OP_ALWAYS; 如果启用了比较功能，则首先将纹素与值进行比较，并将该比较的结果用于过滤操作。这通常用于阴影贴图上的百分比近似滤波（percentage-closer filtering）。我们将在以后的章节中讨论这个问题。 1234samplerInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_LINEAR;samplerInfo.mipLodBias = 0.0f;samplerInfo.minLod = 0.0f;samplerInfo.maxLod = 0.0f; 所有这些字段应用在mipmapping中，mipmapping也会在未来章节中进行讨论。但基本上它就是另一种可以应用的过滤器。 现在完全定义好了采样器的功能。添加一个类成员来保存采样器对象的句柄，并使用vkCreateSampler创建采样器： 123456789101112VkImageView textureImageView;VkSampler textureSampler;...void createTextureSampler() &#123; ... if (vkCreateSampler(device, &amp;samplerInfo, nullptr, &amp;textureSampler) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create texture sampler!&quot;); &#125;&#125; 请注意，采样器不会在任何地方引用VkImage。采样器是一个独特的对象，它提供了一个从纹理中提取颜色的接口，它可以应用于您想要的任何图像，无论是1D，2D还是3D。这与许多旧的API不同，后者会将纹理图像和过滤器组合成单个的状态。 在程序的最后且不再访问图像的时候，销毁采样器： 12345678void cleanup() &#123; cleanupSwapChain(); vkDestroySampler(device, textureSampler, nullptr); vkDestroyImageView(device, textureImageView, nullptr); ...&#125; 各向异性设备功能如果您现在运行程序，您将看到如下的验证层消息： 这是因为各向异性过滤实际上是一个可选的设备功能，我们需要更新createLogicalDevice函数进行请求： 12VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;;deviceFeatures.samplerAnisotropy = VK_TRUE; 即使现代显卡不太可能不支持它，我们还是应该更新isDeviceSuitable来检查它是否可用： 12345678bool isDeviceSuitable(VkPhysicalDevice device) &#123; ... VkPhysicalDeviceFeatures supportedFeatures; vkGetPhysicalDeviceFeatures(device, &amp;supportedFeatures); return indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate &amp;&amp; supportedFeatures.samplerAnisotropy;&#125; vkGetPhysicalDeviceFeatures将VkPhysicalDeviceFeatures结构重新定义，指定了哪些特性被支持而不是通过设置boolean值来请求。 除了强制执行各向异性过滤之外，还可以通过条件设置来不使用它： 12samplerInfo.anisotropyEnable = VK_FALSE;samplerInfo.maxAnisotropy = 1; 在下一章中，我们将图像和采样器对象公开给着色器，以将纹理绘制到正方形上。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(24)-纹理映射-图像","slug":"学习一个vulkan-24-纹理映射-图像","date":"2018-11-24T01:35:16.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/24/学习一个vulkan-24-纹理映射-图像/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/24/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-24-%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84-%E5%9B%BE%E5%83%8F/","excerpt":"继续上一次的","text":"继续上一次的 介绍到目前为止，几何体已经逐顶点的方法进行着色，这是一种相当局限的方法。在本教程的这个部分中，我们将实现纹理映射以使几何看起来更生动有趣，这也将允许我们在将来的章节中加载和绘制基本的3D模型。 在应用程序中添加纹理将涉及以下步骤： 创建设备内存支持的图像对象 用图像文件中的像素填充它 创建图像采样器 添加组合图像采样器描述符以从纹理中采样颜色 我们之前已经使用过图像对象，但这些是由交换链扩展自动创建的，这次我们必须自己创造一个。创建图像并用数据填充它与顶点缓冲区创建类似，我们首先创建一个临时资源并用像素数据填充它，然后我们将其复制到我们将用于渲染的最终图像对象中。虽然可以为此目的创建一个临时图像，但Vulkan还允许您直接将像素从VkBuffer复制到图像，并且在某些硬件上这样还更快。我们首先创建这个缓冲区并用像素值填充它，然后我们将创建一个图像来复制像素。它需要查询内存，分配设备内存并绑定它，就像之前那样。 但是，在处理图像时我们还需要注意一些额外的事情，图像可以具有不同的布局，这些布局会影响像素在内存中的组织方式。由于图形硬件的工作方式，例如简单地逐行存储像素可能不会产生最佳性能。对图像执行任何操作时，都必须确保它们具有最适合在该操作中使用的布局。实际上，当我们指定渲染过程时，我们已经看到了一些布局： VK_IMAGE_LAYOUT_PRESENT_SRC_KHR：最适合演示 VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL：最适合作为从片段着色器中写入颜色的附件 VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL：最适合作为传输操作中的源，如vkCmdCopyImageToBuffer VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL：最适合作为传输操作中的目标，如vkCmdCopyBufferToImage VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL：最适合着色器采样 转换图像布局的最常用方法之一是管线屏障（pipeline barrier）。管线屏障主要用于同步对资源的访问，例如确保在读取图像之前写入图像，但它们也可用于转换布局。在本章中，我们将看到管线屏障如何用于此目的。使用VK_SHARING_MODE_EXCLUSIVE时，还可以使用屏障来传输队列簇的所有权。 图像库有许多库可用于加载图像，您甚至可以编写自己的代码来加载简单格式，如BMP和PPM。在本教程中，我们将使用stb collection中的stb_image库。它的优点是所有代码都在一个文件中，因此它不需要任何棘手的构建配置。下载stb_image.h并将其存储在一个方便的位置，例如保存GLFW和GLM的目录中。将位置添加到包含路径。Visual Studio将包含stb_image.h的目录添加到Additional Include Directories路径。 Makefile将包含stb_image.h的目录添加到GCC的include目录中： 123456VULKAN_SDK_PATH = /home/user/VulkanSDK/x.x.x.x/x86_64STB_INCLUDE_PATH = /home/user/libraries/stb...CFLAGS = -std=c++17 -I$(VULKAN_SDK_PATH)/include -I$(STB_INCLUDE_PATH) 加载图片像这样包含图像库： 12#define STB_IMAGE_IMPLEMENTATION#include &lt;stb_image.h&gt; 头文件默认只定义了函数的原型。一个代码文件需要使用STB_IMAGE_IMPLEMENTATION来包含定义在头文件中的函数体，否则我们将收到链接错误。 12345678910111213void initVulkan() &#123; ... createCommandPool(); createTextureImage(); createVertexBuffer(); ...&#125;...void createTextureImage() &#123;&#125; 创建一个新函数createTextureImage，我们将加载一个图像并将其上传到Vulkan图像对象中。我们将使用命令缓冲区，因此在createCommandPool之后来调用它。 在shaders目录旁边创建一个新目录textures，以存储纹理图像。我们将从该目录加载一个名为texture.jpg的图像。我选择使用以下CC0许可的可图片并将大小调整为512x512，但您可以选择想要的任何图像。 使用这个库加载图像非常简单： 123456789void createTextureImage() &#123; int texWidth, texHeight, texChannels; stbi_uc* pixels = stbi_load(&quot;textures/texture.jpg&quot;, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha); VkDeviceSize imageSize = texWidth * texHeight * 4; if (!pixels) &#123; throw std::runtime_error(&quot;failed to load texture image!&quot;); &#125;&#125; stbi_load函数将文件路径和要加载的通道数作为参数。STBI_rgb_alpha值会强制图像加载alpha通道，即使它没有，这样以便将来与其他纹理保持一致。返回的指针是像素值数组中的第一个元素。在STBI_rgba_alpha的情况下，像素逐行排列，每像素4个字节，总共有texWidthtexHeight4个值。 临时缓冲区我们现在要在主机可见内存中创建一个缓冲区，以便我们可以使用vkMapMemory并将像素复制给它。在createTextureImage函数中添加此临时缓冲区的变量： 12VkBuffer stagingBuffer;VkDeviceMemory stagingBufferMemory; 缓冲区应该在主机可见内存中，以便我们可以映射它，而且它还应该可以用作传输源，以便我们稍后可以将其复制到图像中： 1createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory); 然后我们可以直接将我们从图像加载库获得的像素值复制到缓冲区： 1234void* data;vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &amp;data); memcpy(data, pixels, static_cast&lt;size_t&gt;(imageSize));vkUnmapMemory(device, stagingBufferMemory); 不要忘记清理原始像素数组： 1stbi_image_free(pixels); 纹理图像虽然我们可以设置着色器来访问缓冲区中的像素值，但在Vulkan中最好使用图像对象来实现此目的。通过使用2D坐标，图像对象可以更容易和更快地来检索颜色。图像对象中的像素称为纹素（texels），即纹理元素，我们将从现在开始使用该名称。添加以下新类成员： 12VkImage textureImage;VkDeviceMemory textureImageMemory; 图像的参数在VkImageCreateInfo结构中指定： 12345678VkImageCreateInfo imageInfo = &#123;&#125;;imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;imageInfo.imageType = VK_IMAGE_TYPE_2D;imageInfo.extent.width = static_cast&lt;uint32_t&gt;(texWidth);imageInfo.extent.height = static_cast&lt;uint32_t&gt;(texHeight);imageInfo.extent.depth = 1;imageInfo.mipLevels = 1;imageInfo.arrayLayers = 1; 在imageType字段中指定的图像类型来告诉Vulkan将使用哪种坐标系来处理图像中的纹素，可以是1D，2D和3D图像。例如，一维图像可用于存储数据或梯度阵列，二维图像主要用于纹理，三维图像可用于存储立体纹素。extent字段指定图像的尺寸，基本上就是每个轴上有多少个纹​​素。这就是为什么深度必须是1而不是0.我们的纹理不会是一个数组，而现在我们不会使用mipmapping功能。 1imageInfo.format = VK_FORMAT_R8G8B8A8_UNORM; Vulkan支持许多可能的图像格式，但我们应该使用与缓冲区中像素相同的纹理元素格式，否则复制操作将失败。 1imageInfo.tiling = VK_IMAGE_TILING_OPTIMAL; tiling字段可以是以下两个值之一： VK_IMAGE_TILING_LINEAR：像我们的像素数组一样，纹素按行序排列 VK_IMAGE_TILING_OPTIMAL：纹素基于具体的实现来定义布局，以实现最佳的访问效率 与图像的布局不同，平铺模式不能在之后更改。如果您希望能够直接访问图像内存中的纹素，则必须使用VK_IMAGE_TILING_LINEAR，我们将使用一个临时缓冲区而不是一个临时图像，并没有这个需求。我们将使用VK_IMAGE_TILING_OPTIMAL从着色器进行高效访问。 1imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; 图像的initialLayout只有两个可能的值： VK_IMAGE_LAYOUT_UNDEFINED：GPU无法使用，第一次转换将丢弃纹素。 VK_IMAGE_LAYOUT_PREINITIALIZED：GPU无法使用，但第一次转换将保留纹素。 在第一次转换期间，很少有情况需要保留纹素。但是，如果您想将图像使用VK_IMAGE_TILING_LINEAR的布局作为临时图像，在这种情况下，您需要将纹素数据上传，然后将图像转换为传输源而不能丢失数据。然而，在我们的例子中，我们首先将图像转换为传输目标，然后从缓冲区对象复制纹素数据，因此我们不需要这个特性，所以可以放心地使用VK_IMAGE_LAYOUT_UNDEFINED。 1imageInfo.usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT; usage字段与缓冲区创建期间的语义相同。该图像将用作缓冲区复制的目标，因此应将其设置为传输目标。我们还希望能够从着色器访问图像用来为我们的网格着色，因此还要应包括VK_IMAGE_USAGE_SAMPLED_BIT。 1imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; 该图像仅由一个队列簇使用：支持图形（因此也支持）传输操作的队列。 12imageInfo.samples = VK_SAMPLE_COUNT_1_BIT;imageInfo.flags = 0; // Optional samples标志位与多重采样相关。这仅仅适用于作为附件的图像，所以我们坚持一个采样数值。对于与稀疏图像相关的图像，存在一些可选标记。稀疏图像是只有某些区域实际存储到内存的图像。例如，如果您使用3D纹理用于立体地形的生成，那么您可以使用它来避免分配的内存存储大量的“空”值。我们将不会在本教程中使用它，因此将其保留为默认值0。 123if (vkCreateImage(device, &amp;imageInfo, nullptr, &amp;textureImage) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create image!&quot;);&#125; 图像是使用vkCreateImage创建的，它没有任何特别值得注意的参数。图形硬件可能不支持VK_FORMAT_R8G8B8A8_UNORM格式，所以您应该有一个可接受的替代方案列表，并选择最好的替代方案，但是，对这种特定格式的支持非常普遍，我们将跳过此步骤。使用不同的格式也需要烦人的转换。我们将在深度缓冲区讨论他，并实现一个类似的系统。 12345678910111213VkMemoryRequirements memRequirements;vkGetImageMemoryRequirements(device, textureImage, &amp;memRequirements);VkMemoryAllocateInfo allocInfo = &#123;&#125;;allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;allocInfo.allocationSize = memRequirements.size;allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT);if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;textureImageMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate image memory!&quot;);&#125;vkBindImageMemory(device, textureImage, textureImageMemory, 0); 为图像分配内存的工作方式与为缓冲区分配内存的方式完全相同。这里需要使用vkGetImageMemoryRequirements而不是vkGetBufferMemoryRequirements，使用vkBindImageMemory而不是vkBindBufferMemory。 这个函数已经变得非常巨大了，并且在后面的章节中还会创建更多的图像，因此我们应该将图像创建的过程抽象为createImage函数，就像我们为缓冲区所做的那样。创建函数并将图像对象创建和内存分配过程移动到这里面： 12345678910111213141516171819202122232425262728293031323334void createImage(uint32_t width, uint32_t height, VkFormat format, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags properties, VkImage&amp; image, VkDeviceMemory&amp; imageMemory) &#123; VkImageCreateInfo imageInfo = &#123;&#125;; imageInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; imageInfo.imageType = VK_IMAGE_TYPE_2D; imageInfo.extent.width = width; imageInfo.extent.height = height; imageInfo.extent.depth = 1; imageInfo.mipLevels = 1; imageInfo.arrayLayers = 1; imageInfo.format = format; imageInfo.tiling = tiling; imageInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED; imageInfo.usage = usage; imageInfo.samples = VK_SAMPLE_COUNT_1_BIT; imageInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; if (vkCreateImage(device, &amp;imageInfo, nullptr, &amp;image) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create image!&quot;); &#125; VkMemoryRequirements memRequirements; vkGetImageMemoryRequirements(device, image, &amp;memRequirements); VkMemoryAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; allocInfo.allocationSize = memRequirements.size; allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties); if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;imageMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate image memory!&quot;); &#125; vkBindImageMemory(device, image, imageMemory, 0);&#125; 这里使用了width,height,format,tiling mode,usage和memory properties参数，因为之后创建的图像都会有所不同。 createTextureImage函数现在可以简化为： 12345678910111213141516171819202122void createTextureImage() &#123; int texWidth, texHeight, texChannels; stbi_uc* pixels = stbi_load(&quot;textures/texture.jpg&quot;, &amp;texWidth, &amp;texHeight, &amp;texChannels, STBI_rgb_alpha); VkDeviceSize imageSize = texWidth * texHeight * 4; if (!pixels) &#123; throw std::runtime_error(&quot;failed to load texture image!&quot;); &#125; VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(imageSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory); void* data; vkMapMemory(device, stagingBufferMemory, 0, imageSize, 0, &amp;data); memcpy(data, pixels, static_cast&lt;size_t&gt;(imageSize)); vkUnmapMemory(device, stagingBufferMemory); stbi_image_free(pixels); createImage(texWidth, texHeight, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, textureImage, textureImageMemory);&#125; 布局转换我们现在要编写的函数包括再次记录和执行命令缓冲区，所以现在是将该逻辑转换为辅助函数的好时机： 1234567891011121314151617181920212223242526272829303132VkCommandBuffer beginSingleTimeCommands() &#123; VkCommandBufferAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandPool = commandPool; allocInfo.commandBufferCount = 1; VkCommandBuffer commandBuffer; vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer); VkCommandBufferBeginInfo beginInfo = &#123;&#125;; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT; vkBeginCommandBuffer(commandBuffer, &amp;beginInfo); return commandBuffer;&#125;void endSingleTimeCommands(VkCommandBuffer commandBuffer) &#123; vkEndCommandBuffer(commandBuffer); VkSubmitInfo submitInfo = &#123;&#125;; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = &amp;commandBuffer; vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE); vkQueueWaitIdle(graphicsQueue); vkFreeCommandBuffers(device, commandPool, 1, &amp;commandBuffer);&#125; 这些函数的代码是基于copyBuffer中的已有代码。您现在可以将该功能简化为： 123456789void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) &#123; VkCommandBuffer commandBuffer = beginSingleTimeCommands(); VkBufferCopy copyRegion = &#123;&#125;; copyRegion.size = size; vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &amp;copyRegion); endSingleTimeCommands(commandBuffer);&#125; 如果我们仍在使用缓冲区，那么我们现在可以编写一个函数来记录和执行vkCmdCopyBufferToImage来完成作业，但是这个命令要求图像首先处于正确的布局中。创建一个新函数来处理布局转换： 12345void transitionImageLayout(VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout) &#123; VkCommandBuffer commandBuffer = beginSingleTimeCommands(); endSingleTimeCommands(commandBuffer);&#125; 执行布局转换的最常用方法之一是使用图像内存屏障（image memory barrier）。像这样的管线屏障通常用于同步对资源的访问，例如确保在读取缓冲区之前完成对缓冲区的写入，但是当使用VK_SHARING_MODE_EXCLUSIVE时，它也可以用于转换图像布局和传输队列簇的所有权。缓冲区有一个等效的缓冲区内存屏障（uffer memory barrier）。 1234VkImageMemoryBarrier barrier = &#123;&#125;;barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;barrier.oldLayout = oldLayout;barrier.newLayout = newLayout; 前两个字段指定布局转换。如果您不关心图像的现有内容，可以将oldLayout的值改为VK_IMAGE_LAYOUT_UNDEFINED。 12barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED;barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; 如果您使用屏障来传输队列簇的所有权，那么这两个字段应该是队列族的索引。如果您不想这样做（这个不是默认值！必须设置），则必须将它们设置为VK_QUEUE_FAMILY_IGNORED。 123456barrier.image = image;barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;barrier.subresourceRange.baseMipLevel = 0;barrier.subresourceRange.levelCount = 1;barrier.subresourceRange.baseArrayLayer = 0;barrier.subresourceRange.layerCount = 1; image和subresourceRange指定了受影响的图像和图像的特定部分。我们的图像不是数组形式，也没有使用mipmapping级别，因此只指定了一个级别和图层。 12barrier.srcAccessMask = 0; // TODObarrier.dstAccessMask = 0; // TODO 屏障主要用于同步，因此您必须指定涉及资源的哪些类型的操作必须在屏障之前发生，以及涉及资源的哪些操作必须在屏障上等待。尽管已经使用vkQueueWaitIdle手动同步，但我们还是需要这样做。正确的值取决于旧的和新的布局，所以一旦我们弄清楚我们将要使用哪些转换，就会回到这里来设置。 12345678vkCmdPipelineBarrier( commandBuffer, 0 /* TODO */, 0 /* TODO */, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier); 使用相同的函数提交所有类型的管道障碍。命令缓冲区之后的第一个参数指定了应在屏障之前发生的操作位于哪个管道阶段。第二个参数指定操作将在屏障上等待的管道阶段。在屏障之前和之后指定的管道阶段取决于您在屏障之前和之后使用资源的方式。允许的值列在此规范表中。例如，如果您要在p屏障后从统一缓冲区中读取，就需要指定为VK_ACCESS_UNIFORM_READ_BIT用法并将从统一缓冲区中读取到的初始着色器作为管线阶段，例如VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT。为此类用法指定非着色器管道阶段是没有意义的，并且当您指定与使用类型不匹配的管道阶段时，验证层将发出警告。 第三个参数是0或VK_DEPENDENCY_BY_REGION_BIT。后者将屏障转变为每个区域的状态。这意味着，可以实现从目前已经编写的资源部分开始读取。 最后三个参数引用了三种可用类型的管道屏障数组：内存屏障，缓冲内存屏障和图像内存屏障，就像我们在这里使用的那样。请注意，我们还没有使用VkFormat参数，这个我们将在深度缓冲区章节中来使用进行特殊转换。 从缓冲区复制到图像在回到createTextureImage之前，我们这里再写一个辅助函数：copyBufferToImage： 12345void copyBufferToImage(VkBuffer buffer, VkImage image, uint32_t width, uint32_t height) &#123; VkCommandBuffer commandBuffer = beginSingleTimeCommands(); endSingleTimeCommands(commandBuffer);&#125; 就像缓冲区复制一样，您需要指定将缓冲区的哪个部分复制到映像的哪个部分。这通过VkBufferImageCopy结构实现： 12345678910111213141516VkBufferImageCopy region = &#123;&#125;;region.bufferOffset = 0;region.bufferRowLength = 0;region.bufferImageHeight = 0;region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;region.imageSubresource.mipLevel = 0;region.imageSubresource.baseArrayLayer = 0;region.imageSubresource.layerCount = 1;region.imageOffset = &#123;0, 0, 0&#125;;region.imageExtent = &#123; width, height, 1&#125;; 大多数这些参数都是一看就知道了。bufferOffset指定了缓冲区中的字节偏移量，代表像素值起始的位置。bufferRowLength和bufferImageHeight字段指定像素在内存中的布局方式。例如，您可以在图像的行与行之间有一些填充字节，为两者指定0表示像素紧密排列，就像我们的情况一样imageSubresource，imageOffset和imageExtent字段指示了我们要复制像素的图像部分。 使用vkCmdCopyBufferToImage函数将缓冲区到图像的复制操作排入队列： 12345678vkCmdCopyBufferToImage( commandBuffer, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &amp;region); 第四个参数指示图像当前使用的布局。现在假设图像已经转换到最适合复制像素的布局。现在我们只将像素块复制到整个图像，但是可以指定一个VkBufferImageCopy数组，在一次操作中从该缓冲区到图像执行许多不同的复制操作。 准备纹理图像现在我们拥有了完成纹理图像设置所需的所有工具，因此我们将回到createTextureImage函数，我们在那里做的最后一件事是创建纹理图像。下一步是将临时缓冲区复制到纹理图像。这涉及两个步骤： 将纹理图像转换为VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL 执行缓冲区到图像的复制操作 这对我们刚刚创建的函数很容易实现： 12transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);copyBufferToImage(stagingBuffer, textureImage, static_cast&lt;uint32_t&gt;(texWidth), static_cast&lt;uint32_t&gt;(texHeight)); 图像是使用VK_IMAGE_LAYOUT_UNDEFINED布局创建的，因此在转换textureImage时应将其指定为旧布局。请记住，我们可以这样做是因为在执行复制操作之前我们不关心其内容。 为了能够从着色器中的纹理图像进行采样，我们需要最后一次转换操作来为着色器访问做好准备： 1transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); 转换屏障掩码如果您现在运行启用了验证图层的应用程序，那么您将看到它抱怨transitionImageLayout中的访问掩码和管道阶段无效。我们仍然需要根据转换中的布局来设置它们。 我们需要处理两个转换： Undefined → transfer destination：传输的写入操作不需要等待任何事情 Transfer destination → shader reading: 着色器的读取应该等待传输写入，特别是着色器在读取片段着色器的时候，因为那是我们要使用纹理的地方。 使用以下访问掩码和管道阶段来指定这些规则： 123456789101112131415161718192021222324252627VkPipelineStageFlags sourceStage;VkPipelineStageFlags destinationStage;if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED &amp;&amp; newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) &#123; barrier.srcAccessMask = 0; barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; sourceStage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT; destinationStage = VK_PIPELINE_STAGE_TRANSFER_BIT;&#125; else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL &amp;&amp; newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) &#123; barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT; sourceStage = VK_PIPELINE_STAGE_TRANSFER_BIT; destinationStage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;&#125; else &#123; throw std::invalid_argument(&quot;unsupported layout transition!&quot;);&#125;vkCmdPipelineBarrier( commandBuffer, sourceStage, destinationStage, 0, 0, nullptr, 0, nullptr, 1, &amp;barrier); 正如您在上述表中所看到的，传输写入必须在管道传输阶段进行。由于写入不必等待任何事情，因此您可以为预屏障操作指定空的访问掩码和最早可能的流水线阶段VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT。应该注意的是，VK_PIPELINE_STAGE_TRANSFER_BIT不是图形和计算流水线中的真实阶段。它更像是一个转换发生时的一个伪阶段。有关伪阶段的更多信息和其他示例，请参阅文档。 图像将写入相同的管道阶段，然后由片段着色器读取，这就是为什么我们要在片段着色器管道阶段指定着色器读取访问。 如果我们将来需要进行更多转换，那么我们将扩展该功能。应用程序现在应该成功运行，尽管还没有可视化的变化。 需要注意的一点是，命令缓冲区提交会在开始时导致隐式VK_ACCESS_HOST_WRITE_BIT同步。由于transitionImageLayout函数仅使用单个命令执行命令缓冲区，如果在布局转换中需要VK_ACCESS_HOST_WRITE_BIT依赖项，则可以使用此隐式同步并将srcAccessMask设置为0。你想明确操作或隐式操作是完全取决于你的想法，但我个人并不喜欢依赖于这些类似OpenGL的“隐藏”操作。 实际上有一种特殊类型的图像布局支持所有操作，VK_IMAGE_LAYOUT_GENERAL。当然，它的问题在于它不一定能为所有操作都提供最佳性能。在某些特殊情况需要它，例如将图像用作输入和输出，或者在图像离开预初始化布局后读取图像。 到目前为止，所有提交命令的辅助函数都已设置为通过等待队列变为空闲来同步执行。对于实际的应用，建议将这些操作组合在一个命令缓冲区中，并异步执行它们以获得更高的吞吐量，尤其是createTextureImage函数中的转换和复制操作。尝试通过创建一个setupCommandBuffer辅助函数记录命令，并添加一个flushSetupCommands函数来执行所以已经目录的命令。纹理贴图映射工作后这样做，来检查纹理资源是否仍然正确设置。 清理通过在末尾清理临时缓冲区及其内存来完成createTextureImage函数： 12345 transitionImageLayout(textureImage, VK_FORMAT_R8G8B8A8_UNORM, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL); vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr);&#125; 程序中使用的贴图图像直到退出的时候才清理： 12345678void cleanup() &#123; cleanupSwapChain(); vkDestroyImage(device, textureImage, nullptr); vkFreeMemory(device, textureImageMemory, nullptr); ...&#125; 图像现在包含了纹理，但我们仍然需要一种从图形管道访问它的方法。我们将在下一章中讨论这个问题。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(23)-统一缓冲区-描述符池和描述符集","slug":"学习一个vulkan-23-统一缓冲区-描述符池和描述符集","date":"2018-11-23T01:16:57.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/23/学习一个vulkan-23-统一缓冲区-描述符池和描述符集/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/23/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-23-%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2%E5%8C%BA-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%B1%A0%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86/","excerpt":"继续上一次的","text":"继续上一次的 介绍前一章中的描述符布局描述了被绑定的描述符的类型。在本章中，我们将为每个VkBuffer资源创建一个描述符集，以将其绑定到统一缓冲区描述符上。 描述符池描述符集不能直接创建，它们必须从命令缓冲区等池中分配。对于描述符集合使用需要调用描述符对象池（descriptor pool）。我们将编写一个新函数createDescriptorPool来创建： 123456789101112void initVulkan() &#123; ... createUniformBuffer(); createDescriptorPool(); ...&#125;...void createDescriptorPool() &#123;&#125; 我们首先需要使用VkDescriptorPoolSize结构来描述我们的描述符集将包含哪些描述符类型以及数目。 123VkDescriptorPoolSize poolSize = &#123;&#125;;poolSize.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;poolSize.descriptorCount = static_cast&lt;uint32_t&gt;(swapChainImages.size()); 我们将为每个帧分配其中一个描述符。这个池的大小由VkDescriptorPoolCreateInfo结构引用： 1234VkDescriptorPoolCreateInfo poolInfo = &#123;&#125;;poolInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;poolInfo.poolSizeCount = 1;poolInfo.pPoolSizes = &amp;poolSize; 除了可用的单个描述符的最大数量之外，我们还需要指定可以分配的最大描述符集数量： 1poolInfo.maxSets = static_cast&lt;uint32_t&gt;(swapChainImages.size()); 该结构具有一个类似于命令池的可选标志，用于确定是否可以释放各个单个的描述符集：VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT。创建后我们不会再使用他，所以我们不需要这个标志。这里设置成默认的0就行。 1234567VkDescriptorPool descriptorPool;...if (vkCreateDescriptorPool(device, &amp;poolInfo, nullptr, &amp;descriptorPool) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create descriptor pool!&quot;);&#125; 添加一个新的类成员来存储描述符池的句柄，并调用vkCreateDescriptorPool来创建它。与其他绘制资源一样，描述符也是在程序退出的时候销毁： 1234567void cleanup() &#123; cleanupSwapChain(); vkDestroyDescriptorPool(device, descriptorPool, nullptr); ...&#125; 描述符集我们现在可以分配描述符集了。添加一个createDescriptorSets函数： 123456789101112void initVulkan() &#123; ... createDescriptorPool(); createDescriptorSets(); ...&#125;...void createDescriptorSets() &#123;&#125; 使用VkDescriptorSetAllocateInfo结构来描述描述符集的分配。您需要指定要分配的描述符池，要分配的描述符集的数量，以及基于它们的描述符布局： 123456std::vector&lt;VkDescriptorSetLayout&gt; layouts(swapChainImages.size(), descriptorSetLayout);VkDescriptorSetAllocateInfo allocInfo = &#123;&#125;;allocInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;allocInfo.descriptorPool = descriptorPool;allocInfo.descriptorSetCount = static_cast&lt;uint32_t&gt;(swapChainImages.size());allocInfo.pSetLayouts = layouts.data(); 在我们的例子中，我们将为每个交换链图像都创建一个描述符集，所有描述符都具有相同的布局。不幸的是，我们确实需要布局的所有副本，因为下一个函数需要一个与集合数匹配的数组。添加一个类成员来保存描述符集句柄并使用vkAllocateDescriptorSets分配它们： 123456789VkDescriptorPool descriptorPool;std::vector&lt;VkDescriptorSet&gt; descriptorSets;...descriptorSets.resize(swapChainImages.size());if (vkAllocateDescriptorSets(device, &amp;allocInfo, descriptorSets.data()) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate descriptor sets!&quot;);&#125; 您不需要显式清理描述符集，因为它们将在销毁描述符池时自动释放。对vkAllocateDescriptorSets的调用将分配描述符集，每个描述符集都具有一个统一的缓冲区描述符。 现在已经分配了描述符集，但仍然需要配置其中的描述符。我们现在将添加一个循环来填充每个描述符： 123for (size_t i = 0; i &lt; swapChainImages.size(); i++) &#123;&#125; 引用缓冲区的描述符（如我们的统一缓冲区描述符）使用VkDescriptorBufferInfo结构进行配置。此结构指定缓冲区及其中包含描述符数据的区域。 123456for (size_t i = 0; i &lt; swapChainImages.size(); i++) &#123; VkDescriptorBufferInfo bufferInfo = &#123;&#125;; bufferInfo.buffer = uniformBuffers[i]; bufferInfo.offset = 0; bufferInfo.range = sizeof(UniformBufferObject);&#125; 如果你正在覆盖整个缓冲区，就像现在这种情况下一样，那么也可以使用VK_WHOLE_SIZE值作为范围。使用vkUpdateDescriptorSets函数更新描述符的配置，该函数将VkWriteDescriptorSet结构数组作为参数。 12345VkWriteDescriptorSet descriptorWrite = &#123;&#125;;descriptorWrite.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;descriptorWrite.dstSet = descriptorSets[i];descriptorWrite.dstBinding = 0;descriptorWrite.dstArrayElement = 0; 前两个字段指定要更新的描述符集和绑定，我们设定了统一缓冲区绑定的索引为0。请记住，描述符可以是数组，因此我们还需要指定要更新后的数组的索引。由于我们没有使用数组，所以索引设为0就行了。 12descriptorWrite.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;descriptorWrite.descriptorCount = 1; 我们需要再次指定描述符的类型。从索引dstArrayElement开始，可以在数组中一次更新多个描述符，descriptorCount字段指定要更新的数组元素数目。 123descriptorWrite.pBufferInfo = &amp;bufferInfo;descriptorWrite.pImageInfo = nullptr; // OptionaldescriptorWrite.pTexelBufferView = nullptr; // Optional 最后一个字段引用一个数组，其中包含了实际配置描述符的descriptorCount结构。它取决于描述符的类型，您实际需要使用三个中的一个。pBufferInfo字段用于引用缓冲区数据的描述符，pImageInfo用于引用图像数据的描述符，pTexelBufferView用于引用缓冲区视图的描述符。 1vkUpdateDescriptorSets(device, 1, &amp;descriptorWrite, 0, nullptr); 使用vkUpdateDescriptorSets应用更新。它接受两种数组作为参数：VkWriteDescriptorSet数组和VkCopyDescriptorSet数组。正如其名称所暗示的，后者可用于将描述符彼此复制。 使用描述符集我们现在需要更新createCommandBuffers函数，使用cmdBindDescriptorSets将描述符集合绑定到实际的着色器的描述符中，这个函数需vkCmdDrawIndexed之前完成调用： 12vkCmdBindDescriptorSets(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, pipelineLayout, 0, 1, &amp;descriptorSets[i], 0, nullptr);vkCmdDrawIndexed(commandBuffers[i], static_cast&lt;uint32_t&gt;(indices.size()), 1, 0, 0, 0); 与顶点和索引缓冲区不同，描述符集不是图形管道所特有的，因此，我们需要指定是否要将描述符集绑定到图形或计算管道。下一个参数是描述符所基于的布局。接下来的三个参数分别指定了第一个描述符集的索引，要绑定的集合数以及要绑定的集数组。最后两个参数指定用于动态描述符的偏移数组。我们在后续的章节中讨论这些。 如果你现在运行你的程序，那么你会注意到遗憾的是没有任何东西可见。问题在于，由于我们在投影矩阵中进行了Y-flip，所以现在以顺时针顺序而不是逆时针顺序绘制顶点。这会导致背面剔除，并阻止绘制任何几何体。在createGraphicsPipeline函数中修改VkPipelineRasterizationStateCreateInfo中的frontFace以更正此问题： 12rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;rasterizer.frontFace = VK_FRONT_FACE_COUNTER_CLOCKWISE; 再次运行您的程序，您现在应该看到以下内容： 矩形已变为正方形，因为投影矩阵现在可以校正纵横比。updateUniformBuffer负责屏幕大小调整，因此我们不需要在recreateSwapChain中重新创建描述符集。 多描述符集正如一些结构和函数调用暗示的那样，实际上可以同时绑定多个描述符集。在创建管道布局时，需要为每个描述符集指定描述符布局，然后着色器可以引用特定的描述符集，如下所示： 1layout(set = 0, binding = 0) uniform UniformBufferObject &#123; ... &#125; 我们可以使用此功能将每个对象和发生变化的描述符分配到单独的描述符集合中，在这种情况下，可以避免重新绑定大部分描述符，这样可能会更加高效。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(22)-统一缓冲区-描述符布局和缓冲区","slug":"学习一个vulkan-22-统一缓冲区-描述符布局和缓冲区","date":"2018-11-22T01:18:53.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/22/学习一个vulkan-22-统一缓冲区-描述符布局和缓冲区/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/22/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-22-%E7%BB%9F%E4%B8%80%E7%BC%93%E5%86%B2%E5%8C%BA-%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B8%83%E5%B1%80%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA/","excerpt":"继续上一次的","text":"继续上一次的 介绍我们现在能够将任意属性传递给每个顶点的顶点着色器，但是全局变量呢？我们将从本章开始转向3D图形，这需要一个模型-视图-投影矩阵。我们可以将它包含为顶点数据，但这会浪费内存，并且只要转换发生变化，就需要我们更新顶点缓冲区。这种变换通常会发生在每一帧。 在Vulkan中解决这个问题的正确方法是使用资源描述符（resource descriptors）。描述符是着色器可以自由访问缓冲区和图像等资源的一种方式。我们将设置一个包含转换矩阵的缓冲区，并让顶点着色器通过描述符访问它们。描述符的使用包括三个部分： 在管道创建期间指定描述符布局 从描述符池分配描述符集 在渲染期间绑定描述符集 描述符布局（descriptor layout）指定了管道将访问的资源类型，就像渲染过程指定了要访问的附件类型一样。描述符集（descriptor set）指定将绑定到描述符的实际缓冲区或图像资源，就像帧缓冲区指定要绑定到渲染通道附件的实际图像视图一样。然后，描述符集绑定到绘图命令，就像顶点缓冲区和帧缓冲区一样。 描述符有很多种类，但在本章中我们将使用统一缓冲区对象（UBO）。我们将在后面的章节中介绍其他类型的描述符，但基本过程是相同的。假设我们有一个数据，我们希望顶点着色器拥有一个这样的C语言形式的结构体： 12345struct UniformBufferObject &#123; glm::mat4 model; glm::mat4 view; glm::mat4 proj;&#125;; 然后我们可以将数据复制到VkBuffer并通过顶点着色器中的统一缓冲区对象描述符访问它，如下所示： 12345678910layout(binding = 0) uniform UniformBufferObject &#123; mat4 model; mat4 view; mat4 proj;&#125; ubo;void main() &#123; gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0); fragColor = inColor;&#125; 我们会在每一帧更新模型，视图和投影矩阵，使前一章的矩形以3D旋转。 顶点着色器修改顶点着色器以包含上面指定的统一缓冲区对象。这里假设您熟悉MVP转换，如果不是，请参阅这个资源。 123456789101112131415161718#version 450#extension GL_ARB_separate_shader_objects : enablelayout(binding = 0) uniform UniformBufferObject &#123; mat4 model; mat4 view; mat4 proj;&#125; ubo;layout(location = 0) in vec2 inPosition;layout(location = 1) in vec3 inColor;layout(location = 0) out vec3 fragColor;void main() &#123; gl_Position = ubo.proj * ubo.view * ubo.model * vec4(inPosition, 0.0, 1.0); fragColor = inColor;&#125; 请注意，uniform，in和out声明的顺序无关紧要。binding指令类似于属性的location指令，我们将在描述符布局中引用此绑定。将gl_Position行更改为使用变换矩阵计算裁剪坐标的最终位置。与2D三角形不同，裁剪坐标的最后一个分量可能不是1，这将导致在屏幕上转换为最终标准化设备坐标时会做一个除法。在透视投影中的透视除法（perspective division）也用到了这种方法，而且这对于能使更近的物体看起来比远离的物体更大是必要的。 描述符集布局下一步是在C++端定义UBO，并告知Vulkan在顶点着色器使用该描述符： 12345struct UniformBufferObject &#123; glm::mat4 model; glm::mat4 view; glm::mat4 proj;&#125;; 我们可以使用GLM中的与着色器中结构体完全匹配的数据类型。矩阵中的数据与着色器预期的二进制数据兼容，所以我们可以稍后将一个UniformBufferObject通过memcpy拷贝到VkBuffer中。 我们需要提供有关在着色器中用于管道创建的每个描述符绑定的详细信息，就像我们必须对每个顶点属性及其位置索引所做的那样。我们将设置一个新函数来定义所有这些名为createDescriptorSetLayout的信息，它应该在管道创建之前调用，因为我们之后就会用到它。 123456789101112void initVulkan() &#123; ... createDescriptorSetLayout(); createGraphicsPipeline(); ...&#125;...void createDescriptorSetLayout() &#123;&#125; 每个绑定都需要通过VkDescriptorSetLayoutBinding结构来描述。 123456void createDescriptorSetLayout() &#123; VkDescriptorSetLayoutBinding uboLayoutBinding = &#123;&#125;; uboLayoutBinding.binding = 0; uboLayoutBinding.descriptorType = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER; uboLayoutBinding.descriptorCount = 1;&#125; 前两个参数指定了着色器中使用的绑定和描述符的类型，他是一个统一缓冲区对象。着色器变量可以表示统一缓冲区对象的数组，而descriptorCount则指定数组中的值的数量。这可以用于为骨架动画指定骨架中每个骨骼的变换。我们的MVP转换在一个统一的缓冲区对象中，因此我们使用的descriptorCount为1。 1uboLayoutBinding.stageFlags = VK_SHADER_STAGE_VERTEX_BIT; 我们还需要指定描述符将被引用于哪个着色器阶段。stageFlags字段可以是VkShaderStageFlagBits或VK_SHADER_STAGE_ALL_GRAPHICS的各种组合，在我们的例子中，我们只引用顶点着色器中的描述符。 1uboLayoutBinding.pImmutableSamplers = nullptr; // Optional pImmutableSamplers字段仅与图像采样相关的描述符相关，我们将在后面介绍。现在可以将其保留为默认值。 所有描述符绑定都会组合到一个VkDescriptorSetLayout对象中。在pipelineLayout上面定义一个新的类成员： 12VkDescriptorSetLayout descriptorSetLayout;VkPipelineLayout pipelineLayout; 然后我们可以使用vkCreateDescriptorSetLayout创建它。这个函数接受一个简单的结构体VkDescriptorSetLayoutCreateInfo，该结构体持有一个绑定数组： 12345678VkDescriptorSetLayoutCreateInfo layoutInfo = &#123;&#125;;layoutInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;layoutInfo.bindingCount = 1;layoutInfo.pBindings = &amp;uboLayoutBinding;if (vkCreateDescriptorSetLayout(device, &amp;layoutInfo, nullptr, &amp;descriptorSetLayout) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create descriptor set layout!&quot;);&#125; 我们需要在管道创建期间指定描述符集布局，用以告诉Vulkan着色器将使用哪些描述符。描述符集布局在管道布局对象中指定，修改VkPipelineLayoutCreateInfo来引用布局对象： 1234VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;;pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;pipelineLayoutInfo.setLayoutCount = 1;pipelineLayoutInfo.pSetLayouts = &amp;descriptorSetLayout; 您可能想知道为什么可以在此指定多个描述符集布局，这是因为单个布局已包含所有绑定了。我们将在下一章回到这里，那时我们将研究描述符池和描述符集。 描述符布局应该在程序退出前始终有效： 1234567void cleanup() &#123; cleanupSwapChain(); vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr); ...&#125; 统一缓冲区在下一章中，我们将指定包含着色器的UBO数据的缓冲区，但我们需要首先创建此缓冲区。我们将每帧的新数据都复制到统一缓冲区，因此拥有一个临时缓冲区并没有任何意义，在这种情况下，它只会增加额外的开销，并可能降低性能而不是改进它。 我们应该有多个缓冲区，因为多个帧可能同时都在飞行状态，我们不希望更新缓冲区以准备下一帧的时候，前一帧仍然在读取。但是，由于我们需要从每个交换链图像的命令缓冲区引用统一缓冲区，因此每个交换链图像也有一个统一的缓冲区是很有意义的。 为此，需要为uniformBuffers和uniformBuffersMemory添加新的类成员： 12345VkBuffer indexBuffer;VkDeviceMemory indexBufferMemory;std::vector&lt;VkBuffer&gt; uniformBuffers;std::vector&lt;VkDeviceMemory&gt; uniformBuffersMemory; 同样，创建一个新函数createUniformBuffers，它在createIndexBuffer之后调用并分配缓冲区： 1234567891011121314151617181920void initVulkan() &#123; ... createVertexBuffer(); createIndexBuffer(); createUniformBuffer(); ...&#125;...void createUniformBuffer() &#123; VkDeviceSize bufferSize = sizeof(UniformBufferObject); uniformBuffers.resize(swapChainImages.size()); uniformBuffersMemory.resize(swapChainImages.size()); for (size_t i = 0; i &lt; swapChainImages.size(); i++) &#123; createBuffer(bufferSize, VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, uniformBuffers[i], uniformBuffersMemory[i]); &#125;&#125; 我们将编写一个单独的函数来更新统一缓冲区，每帧都有一个新的变换，因此这里不会有vkMapMemory。统一数据将将用于所有绘制调用，因此包含它的缓冲区会在最后才进行销毁： 123456789101112void cleanup() &#123; cleanupSwapChain(); vkDestroyDescriptorSetLayout(device, descriptorSetLayout, nullptr); for (size_t i = 0; i &lt; swapChainImages.size(); i++) &#123; vkDestroyBuffer(device, uniformBuffers[i], nullptr); vkFreeMemory(device, uniformBuffersMemory[i], nullptr); &#125; ...&#125; 更新统一数据在我们知道要获取哪个交换链图像后，立即创建一个新函数updateUniformBuffer并在drawFrame函数里添加对它的调用： 123456789101112131415161718192021void drawFrame() &#123; ... uint32_t imageIndex; VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits&lt;uint64_t&gt;::max(), imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex); ... updateUniformBuffer(imageIndex); VkSubmitInfo submitInfo = &#123;&#125;; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; ...&#125;...void updateUniformBuffer(uint32_t currentImage) &#123;&#125; 此函数将每帧生成一个新变换，来使几何体旋转。我们需要包含两个新的头文件来实现此功能： 12345#define GLM_FORCE_RADIANS#include &lt;glm/glm.hpp&gt;#include &lt;glm/gtc/matrix_transform.hpp&gt;#include &lt;chrono&gt; glm&#x2F;gtc&#x2F;matrix_transform.hpp拥有可用于生成模型转换的函数，如glm::rotate，查看转换的函数，如glm::lookAt，以及投影变换函数，比如glm::perspective。GLM_FORCE_RADIANS的定义是必要的，这可以确保像glm::rotate这样的函数会使用弧度作为参数，用以避免任何可能的混淆。 chrono标准库拥有执行精确计时的功能。我们将使用它来确保几何体每秒旋转90度，而不管帧速率如何。 123456void updateUniformBuffer(uint32_t currentImage) &#123; static auto startTime = std::chrono::high_resolution_clock::now(); auto currentTime = std::chrono::high_resolution_clock::now(); float time = std::chrono::duration&lt;float, std::chrono::seconds::period&gt;(currentTime - startTime).count();&#125; updateUniformBuffer函数将以一些逻辑开始以浮点精度来计算自渲染开始以来的经过的秒数。 我们现在将在统一缓冲区对象中定义模型，视图和投影变换。模型的旋转将使用时间变量围绕Z轴进行简单旋转： 12UniformBufferObject ubo = &#123;&#125;;ubo.model = glm::rotate(glm::mat4(1.0f), time * glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f)); glm::rotate函数将现有变换矩阵，旋转角度和旋转轴作为参数。glm::mat4(1.0f)构造函数返回一个单位矩阵。使用旋转角度time*glm::radians(90.0f)可以实现每秒90度旋转的目的。 1ubo.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f)); 对于视图变换，我决定以45度角从上面来观察。glm::lookAt函数将眼睛位置，中心位置和向上轴作为参数。 1ubo.proj = glm::perspective(glm::radians(45.0f), swapChainExtent.width / (float) swapChainExtent.height, 0.1f, 10.0f); 我选择使用具有45度垂直视场角（FOV）的透视投影。其他参数分别是宽高比，近裁剪面和远裁剪面。使用当前交换链的范围来计算宽高比非常重要，以便在调整大小后考虑窗口的新宽度和高度。 1ubo.proj[1][1] *= -1; GLM最初是为OpenGL设计的，其中裁剪坐标的Y坐标是反转的。最简单的修正方法是在投影矩阵中翻转Y轴缩放因子的符号。如果你不这样做，那么图像将被颠倒渲染。 现在定义了所有转换，因此我们可以将统一缓冲区对象中的数据复制到当前的统一缓冲区。这与我们对顶点缓冲区的操作完全相同，除了没有暂存缓冲区： 1234void* data;vkMapMemory(device, uniformBuffersMemory[currentImage], 0, sizeof(ubo), 0, &amp;data); memcpy(data, &amp;ubo, sizeof(ubo));vkUnmapMemory(device, uniformBuffersMemory[currentImage]); 使用UBO这种方式不是将频繁更改的值传递给着色器的最有效方法。将小数据缓冲区传递给着色器的更有效方法是推式常量（push constants）。我们可以在以后的章节中看到。 在下一章中，我们将讨论描述符集，它实际上将VkBuffers绑定到统一缓冲区描述符，以便着色器可以访问相关的转换数据（转换矩阵等）。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(21)-顶点缓冲区-索引缓冲区","slug":"学习一个vulkan-21-顶点缓冲区-索引缓冲区","date":"2018-11-21T01:20:41.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/21/学习一个vulkan-21-顶点缓冲区-索引缓冲区/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/21/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-21-%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA-%E7%B4%A2%E5%BC%95%E7%BC%93%E5%86%B2%E5%8C%BA/","excerpt":"继续上一次的","text":"继续上一次的 介绍在实际应用程序中渲染的3D网格通常会在多个三角形之间共享顶点。即使是像绘制矩形这样简单的事情，这种情况也会发生： 绘制一个矩形需要两个三角形，这意味着我们需要一个带有6个顶点的顶点缓冲区。问题是两个顶点的数据会重复，这导致了50％的冗余。这在更复杂的网格时会变得更糟，平均每三个三角形就会发生重复顶点使用的情况。该问题的解决方案是使用索引缓冲区（index buffer）。 索引缓冲区本质上是指向顶点缓冲区的指针数组。它允许您重新排序顶点数据，并重用多个顶点的现有数据。上图显示了如果我们有一个只包含四个顶点的顶点缓冲区，那么矩形的索引缓冲区会是什么样子，前三个索引定义右上三角形，后三个索引定义左下三角形的顶点。 创建索引缓冲区在本章中，我们将修改顶点数据并添加索引数据以绘制如图中的矩形。修改顶点数据以表示四个角： 123456const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;-0.5f, -0.5f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, -0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;&#125;&#125;; 左上角为红色，右上角为绿色，右下角为蓝色，左下角为白色。我们将添加一个新的数组索引来表示索引缓冲区的内容。它和图中的索引相匹配用来绘制右上角三角形和左下角三角形。 123const std::vector&lt;uint16_t&gt; indices = &#123; 0, 1, 2, 2, 3, 0&#125;; 根据顶点中的条目数，可以使用uint16_t或uint32_t作为索引缓冲区。我们现在可以使用uint16_t，因为我们使用的顶点不到65535个。 就像顶点数据一样，索引需要上传到VkBuffer中，以便GPU能够访问它们。定义两个新的类成员来保存索引缓冲区的资源： 1234VkBuffer vertexBuffer;VkDeviceMemory vertexBufferMemory;VkBuffer indexBuffer;VkDeviceMemory indexBufferMemory; 现在要添加的createIndexBuffer函数，内容几乎与createVertexBuffer一模一样： 1234567891011121314151617181920212223242526void initVulkan() &#123; ... createVertexBuffer(); createIndexBuffer(); ...&#125;void createIndexBuffer() &#123; VkDeviceSize bufferSize = sizeof(indices[0]) * indices.size(); VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory); void* data; vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data); memcpy(data, indices.data(), (size_t) bufferSize); vkUnmapMemory(device, stagingBufferMemory); createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_INDEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, indexBuffer, indexBufferMemory); copyBuffer(stagingBuffer, indexBuffer, bufferSize); vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr);&#125; 有两个地方有差别。bufferSize等于索引的大小乘以类型（uint16_t或uint32_t）的大小。indexBuffer的用法应该是VK_BUFFER_USAGE_INDEX_BUFFER_BIT而不是VK_BUFFER_USAGE_VERTEX_BUFFER_BIT。除此之外，其他部分完全相同。我们创建一个临时缓冲区来复制索引的内容，然后将其复制到最终的设备本地索引缓冲区。 和顶点缓冲区一样，应该在程序结束时清理索引缓冲区： 1234567891011void cleanup() &#123; cleanupSwapChain(); vkDestroyBuffer(device, indexBuffer, nullptr); vkFreeMemory(device, indexBufferMemory, nullptr); vkDestroyBuffer(device, vertexBuffer, nullptr); vkFreeMemory(device, vertexBufferMemory, nullptr); ...&#125; 使用索引缓冲区使用索引缓冲区进行绘制涉及对createCommandBuffers的两个更改。我们首先需要绑定索引缓冲区，就像我们对顶点缓冲区所做的那样，不同之处在于索引缓冲区只能有一个。遗憾的是，不可能为每个顶点属性使用不同的索引，因此即使只有一个属性变化，我们仍然必须完全复制顶点数据。 123vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);vkCmdBindIndexBuffer(commandBuffers[i], indexBuffer, 0, VK_INDEX_TYPE_UINT16); 使用vkCmdBindIndexBuffer绑定索引缓冲区，参数分别是索引缓冲区，字节偏移量和索引数据类型作为参数。和前面说的一样，可能的类型是VK_INDEX_TYPE_UINT16和VK_INDEX_TYPE_UINT32。 只是绑定索引缓冲区还没有改变任何东西，我们还需要更改绘图命令以告诉Vulkan使用索引缓冲区。删除vkCmdDraw行并将其替换为vkCmdDrawIndexed： 1vkCmdDrawIndexed(commandBuffers[i], static_cast&lt;uint32_t&gt;(indices.size()), 1, 0, 0, 0); 对此函数的调用与vkCmdDraw非常相似。前两个参数指定了索引数和实例数，我们没有使用实例化，所以只需指定1个实例。索引数表示将传递给顶点缓冲区的顶点数。下一个参数指定索引缓冲区的偏移量，如果使用值1将会导致显卡在第二个索引处开始读取。倒数第二个参数指定要添加到索引缓冲区中索引的偏移量，最后一个参数指定了实例化的偏移量，我们没有用到。 现在运行您的程序，您应该看到以下内容： 您现在知道如何通过使用索引缓冲区重用顶点来节省内存了。这将在我们将要加载复杂3D模型的未来章节中变得尤为重要。 前一章已经提到过你应该使用单个分配内存来分配多个资源，比如缓冲区，但事实上你应该更进一步。驱动程序开发人员还建议您将多个缓冲区（如顶点和索引缓冲区）存储到单个VkBuffer中，并在vkCmdBindVertexBuffers等命令中使用偏移量。优点在于，在这种情况下，数据会更加充分的利用缓存，因为它们排列在一块区域。如果在相同的渲染操作期间不使用相同的内存块，甚至可以重复使用相同的内存块，只要刷新数据即可。该技巧称为称为aliasing，一些Vulkan函数有明确的标志指定这样做。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(20)-顶点缓冲区-临时缓冲区","slug":"学习一个vulkan-20-顶点缓冲区-临时缓冲区","date":"2018-11-20T01:05:14.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/20/学习一个vulkan-20-顶点缓冲区-临时缓冲区/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/20/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-20-%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA-%E4%B8%B4%E6%97%B6%E7%BC%93%E5%86%B2%E5%8C%BA/","excerpt":"继续上一次的","text":"继续上一次的 介绍我们现在的顶点缓冲区工作正常，但允许我们从CPU访问它的内存类型可能不是显卡本身能够读取的最佳内存类型。最佳内存具有VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT的标志，并且CPU通常无法在专用显卡上访问。在本章中，我们将创建两个顶点缓冲区。一个是临时缓冲区（staging buffer），CPU可以将数据从顶点数组上传到其中，另一个是用于设备本地内存中的最终顶点缓冲区。然后，我们将使用缓冲区复制命令将数据从临时缓冲区移动到实际的顶点缓冲区。 传输队列缓冲区复制命令需要一个支持传输操作的队列簇，使用VK_QUEUE_TRANSFER_BIT指示。好消息是任何具有VK_QUEUE_GRAPHICS_BIT或VK_QUEUE_COMPUTE_BIT功能的队列簇都已经隐式支持VK_QUEUE_TRANSFER_BIT操作了。在这些情况下，并不需要在queueFlags中明确的列出它。 如果您喜欢挑战，那么仍然可以尝试使用专门用于传输操作的不同队列簇。它将要求您对您的程序进行以下修改： 修改QueueFamilyIndi​​ces和findQueueFamilies以显式查找具有VK_QUEUE_TRANSFER标志位位但不是VK_QUEUE_GRAPHICS_BIT的队列簇。 修改createLogicalDevice以请求传输队列的句柄 为传输队列簇上提交的命令缓冲区创建第二个命令池 将资源的sharingMode更改为VK_SHARING_MODE_CONCURRENT并指定图形和传输队列簇 任何传输命令，如vkCmdCopyBuffer（我们将在本章中使用）都需要提交到到传输队列而不是图形队列 工作量有一点点，但它可以教你如何在队列簇之间共享资源。 创建抽象缓冲区因为我们将在本章中创建多个缓冲区，所以将缓冲区创建移动到辅助函数会更好一点。创建一个新的函数createBuffer并将createVertexBuffer中的代码（除外映射相关的）移动到这里。 12345678910111213141516171819202122232425void createBuffer(VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags properties, VkBuffer&amp; buffer, VkDeviceMemory&amp; bufferMemory) &#123; VkBufferCreateInfo bufferInfo = &#123;&#125;; bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; bufferInfo.size = size; bufferInfo.usage = usage; bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; if (vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;buffer) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create buffer!&quot;); &#125; VkMemoryRequirements memRequirements; vkGetBufferMemoryRequirements(device, buffer, &amp;memRequirements); VkMemoryAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; allocInfo.allocationSize = memRequirements.size; allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, properties); if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;bufferMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate buffer memory!&quot;); &#125; vkBindBufferMemory(device, buffer, bufferMemory, 0);&#125; 确保为缓冲区大小，内存属性和用法添加参数，以便我们可以使用此函数创建许多不同类型的缓冲区。最后两个参数是输出变量用来写入句柄。 从createVertexBuffer中删除缓冲区创建和内存分配代码，现在只需调用createBuffer就行了： 123456789void createVertexBuffer() &#123; VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size(); createBuffer(bufferSize, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, vertexBuffer, vertexBufferMemory); void* data; vkMapMemory(device, vertexBufferMemory, 0, bufferSize, 0, &amp;data); memcpy(data, vertices.data(), (size_t) bufferSize); vkUnmapMemory(device, vertexBufferMemory);&#125; 运行程序以确保顶点缓冲区仍能正常工作。 使用临时缓冲区我们现在要将createVertexBuffer更改为仅使用主机可见缓冲区作为临时缓冲区，并使用设备本地缓冲区作为实际顶点缓冲区。 1234567891011121314void createVertexBuffer() &#123; VkDeviceSize bufferSize = sizeof(vertices[0]) * vertices.size(); VkBuffer stagingBuffer; VkDeviceMemory stagingBufferMemory; createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, stagingBuffer, stagingBufferMemory); void* data; vkMapMemory(device, stagingBufferMemory, 0, bufferSize, 0, &amp;data); memcpy(data, vertices.data(), (size_t) bufferSize); vkUnmapMemory(device, stagingBufferMemory); createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);&#125; 我们现在使用带有stagingBufferMemory的新stagingBuffer来映射和复制顶点数据。在本章中，我们将使用两个新的缓冲区使用标志符： VK_BUFFER_USAGE_TRANSFER_SRC_BIT：缓冲区可用作存储器传输操作中的源头。 VK_BUFFER_USAGE_TRANSFER_DST_BIT：缓冲区可用作存储器传输操作中的目标。 vertexBuffer现在是从设备本地的内存类型中分配的，这通常意味着我们无法使用vkMapMemory。但是，我们可以将数据从stagingBuffer复制到vertexBuffer。我们需要指定stagingBuffer的传输源标志位，还要为顶点缓冲区vertexBuffer设置传输目标标志位以及顶点缓冲区使用标志。 我们现在要写一个copyBuffer函数将相关内容从一个缓冲区复制到另一个缓冲区： 123void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) &#123;&#125; 内存传输操作也是通过命令缓冲区执行的，就像绘制命令一样。因此我们必须首先分配一个临时命令缓冲区。您可能希望为短期缓冲区来创建单独的命令池，因为该实现可能能够应用内存分配优化。在这种情况下，您应该在命令池生成期间使用VK_COMMAND_POOL_CREATE_TRANSIENT_BIT标志。 12345678910void copyBuffer(VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize size) &#123; VkCommandBufferAllocateInfo allocInfo = &#123;&#125;; allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY; allocInfo.commandPool = commandPool; allocInfo.commandBufferCount = 1; VkCommandBuffer commandBuffer; vkAllocateCommandBuffers(device, &amp;allocInfo, &amp;commandBuffer);&#125; 并立即开始命令缓冲区的记录： 12345VkCommandBufferBeginInfo beginInfo = &#123;&#125;;beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT;vkBeginCommandBuffer(commandBuffer, &amp;beginInfo); 这里不需要我们用于绘图命令缓冲区的VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT标志，因为我们只使用命令缓冲区一次并等待从函数返回直到复制操作完成执行。使用VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT来告诉驱动程序我们的意图是一个好习惯。 12345VkBufferCopy copyRegion = &#123;&#125;;copyRegion.srcOffset = 0; // OptionalcopyRegion.dstOffset = 0; // OptionalcopyRegion.size = size;vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, 1, &amp;copyRegion); 使用vkCmdCopyBuffer命令来传输缓冲区的内容。它将源缓冲区和目标缓冲区以及要复制的区域数组作为参数。区域在VkBufferCopy结构中定义，由源缓冲区、目标缓冲区的偏移量和大小组成。与vkMapMemory命令不同，此处无法指定VK_WHOLE_SIZE。 1vkEndCommandBuffer(commandBuffer); 此命令缓冲区仅包含复制命令，因此我们可以在此之后立即停止录制。现在执行命令缓冲区以完成传输： 1234567VkSubmitInfo submitInfo = &#123;&#125;;submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;submitInfo.commandBufferCount = 1;submitInfo.pCommandBuffers = &amp;commandBuffer;vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE);vkQueueWaitIdle(graphicsQueue); 与绘制命令不同的是，这个时候我们不需要等待任何事件，我们只想立即在缓冲区上执行传输命令。还有两种方法可以等待传输命令完成。我们可以使用栅栏fence并使用vkWaitForFences来等待，或者只是使用vkQueueWaitIdle来等待传输队列变为空闲。栅栏允许您同时安排多个传输并等待所有传输完成，而不是一次执行一个，这就给了驱动程序更多的优化空间。 1vkFreeCommandBuffers(device, commandPool, 1, &amp;commandBuffer); 不要忘记清理用于传输操作的命令缓冲区。 我们现在可以从createVertexBuffer函数调用copyBuffer来将顶点数据移动到设备本地缓冲区： 123createBuffer(bufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, vertexBuffer, vertexBufferMemory);copyBuffer(stagingBuffer, vertexBuffer, bufferSize); 将数据从临时缓冲区复制到设备缓冲区后，我们应该清理它： 1234567 ... copyBuffer(stagingBuffer, vertexBuffer, bufferSize); vkDestroyBuffer(device, stagingBuffer, nullptr); vkFreeMemory(device, stagingBufferMemory, nullptr);&#125; 运行程序以验证是否再次看到三角形。这种改进目前可能不可见，但其顶点数据现在正从高性能内存加载。当我们要开始渲染更复杂的几何体时，这会变得很重要。 结论应该注意的是，在实际的应用程序中，您不应该为每个缓冲区都调用vkAllocateMemory。最大并发内存分配数受maxMemoryAllocationCount物理设备限制的限制，即使在像NVIDIA GTX 1080这样的高端硬件上也可能低至4096。为大量对象同时分配内存的正确方法是创建一个自定义分配器，通过使用我们在许多函数中看到的偏移参数，在多个不同对象之间拆分成单个进行分配。 您可以自己实现这样的分配器，也可以使用GPUOpen计划提供的VulkanMemoryAllocator库。但是，对于本教程，可以为每个资源使用单独的分配，因为我们现在不会接近任何的限制。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(19)-顶点缓冲区-创建顶点缓冲区","slug":"学习一个vulkan-19-顶点缓冲区-创建顶点缓冲区","date":"2018-11-19T01:56:22.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/19/学习一个vulkan-19-顶点缓冲区-创建顶点缓冲区/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/19/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-19-%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA-%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA/","excerpt":"继续上一次的","text":"继续上一次的 介绍Vulkan中的缓冲区是用于存储由显卡读取的任意数据的存储区域。它们可用于存储顶点数据，也可用于将在以后的章节中探讨的许多其他目的。与我们到目前为止处理的Vulkan对象不同，缓冲区不会自动为自己分配内存。前几章的工作表明，Vulkan API使程序员几乎可以控制其中的所有内容，内存管理就是其中之一。 创建缓冲区在initVulkan中创建一个新函数createVertexBuffer，并在createCommandBuffers之前调用： 12345678910111213141516171819202122void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createVertexBuffer(); createCommandBuffers(); createSyncObjects();&#125;...void createVertexBuffer() &#123;&#125; 创建缓冲区需要我们填充VkBufferCreateInfo结构： 123VkBufferCreateInfo bufferInfo = &#123;&#125;;bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;bufferInfo.size = sizeof(vertices[0]) * vertices.size(); 这个结构的第一参数是size，它以字节为单位指定缓冲区的大小，使用sizeof就能很简单的计算出顶点数据的字节大小了。 1bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT; 第二个参数是usage，它指示将使用缓冲区中的数据的目的，可以使用按位或来指定多个目的。我们的示例就是一个简单的顶点缓冲区，我们将在后面的章节中介绍其他类型的用法。 1bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; 就像交换链中的图像一样，缓冲区也可以由特定队列簇拥有，或者同时在多个队列簇之间共享。缓冲区仅用于图形队列，因此我们使用独占的方式来访问。 flags参数用于配置稀疏缓冲区内存，这与目前的功能无关。我们将其保留为默认值0。 我们现在可以使用vkCreateBuffer来创建缓冲区了。定义一个类成员来保存缓冲区句柄并将其命名为vertexBuffer： 123456789101112131415VkBuffer vertexBuffer;...void createVertexBuffer() &#123; VkBufferCreateInfo bufferInfo = &#123;&#125;; bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; bufferInfo.size = sizeof(vertices[0]) * vertices.size(); bufferInfo.usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT; bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; if (vkCreateBuffer(device, &amp;bufferInfo, nullptr, &amp;vertexBuffer) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create vertex buffer!&quot;); &#125;&#125; 缓冲区应该在从渲染命令到程序结束都是可用的，并且它不依赖于交换链，所以我们将在原始的cleanup函数中清理它： 1234567void cleanup() &#123; cleanupSwapChain(); vkDestroyBuffer(device, vertexBuffer, nullptr); ...&#125; 内存要求虽然缓冲区已经创建了，但实际上还没有分配任何内存。为缓冲区分配内存的第一步是使用vkGetBufferMemoryRequirements函数查询其内存需求。 12VkMemoryRequirements memRequirements;vkGetBufferMemoryRequirements(device, vertexBuffer, &amp;memRequirements); VkMemoryRequirements结构有三个参数： size：所需内存的大小（以字节为单位）可能与bufferInfo.size不同。 alignment：缓冲区在分配的内存区域中开始时的字节偏移量，取决于bufferInfo.usage和bufferInfo.flags。 memoryTypeBits：适合缓冲区的内存类型的位字段。 显卡可以提供不同类型的内存来分配，每种类型的存储器在允许的操作和性能特征方面都有所不同。我们需要结合缓冲区的要求和我们自己的应用程序要求来找到要使用的正确类型的内存，为此创建一个新函数findMemoryType： 123uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) &#123;&#125; 首先，我们需要使用vkGetPhysicalDeviceMemoryProperties查询有关可用内存类型的信息。 12VkPhysicalDeviceMemoryProperties memProperties;vkGetPhysicalDeviceMemoryProperties(physicalDevice, &amp;memProperties); VkPhysicalDeviceMemoryProperties结构有两个数组memoryTypes和memoryHeaps。内存堆是很多不同的内存资源，就像专用VRAM和当VRAM用完时RAM中的交换空间（swap space）。这些堆中存在不同类型的存储器，目前我们只关心内存的类型而不是它来自的堆，虽然这样显然会影响性能。 让我们首先找到一个适合缓冲区本身的内存类型： 1234567for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) &#123; if (typeFilter &amp; (1 &lt;&lt; i)) &#123; return i; &#125;&#125;throw std::runtime_error(&quot;failed to find suitable memory type!&quot;); typeFilter参数将用于指定适合的内存类型的位字段。这意味着我们可以通过简单地迭代它们并检查相应的位是否设置为1来找到合适的存储器类型的索引。 但是，我们不仅仅是对适合顶点缓冲区的内存类型感兴趣，我们还需要能够将顶点数据写入该内存。memoryTypes数组由VkMemoryType结构组成，这些结构指定每种类型内存的堆和属性。这些属性定义了内存的特殊功能，比如能够映射它，这样我们就可以从CPU写入它了。这个属性用VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT表示，但我们还需要使用VK_MEMORY_PROPERTY_HOST_COHERENT_BIT属性，当我们映射内存时，我们就能看到原因了。 我们现在可以修改循环以检查此属性的支持： 12345for (uint32_t i = 0; i &lt; memProperties.memoryTypeCount; i++) &#123; if ((typeFilter &amp; (1 &lt;&lt; i)) &amp;&amp; (memProperties.memoryTypes[i].propertyFlags &amp; properties) == properties) &#123; return i; &#125;&#125; 我们可能有多个理想的属性，因此我们应该检查按位与的结果是否不仅仅是非零，而是等于所需的属性位字段。如果有一个适合缓冲区的内存类型同时还具有我们需要的所有属性，那么我们返回它的索引，否则我们抛出异常。 内存分配我们现在有办法确定正确的内存类型了，因此我们可以通过填充VkMemoryAllocateInfo结构来实际分配内存。 1234VkMemoryAllocateInfo allocInfo = &#123;&#125;;allocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;allocInfo.allocationSize = memRequirements.size;allocInfo.memoryTypeIndex = findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT); 内存分配现在就像指定大小和类型一样简单，这两者都是从顶点缓冲区的内存需求和所需属性中派生的。创建一个类成员来存储句柄并使用vkAllocateMemory进行分配。 12345678VkBuffer vertexBuffer;VkDeviceMemory vertexBufferMemory;...if (vkAllocateMemory(device, &amp;allocInfo, nullptr, &amp;vertexBufferMemory) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate vertex buffer memory!&quot;);&#125; 如果内存分配成功，那么我们现在可以使用vkBindBufferMemory将此内存与缓冲区关联： 1vkBindBufferMemory(device, vertexBuffer, vertexBufferMemory, 0); 前三个参数是很简单，第四个参数是内存区域内的偏移量。由于此内存是专门为该顶点缓冲区分配的，因此偏移量为0。如果偏移量不为零，则需要通过memRequirements.alignment对其进行整除。 当然，就像C++中的动态内存分配一样，内存应该在某个时候被释放。一旦缓冲区不再使用，绑定到缓冲区对象的内存会被释放，所以在缓冲区被销毁后释放它： 12345void cleanup() &#123; cleanupSwapChain(); vkDestroyBuffer(device, vertexBuffer, nullptr); vkFreeMemory(device, vertexBufferMemory, nullptr); 填充顶点缓冲区现在是时候将顶点数据复制到缓冲区了。这是通过使用vkMapMemory将缓冲区内存映射到CPU可访问内存来完成的。 12void* data;vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &amp;data); 此函数允许我们访问由偏移量和大小定义的指定内存资源的区域，这里的偏移量和大小分别为0和bufferInfo.size，也可以指定特殊值VK_WHOLE_SIZE来映射所有内存。倒数第二个参数可用于指定标志，但当前API中尚无任何可用标志，现在必须设置为0。最后一个参数指定指向映射内存的指针的输出。 1234void* data;vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &amp;data); memcpy(data, vertices.data(), (size_t) bufferInfo.size);vkUnmapMemory(device, vertexBufferMemory); 您现在可以简单地使用memcpy将顶点数据映射到内存，并使用vkUnmapMemory取消映射。不幸的是，驱动程序可能不会立即将数据复制到缓冲存储器中，例如由于缓存的原因。在映射的内存中，对缓冲区的写入也可能不可见。有两种方法可以解决这个问题： 使用主机一致的内存堆，用VK_MEMORY_PROPERTY_HOST_COHERENT_BIT表示 在写入映射内存之后调用vkFlushMappedMemoryRanges，并在从映射内存中读取之前调用vkInvalidateMappedMemoryRanges 我们采用了第一种方法，它确保映射的内存始终与分配的内存的内容相匹配。请记住，这可能会导致性能略差于显式刷新，但这并没有什么太大的关系，我们将在下一章解释这一点。 绑定顶点缓冲区现在剩下的就是在渲染操作期间绑定顶点缓冲区了。我们将扩展createCommandBuffers函数来做到这一点： 1234567vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);VkBuffer vertexBuffers[] = &#123;vertexBuffer&#125;;VkDeviceSize offsets[] = &#123;0&#125;;vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);vkCmdDraw(commandBuffers[i], static_cast&lt;uint32_t&gt;(vertices.size()), 1, 0, 0); vkCmdBindVertexBuffers函数用于绑定顶点缓冲区，就像我们在前一章中设置的那样。除了命令缓冲区之外，前两个参数指定了我们要为其指定顶点缓冲区的偏移量和绑定数。最后两个参数指定要绑定的顶点缓冲区数组和开始从中读取顶点数据的字节偏移量。您还应该将调用更改为vkCmdDraw以传递缓冲区中的顶点数，而不是硬编码的数字3。 现在运行该程序，您应该又可以看到这个熟悉的三角形了： 尝试通过修改顶点数组将顶部顶点的颜色更改为白色： 12345const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;0.0f, -0.5f&#125;, &#123;1.0f, 1.0f, 1.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125;&#125;; 再次运行该程序，您应该看到下面的结果： 在下一章中，我们将介绍将顶点数据复制到顶点缓冲区以获得更好性能的不同方法，当然也需要做更多工作。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(18)-顶点缓冲区-顶点输入描述","slug":"学习一个vulkan-18-顶点缓冲区-顶点输入描述","date":"2018-11-17T01:50:52.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/17/学习一个vulkan-18-顶点缓冲区-顶点输入描述/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/17/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-18-%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA-%E9%A1%B6%E7%82%B9%E8%BE%93%E5%85%A5%E6%8F%8F%E8%BF%B0/","excerpt":"继续上一次的","text":"继续上一次的 介绍在接下来的几章中，我们将使用内存中的顶点缓冲区替换顶点着色器中的硬编码顶点数据。我们将从创建CPU可见的缓冲区并使用memcpy直接将顶点数据复制到其中这种最简单的方法开始，之后我们将看到如何使用临时缓冲区将顶点数据复制到高性能内存中。 顶点着色器首先将顶点着色器更改为不在着色器代码本身中包含顶点数据。顶点着色器使用in关键字从顶点缓冲区获取输入： 12345678910111213141516#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec2 inPosition;layout(location = 1) in vec3 inColor;layout(location = 0) out vec3 fragColor;out gl_PerVertex &#123; vec4 gl_Position;&#125;;void main() &#123; gl_Position = vec4(inPosition, 0.0, 1.0); fragColor = inColor;&#125; inPosition和inColor变量称为顶点属性（vertex attributes）。它们是在顶点缓冲区中按顶点指定的相应属性，就和之前我们手动分配数组来指定每个顶点的位置和颜色一样。现在重新编译顶点着色器。 就像fragColor一样，layout(location &#x3D; x) 告诉了我们以后引用他们时使用的索引。了解其中的某些类型是很重要的，如dvec3 是64位向量，使用了多个槽（slots）。这意味着它之后的索引必须至少高于2： 12layout(location = 0) in dvec3 inPosition;layout(location = 2) in vec3 inColor; 您可以在OpenGL wiki中找到有关布局限定符的更多信息。 顶点数据我们将顶点数据的代码从着色器移动到我们程序代码的数组中。首先引入GLM库，它为我们提供了线性代数相关类型，如矢量和矩阵，我们将使用这些类型来指定位置和颜色向量。 创建一个名为Vertex的新结构，其中包含我们将在顶点着色器中使用的两个属性： 1234struct Vertex &#123; glm::vec2 pos; glm::vec3 color;&#125;; GLM为我们提供了与着色器语言中使用的矢量类型完全匹配的C++类型。 12345const std::vector&lt;Vertex&gt; vertices = &#123; &#123;&#123;0.0f, -0.5f&#125;, &#123;1.0f, 0.0f, 0.0f&#125;&#125;, &#123;&#123;0.5f, 0.5f&#125;, &#123;0.0f, 1.0f, 0.0f&#125;&#125;, &#123;&#123;-0.5f, 0.5f&#125;, &#123;0.0f, 0.0f, 1.0f&#125;&#125;&#125;; 现在使用Vertex结构指定顶点数据数组。我们使用与以前完全相同的位置和颜色值，但现在它们被组合成一个顶点数组，这称为交错顶点属性（interleaving vertex attributes）。 绑定相关描述下一步是告诉Vulkan在将数据格式上传到GPU内存后如何将此数据格式传递给顶点着色器。传达此信息需要两种类型的结构。 第一个结构是VkVertexInputBindingDescription，我们将向Vertex结构添加一个成员函数，然后用正确的数据填充它。 12345678910struct Vertex &#123; glm::vec2 pos; glm::vec3 color; static VkVertexInputBindingDescription getBindingDescription() &#123; VkVertexInputBindingDescription bindingDescription = &#123;&#125;; return bindingDescription; &#125;&#125;; 顶点绑定描述了在整个过程中顶点从内存加载数据的速率。它指定了数据条目之间的字节数以及是在每个顶点之后还是在每个实例之后移动到下一个数据条目。 1234VkVertexInputBindingDescription bindingDescription = &#123;&#125;;bindingDescription.binding = 0;bindingDescription.stride = sizeof(Vertex);bindingDescription.inputRate = VK_VERTEX_INPUT_RATE_VERTEX; 我们所有的顶点数据都被打包在一个数组中，所以我们只需要一个绑定。binding参数指定绑定数组中绑定的索引。stride参数指定从一个条目到下一个条目的字节数，inputRate参数可以具有以下值之一： VK_VERTEX_INPUT_RATE_VERTEX：在每个顶点之后移动到下一个数据条目 VK_VERTEX_INPUT_RATE_INSTANCE：在每个实例之后移动到下一个数据条目 我们不打算使用实例渲染，因此我们这里使用逐顶点数据。 属性描述描述如何处理顶点输入的第二个结构是VkVertexInputAttributeDescription。我们将为Vertex添加另一个辅助函数来填充这个结构： 123456789#include &lt;array&gt;...static std::array&lt;VkVertexInputAttributeDescription, 2&gt; getAttributeDescriptions() &#123; std::array&lt;VkVertexInputAttributeDescription, 2&gt; attributeDescriptions = &#123;&#125;; return attributeDescriptions;&#125; 正如函数原型所示，将会有两个这样的结构。属性描述结构描述了如何从源自绑定描述的顶点数据块中提取顶点属性。我们有两个属性，位置和颜色，所以我们需要两个属性描述结构。 1234attributeDescriptions[0].binding = 0;attributeDescriptions[0].location = 0;attributeDescriptions[0].format = VK_FORMAT_R32G32_SFLOAT;attributeDescriptions[0].offset = offsetof(Vertex, pos); 绑定参数告诉Vulkan每个顶点数据的绑定来源。location参数引用顶点着色器中输入的location指令。在我们的顶点着色器中，location为0代表的就是位置（position）了，它是32bit单精度数据。 format参数描述了属性的数据类型。有点令人困惑的是，这个格式是使用与颜色格式相同的枚举来指定的。下列的着色器类型和格式是比较常用的搭配： float: VK_FORMAT_R32_SFLOAT vec2: VK_FORMAT_R32G32_SFLOAT vec3: VK_FORMAT_R32G32B32_SFLOAT vec4: VK_FORMAT_R32G32B32A32_SFLOAT 如您所见，您应该使用颜色通道数量与着色器数据类型中的组件数量匹配的格式。虽然也可以使用比着色器中的组件数量更多的通道，但它们将会被静默丢弃。如果通道数低于组件数，则BGA组件将会使用默认值（0,0,1）。颜色的类型（SFLOAT，UINT，SINT）和位宽也应与着色器输入的类型匹配。请参阅以下示例： ivec2: VK_FORMAT_R32G32_SINT，一个32位有符号整数的双分量向量 uvec4: VK_FORMAT_R32G32B32A32_UINT，一个32位无符号整数的4分量向量 double: VK_FORMAT_R64_SFLOAT，双精度（64位）浮点数 format参数隐式定义了属性数据的字节大小，offset参数指定了每个顶点数据读取的字节宽度偏移量。绑定一次就会加载一个Vertex，position属性(pos)的偏移量在字节数据中为0字节，这是使用offsetof宏自动计算的。 1234attributeDescriptions[1].binding = 0;attributeDescriptions[1].location = 1;attributeDescriptions[1].format = VK_FORMAT_R32G32B32_SFLOAT;attributeDescriptions[1].offset = offsetof(Vertex, color); color属性的描述方式也大致相同。 管道顶点输入我们现在需要通过引用createGraphicsPipeline中的结构来设置图形管道来接受这个格式的顶点数据。修改vertexInputInfo结构以引用这两个描述： 1234567auto bindingDescription = Vertex::getBindingDescription();auto attributeDescriptions = Vertex::getAttributeDescriptions();vertexInputInfo.vertexBindingDescriptionCount = 1;vertexInputInfo.vertexAttributeDescriptionCount = static_cast&lt;uint32_t&gt;(attributeDescriptions.size());vertexInputInfo.pVertexBindingDescriptions = &amp;bindingDescription;vertexInputInfo.pVertexAttributeDescriptions = attributeDescriptions.data(); 现在，管道已准备好接受顶点容器格式的顶点数据并将其传递给顶点着色器了。如果现在在启用验证层的情况下运行程序，您将看到没有绑定的顶点缓冲区的提示。下一步是创建顶点缓冲区并将顶点数据移动到顶点缓冲区，以便GPU能够访问它。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(17)-画个三角形-重构交换链","slug":"学习一个vulkan-17-画个三角形-重构交换链","date":"2018-11-16T01:45:47.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/16/学习一个vulkan-17-画个三角形-重构交换链/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/16/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-17-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E9%87%8D%E6%9E%84%E4%BA%A4%E6%8D%A2%E9%93%BE/","excerpt":"继续上一次的","text":"继续上一次的 介绍我们现在的应用程序可以成功绘制一个三角形了，但对于某些情况它还不能正确的处理。其中一个可能的情况就是窗口表面可能会发生变化，使得交换链不再与之兼容。导致这种情况发生的原因之一是窗口大小的变化，我们必须捕获这些事件并重新创建交换链。 重新创建交换链创建一个新的recreateSwapChain函数，该函数调用createSwapChain以及依赖于交换链或窗口大小对象的所有相关的创建函数： 12345678910void recreateSwapChain() &#123; vkDeviceWaitIdle(device); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers();&#125; 我们首先调用vkDeviceWaitIdle，因为就像在上一章中一样，我们不应该触及到可能仍在使用中的资源。显然，我们要做的第一件事就是重新构建交换链本身，还需要重新创建图像视图，因为它们是直接基于交换链图像的，也需要重新创建渲染过程，因为它取决于交换链图像的格式，虽然交换链图像格式很少在窗口调整大小等操作期间发生变化，但仍应进行处理。视口和裁剪矩形的大小是在创建图形管道期间指定的，因此还需要重建管道。也可以通过对视口和裁剪矩形使用动态状态来避免这种情况。最后，帧缓冲区和命令缓冲区也直接依赖于交换链图像，所以也要重建。 为了确保在重新创建它们之前可以清除这些对象的旧版本，我们应该将一些清理代码移动到我们可以从recreateSwapChain中调用的单独的函数中。这里创建cleanupSwapChain： 12345678910111213141516void cleanupSwapChain() &#123;&#125;void recreateSwapChain() &#123; vkDeviceWaitIdle(device); cleanupSwapChain(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandBuffers();&#125; 我们从cleanup中将需要被重新创建的对象所对应的清理代码移动到cleanupSwapChain中: 123456789101112131415161718192021222324252627282930313233343536373839404142void cleanupSwapChain() &#123; for (size_t i = 0; i &lt; swapChainFramebuffers.size(); i++) &#123; vkDestroyFramebuffer(device, swapChainFramebuffers[i], nullptr); &#125; vkFreeCommandBuffers(device, commandPool, static_cast&lt;uint32_t&gt;(commandBuffers.size()), commandBuffers.data()); vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) &#123; vkDestroyImageView(device, swapChainImageViews[i], nullptr); &#125; vkDestroySwapchainKHR(device, swapChain, nullptr);&#125;void cleanup() &#123; cleanupSwapChain(); for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr); vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr); vkDestroyFence(device, inFlightFences[i], nullptr); &#125; vkDestroyCommandPool(device, commandPool, nullptr); vkDestroyDevice(device, nullptr); if (enableValidationLayers) &#123; DestroyDebugReportCallbackEXT(instance, callback, nullptr); &#125; vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate();&#125; 我们可以从头开始重新创建命令池，但这太浪费了。这里选择使用vkFreeCommandBuffers函数来清理现有的命令缓冲区。这样我们就可以重用现有的池来分配新的命令缓冲区。 要正确处理窗口大小调整，我们还需要查询帧缓冲区的当前大小，以确保交换链图像具有（新的）正确的尺寸。要做到这一点，需要更改chooseSwapExtent函数以考虑实际大小： 123456789101112131415VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities) &#123; if (capabilities.currentExtent.width != std::numeric_limits&lt;uint32_t&gt;::max()) &#123; return capabilities.currentExtent; &#125; else &#123; int width, height; glfwGetFramebufferSize(window, &amp;width, &amp;height); VkExtent2D actualExtent = &#123; static_cast&lt;uint32_t&gt;(width), static_cast&lt;uint32_t&gt;(height) &#125;; ... &#125;&#125; 这就是重建交换链需要的所有东西了。但是，这种方法的缺点是我们需要在创建新的交换链之前停止所有渲染。在旧交换链的绘制命令执行过程时来创建新的交换链是可能的，您需要将之前的交换链传递给VkSwapchainCreateInfoKHR结构中的oldSwapChain字段，并在完成使用后立即销毁旧的交换链。 次优或过时的交换链现在我们只需要确定何时需要交换链重新创建并调用我们的新的recreateSwapChain函数。幸运的是，Vulkan在显示期间通常可以告诉我们交换链已经不再适用了，vkAcquireNextImageKHR和vkQueuePresentKHR函数可以返回以下特殊值来指示这个信息： VK_ERROR_OUT_OF_DATE_KHR：交换链已与表面不兼容，无法再用于渲染。通常在窗口调整大小后发生。 VK_SUBOPTIMAL_KHR：交换链仍然可以用于成功呈现到表面，但表面属性不再完全匹配。 12345678VkResult result = vkAcquireNextImageKHR(device, swapChain, std::numeric_limits&lt;uint64_t&gt;::max(), imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex);if (result == VK_ERROR_OUT_OF_DATE_KHR) &#123; recreateSwapChain(); return;&#125; else if (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) &#123; throw std::runtime_error(&quot;failed to acquire swap chain image!&quot;);&#125; 如果交换链在尝试获取图像时过时（out of date）了，则不会再呈现给它。因此，我们应该立即重新创建交换链，并在下一个drawFrame的调用中再次尝试。 但是，如果我们在此时中止绘图，那么栅栏将永远无法通过vkQueueSubmit进行提交，并且当我们稍后尝试等待它时它将处于意外（unexpected）状态。我们可以重新创建围栏作为交换链重新创建的一部分，但移动vkResetFences调用显得更简单： 12345vkResetFences(device, 1, &amp;inFlightFences[currentFrame]);if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#125; 如果交换链不是最理想的话，您也可以同样处理，但在这种情况下我选择继续进行，因为我们已经获取到一个图像了。VK_SUCCESS和VK_SUBOPTIMAL_KHR都被视为“成功”的返回码。 123456789result = vkQueuePresentKHR(presentQueue, &amp;presentInfo);if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR) &#123; recreateSwapChain();&#125; else if (result != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to present swap chain image!&quot;);&#125;currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT; vkQueuePresentKHR函数返回具有相同含义的相同的值。在这种情况下，如果交换链不是最理想的，我们也会重新创建交换链，因为我们希望得到最好的结果。 处理尺寸变化虽然许多驱动程序和平台在窗口调整大小后都会自动触发VK_ERROR_OUT_OF_DATE_KHR，但这种情况是不能完全保证的。这就是为什么我们会添加一些额外的代码来明确的处理尺寸的改变。首先添加一个新的成员变量，标记尺寸改变已发生： 1234std::vector&lt;VkFence&gt; inFlightFences;size_t currentFrame = 0;bool framebufferResized = false; 然后修改drawFrame函数检查此标志： 123456if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || framebufferResized) &#123; framebufferResized = false; recreateSwapChain();&#125; else if (result != VK_SUCCESS) &#123; ...&#125; 现在要实际检测调整大小，我们可以使用GLFW框架中的glfwSetFramebufferSizeCallback函数来设置回调： 123456789101112void initWindow() &#123; glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Vulkan&quot;, nullptr, nullptr); glfwSetFramebufferSizeCallback(window, framebufferResizeCallback);&#125;static void framebufferResizeCallback(GLFWwindow* window, int width, int height) &#123;&#125; 我们创建一个静态函数作为回调的原因是因为GLFW不知道如何正确的使用指向HelloTriangleApplication实例的指针来调用相应的成员函数。 但是，我们确实在回调中获得了对GLFWwindow的引用，并且还有另一个GLFW函数允许您在其中存储任意指针：glfwSetWindowUserPointer： 123window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Vulkan&quot;, nullptr, nullptr);glfwSetWindowUserPointer(window, this);glfwSetFramebufferSizeCallback(window, framebufferResizeCallback); 现在可以使用glfwGetWindowUserPointer从回调中检索这个值，来正确设置标志： 1234static void framebufferResizeCallback(GLFWwindow* window, int width, int height) &#123; auto app = reinterpret_cast&lt;HelloTriangleApplication*&gt;(glfwGetWindowUserPointer(window)); app-&gt;framebufferResized = true;&#125; 现在尝试运行程序并调整窗口大小，查看帧缓冲区是否确实能通过窗口大小的改变来正确调整大小。 处理最小化还有另一种情况，交换链可能会丢失数据，这是一种特殊的窗口大小调整：窗口最小化。这种情况很特殊，因为它会导致帧缓冲区大小为0。在本教程中，我们将通过扩展recreateSwapChain函数，使窗口一直暂停直到他再次回到前台： 1234567891011void recreateSwapChain() &#123; int width = 0, height = 0; while (width == 0 || height == 0) &#123; glfwGetFramebufferSize(window, &amp;width, &amp;height); glfwWaitEvents(); &#125; vkDeviceWaitIdle(device); ...&#125; 现在已经完成了的第一个表现还不错的Vulkan程序。在下一章中，我们将抛弃顶点着色器中的硬编码顶点，真正的使用顶点缓冲区。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(16)-画个三角形(绘制)-渲染和显示","slug":"学习一个vulkan-16-画个三角形-绘制-渲染和显示","date":"2018-11-15T06:42:59.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/15/学习一个vulkan-16-画个三角形-绘制-渲染和显示/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/15/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-16-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E7%BB%98%E5%88%B6-%E6%B8%B2%E6%9F%93%E5%92%8C%E6%98%BE%E7%A4%BA/","excerpt":"继续上一次的","text":"继续上一次的 创建在这个章节里，我们会将所有的东西聚合到一起。现在编写drawFrame函数，该函数在主循环中调用用于将三角形显示到屏幕上。创建函数并在mainLoop里调用它： 123456789101112void mainLoop() &#123; while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); drawFrame(); &#125;&#125;...void drawFrame() &#123;&#125; 同步drawFrame函数将执行以下操作： 从交换链中获取图像 在帧缓冲区中将该图像作为附件执行命令缓冲区中的命令 将图像返回到交换链以进行演示 这些事件中的每一个都需要使用单个函数调用来启动，但它们是异步执行的。函数的调用将会在操作实际完成之前就返回了，并且执行顺序也是未定义的。这是不幸的，因为我们希望每个操作都取决于前一个操作。 有两种同步交换链消息的方法：栅栏和信号量。它们都是可用于协调操作的对象，具有一个操作信号和另一个操作等待栅栏或信号量从无信号状态变为信号状态，如果莫某个操作没有信号，则会一直等待着栅栏或者信号量来令他转换到有信号的状态。 两种方式的区别在于可以使用vkWaitForFences之类的函数从程序中访问栅栏的状态，但是信号量却不行。栅栏主要用于将应用程序本身与渲染操作同步，而信号量用于同步命令队列内或跨命令队列的操作。我们想要同步绘制命令和显示队列操作，这使得使用信号量比较合适。 信号量我们需要一个信号量来表示已经获取了图像并准备好进行渲染，另一个信号量表示渲染已经完成并且可以进行显示。创建两个类成员来存储这些信号量对象： 12VkSemaphore imageAvailableSemaphore;VkSemaphore renderFinishedSemaphore; 要创建信号量，还需要为添加最后的一个create函数：createSemaphores： 123456789101112131415161718192021void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers(); createSemaphores();&#125;...void createSemaphores() &#123;&#125; 创建信号量需要填充VkSemaphoreCreateInfo结构，但是在当前版本的API中，除了sType之外，实际上没有任何必需的字段： 1234void createSemaphores() &#123; VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;&#125; Vulkan API的未来版本或有什么扩展可能会为flags和pNext参数添加一些功能，就像它的其他结构一样。创建信号量vkCreateSemaphor和其他对象的创建模式差不多： 12345if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphore) != VK_SUCCESS || vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphore) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create semaphores!&quot;);&#125; 当程序结束时，所有命令都已完成且不再需要同步时，应清除信号量： 123void cleanup() &#123; vkDestroySemaphore(device, renderFinishedSemaphore, nullptr); vkDestroySemaphore(device, imageAvailableSemaphore, nullptr); 从交换链中获取图像如前所述，我们需要在drawFrame函数中做的第一件事就是从交换链中获取一个图像。回想一下，交换链是一个扩展功能，因此我们必须使用具有vk*KHR命名的函数： 1234void drawFrame() &#123; uint32_t imageIndex; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits&lt;uint64_t&gt;::max(), imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);&#125; vkAcquireNextImageKHR的前两个参数是我们希望从中获取图像的逻辑设备和交换链。第三个参数指定处理图像可用的时间限制（以纳秒为单位），这里使用64位无符号整数的最大值可禁用时间的限制。 接下来的两个参数指定当显示引擎处理完图像后要发出信号的同步对象。这就是开始绘制的时候了，可以指定使用信号量，栅栏或都使用，在此处我们使用imageAvailableSemaphore。 最后一个参数指定一个变量，用于输出已变为可用的交换链图像的索引。索引引用了swapChainImages数组中的VkImage图像，我们将使用该索引来选择正确的命令缓冲区。 提交命令缓冲区队列提交和同步是通过配置VkSubmitInfo结构中的参数完成的： 12345678VkSubmitInfo submitInfo = &#123;&#125;;submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;VkPipelineStageFlags waitStages[] = &#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;submitInfo.waitSemaphoreCount = 1;submitInfo.pWaitSemaphores = waitSemaphores;submitInfo.pWaitDstStageMask = waitStages; 前三个参数指定在执行开始之前等待的信号量以及要等待的管道位于的阶段。我们希望一直等待为图像写入颜色直到它可用，所以我们指定了写入颜色附件的图形管道的阶段。这意味着从理论上讲，现在的实现已经可以开始执行我们的顶点着色器了，而图像还不可用。waitStages数组对应的pWaitSemaphores中会具有相同索引的信号量。 12submitInfo.commandBufferCount = 1;submitInfo.pCommandBuffers = &amp;commandBuffers[imageIndex]; 接下来的两个参数指定实际提交来执行的命令缓冲区。和之前说的一样，我们提交到的命令缓冲区会将我们刚刚获取的交换链图像绑定为颜色附件。 123VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;submitInfo.signalSemaphoreCount = 1;submitInfo.pSignalSemaphores = signalSemaphores; signalSemaphoreCount和pSignalSemaphores参数指定在命令缓冲区完成执行后向哪些信号量发出信号。在我们的例子中，根据需要我们使用了renderFinishedSemaphore。 123if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, VK_NULL_HANDLE) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;);&#125; 我们现在可以使用vkQueueSubmit将命令缓冲区提交到图形队列。当工作负载大得多时，该函数将VkSubmitInfo结构数组作为参数来改善效率。最后一个参数是一个可选的fence，当命令缓冲区完成执行时，它将发出信号。我们只使用信号量进行同步，因此这里只传递一个VK_NULL_HANDLE。 子通道依赖项请记住，渲染过程中的子通道会自动处理图像布局的变化。这些转换由子通道依赖项（subpass dependencies）控制，子通道依赖项指定了子通道之间的内存和执行依赖关系。我们现在只有一个子通道，但是在此子通道之前和之后的操作也算作隐式的“子通道”。 有两个内置依赖项，用于处理渲染过程开始时和渲染过程结束时的转换，但前者发生的时间并不是刚好正确的。它假设转换发生是在管道的开始，但是那时我们还没有获得图像。有两种方法可以解决这个问题。可以将imageAvailableSemaphore的waitStages更改为VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT，确保在图像有效之前渲染过程不会开始，或者我们可以使渲染过程等待VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT阶段。我决定在这里使用第二个选项，因为它也是查看子通道的依赖关系以及它们如何工作的一个很好的方式。 子通道依赖项在VkSubpassDependency结构中指​​定。转到createRenderPass函数并添加如下结构： 123VkSubpassDependency dependency = &#123;&#125;;dependency.srcSubpass = VK_SUBPASS_EXTERNAL;dependency.dstSubpass = 0; 前两个字段指定了依赖关系和从属子通道的索引。VK_SUBPASS_EXTERNAL指的是渲染通道之前或之后的隐式子通道，具体取决于它是在srcSubpass还是dstSubpass中指定的。索引0指的是我们的子通道，它是第一个也是唯一一个。dstSubpass必须始终高于srcSubpass以防止依赖关系图中产生循环。 12dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;dependency.srcAccessMask = 0; 接下来的两个字段指定要等待的操作以及这些操作发生的阶段。在我们访问之前，我们需要等待交换链完成从图像中进行读取，这可以通过等待颜色附件输出的阶段来实现。 12dependency.dstStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;dependency.dstAccessMask = VK_ACCESS_COLOR_ATTACHMENT_READ_BIT | VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT; 应该等待的操作是在颜色附加阶段，这里涉及到了读取和写入颜色附件。这些设置将阻止转换的发生，直到我们实际需要（并允许），也就是我们想要开始为其写入颜色的时候。 12renderPassInfo.dependencyCount = 1;renderPassInfo.pDependencies = &amp;dependency; VkRenderPassCreateInfo结构有两个字段来指定依赖项数组。 显示绘制的最后一步是将结果提交回交换链，以使其最终显示在屏幕上。显示可以通过drawFrame函数末尾的VkPresentInfoKHR结构进行配置。 12345VkPresentInfoKHR presentInfo = &#123;&#125;;presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;presentInfo.waitSemaphoreCount = 1;presentInfo.pWaitSemaphores = signalSemaphores; 前两个参数指定在显示发生之前要等待的信号量，和VkSubmitInfo一样。 1234VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;presentInfo.swapchainCount = 1;presentInfo.pSwapchains = swapChains;presentInfo.pImageIndices = &amp;imageIndex; 接下来的两个参数指定用于呈现图像的交换链以及每个交换链的图像索引，大多数情况下只有一个。 1presentInfo.pResults = nullptr; // Optional 最后参数是可选的，叫做pResults。它允许您指定一个VkResult数组，以便在显示成功时检查每个单独的交换链。如果您只使用单个交换链，则没有必要设置，因为可以简单地使用当前函数的返回值就能知道了。 1vkQueuePresentKHR(presentQueue, &amp;presentInfo); vkQueuePresentKHR函数提交将图像呈现给交换链的请求。我们将在下一章中为vkAcquireNextImageKHR和vkQueuePresentKHR添加错误处理，因为他们的失败也并不一定意味着程序应该终止，这与我们迄今为止看到的功能不同。 如果到目前为止你已经正确地完成了所有操作，那么在运行程序时，您现在应该看到类似于以下的内容： 好极了！不幸的是，在启用验证图层后，可以看到程序会在关闭它时立即崩溃。从debugCallback打印到终端的消息可以看到原因： 请记住，drawFrame中的所有操作都是异步的。这意味着当我们退出mainLoop中的循环时，绘图和演示操作可能仍在继续，在这时候清理资源是并不是一个好的想法。 要解决这个问题，我们应该在退出mainLoop并销毁窗口之前等待逻辑设备完成操作： 12345678void mainLoop() &#123; while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); drawFrame(); &#125; vkDeviceWaitIdle(device);&#125; 您还可以等待特定命令队列中的操作以vkQueueWaitIdle结束。这些功能可以用作执行同步的非常基本的方法，现在关闭窗口时程序可以毫无问题地退出。 飞行帧（Frames in flight）如果运行启用了验证层的应用程序，则会监视应用程序的内存使用情况，您可能会注意到它正在缓慢增长。这样做的原因是应用程序正在drawFrame函数中快速提交工作，但却并没有检查它是否完成。如果CPU提交的工作速度超过了GPU可以跟上的速度，那么队列将慢慢被工作填满。更糟糕的是，我们还正在重复使用imageAvailableSemaphore和renderFinishedSemaphore同时进行多个帧的操作。 解决此问题的简单方法是在提交后等待工作完成，例如使用vkQueueWaitIdle： 1234567void drawFrame() &#123; ... vkQueuePresentKHR(presentQueue, &amp;presentInfo); vkQueueWaitIdle(presentQueue);&#125; 但是，这种方式并不能很好的使用GPU，这样做的话整个图形管道现在一次仅用于一帧。只有当前帧已经处理完毕而且是空闲的，才会用于下一帧。我们现在将扩展我们的应用程序，以允许多个帧在飞行同时仍然对堆积的工作量做出限制。 首先在程序顶部添加一个常量，该常量定义应同时处理多少帧： 1const int MAX_FRAMES_IN_FLIGHT = 2; 每个框架都应该有一组自己的信号量： 12std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores; 需要更改createSemaphores来创建以下的东西： 1234567891011121314void createSemaphores() &#123; imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT); renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT); VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS || vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create semaphores for a frame!&quot;); &#125;&#125; 同样，它们也应该全部清理掉： 12345678void cleanup() &#123; for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr); vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr); &#125; ...&#125; 要每次使用正确的信号量，我们需要跟踪当前帧。因此需要使用帧索引： 1size_t currentFrame = 0; 现在可以修改drawFrame函数来使用正确的对象： 12345678910111213void drawFrame() &#123; vkAcquireNextImageKHR(device, swapChain, std::numeric_limits&lt;uint64_t&gt;::max(), imageAvailableSemaphores[currentFrame], VK_NULL_HANDLE, &amp;imageIndex); ... VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphores[currentFrame]&#125;; ... VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphores[currentFrame]&#125;; ...&#125; 当然，也不要忘记每次都要进入下一帧： 12345void drawFrame() &#123; ... currentFrame = (currentFrame + 1) % MAX_FRAMES_IN_FLIGHT;&#125; 通过使用modulo（％）运算符，我们可以确保帧索引每隔MAX_FRAMES_IN_FLIGHT就会循环（和循环队列差不多）。 虽然我们没有设置所需的对象来同时处理多个帧，我们实际上还并没有能够阻止提交的数目超过MAX_FRAMES_IN_FLIGHT。目前只有GPU-GPU同步，还没有CPU-GPU同步来继续跟踪工作的进展情况，也就是说在帧＃0仍然在飞行状态时，我们也可能在使用他。 为了执行CPU-GPU同步，Vulkan提供了第二种类型的同步原语，称为栅栏（fences）。栅栏类似于信号量，因为它们可以发出信号并等待，但这次我们在我们自己的代码中来等待它们。首先为每个帧创建一个栅栏： 1234std::vector&lt;VkSemaphore&gt; imageAvailableSemaphores;std::vector&lt;VkSemaphore&gt; renderFinishedSemaphores;std::vector&lt;VkFence&gt; inFlightFences;size_t currentFrame = 0; 我们决定将栅栏和信号量在一起创建，将createSemaphores重命名为createSyncObjects： 1234567891011121314151617181920void createSyncObjects() &#123; imageAvailableSemaphores.resize(MAX_FRAMES_IN_FLIGHT); renderFinishedSemaphores.resize(MAX_FRAMES_IN_FLIGHT); inFlightFences.resize(MAX_FRAMES_IN_FLIGHT); VkSemaphoreCreateInfo semaphoreInfo = &#123;&#125;; semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; VkFenceCreateInfo fenceInfo = &#123;&#125;; fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; if (vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;imageAvailableSemaphores[i]) != VK_SUCCESS || vkCreateSemaphore(device, &amp;semaphoreInfo, nullptr, &amp;renderFinishedSemaphores[i]) != VK_SUCCESS || vkCreateFence(device, &amp;fenceInfo, nullptr, &amp;inFlightFences[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create synchronization objects for a frame!&quot;); &#125; &#125;&#125; 栅栏的创建（VkFence）与信号量的创建非常相似，当然最也还要确保清理干净： 123456789void cleanup() &#123; for (size_t i = 0; i &lt; MAX_FRAMES_IN_FLIGHT; i++) &#123; vkDestroySemaphore(device, renderFinishedSemaphores[i], nullptr); vkDestroySemaphore(device, imageAvailableSemaphores[i], nullptr); vkDestroyFence(device, inFlightFences[i], nullptr); &#125; ...&#125; 现在来修改drawFrame以使用fences进行同步。调用vkQueueSubmit包含了一个可选参数，用于传递在命令缓冲区完成执行时应发出信号的栅栏。我们可以使用它来表示帧已经完成： 12345678void drawFrame() &#123; ... if (vkQueueSubmit(graphicsQueue, 1, &amp;submitInfo, inFlightFences[currentFrame]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to submit draw command buffer!&quot;); &#125; ...&#125; 现在唯一剩下的就是修改drawFrame的开头用来等待帧完成： 123456void drawFrame() &#123; vkWaitForFences(device, 1, &amp;inFlightFences[currentFrame], VK_TRUE, std::numeric_limits&lt;uint64_t&gt;::max()); vkResetFences(device, 1, &amp;inFlightFences[currentFrame]); ...&#125; vkWaitForFences函数用一系列栅栏作为参数，并在返回之前等待其中的任何一个或全部发出信号。VK_TRUE表示我们要等待所有栅栏，但是在我们就只有一个，所以在我们的例子中它显然无关紧要。就像vkAcquireNextImageKHR一样，这个函数也有一个时间限制参数。与信号量不同的是，我们需要手动调用vkResetFences来重置栅栏使他恢复到没有信号的状态。 如果你现在运行程序，你会发现一些奇怪的东西。应用程序似乎不再渲染任何东西。启用验证层后，您将看到以下错误信息： 这意味着我们正在等待尚未提交的栅栏。这里的问题是，默认情况下，栅栏是在没有信号状态下创建的，所以由于我们之前没有使用过栅栏，vkWaitForFences会永远等待。为了解决这个问题，我们可以更改栅栏的创建以在信号状态下初始化它，就好像我们已经渲染了一个完成的初始帧一样： 123456789void createSyncObjects() &#123; ... VkFenceCreateInfo fenceInfo = &#123;&#125;; fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT; ...&#125; 现在程序可以正常工作没有内存泄漏了。我们现在已经实现了所有需要的同步，以确保排队的工作帧不超过两帧。请注意，对于代码的其他部分（例如最终的清理）来说，如果能够依赖于更粗略的同步（如vkDeviceWaitIdle）会更好。您可以根据性能的要求决定使用哪种方法。 要通过示例了解有关同步的更多信息，请查看Khronos的相关概述。 总结写了差不多900行代码后，终于进入了在屏幕上弹出一些东西的阶段。引导Vulkan程序肯定是需要做很多工作的，但好处是通过这些明细的操作步骤，Vulkan为您提供了巨大的控制权。我建议你现在花点时间重新阅读代码并在心中构建模型，了解程序中所有Vulkan对象的用途以及它们之间的关系。我们将在这些知识的基础上进一步扩展该程序的功能。 在下一章中，我们将讨论一个好的Vulkan程序所需的一个小东西。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(15)-画个三角形(绘制)-命令缓冲区","slug":"学习一个vulkan-15-画个三角形-绘制-命令缓冲区","date":"2018-11-14T01:26:01.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/14/学习一个vulkan-15-画个三角形-绘制-命令缓冲区/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/14/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-15-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E7%BB%98%E5%88%B6-%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA/","excerpt":"继续上一次的","text":"继续上一次的 Vulkan中的命令（如绘图操作和内存传输）并不会直接调用函数来执行，您必须在命令缓冲区对象中记录下要执行的所有操作。这样做的好处是，所有设置绘图命令的工作都可以提前并在多个线程中完成，之后，只需要告诉Vulkan在主循环中执行命令就行了。 命令池在创建命令缓冲区之前，我们必须创建一个命令池。命令池管理用于存储缓冲区的内存，并从中分配命令缓冲区，添加一个新的类成员来存储VkCommandPool对象： 1VkCommandPool commandPool; 然后创建一个新函数createCommandPool，并在initVulkan中创建framebuffers的函数的后面进行调用： 12345678910111213141516171819void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool();&#125;...void createCommandPool() &#123;&#125; 创建命令池只需要两个参数： 123456QueueFamilyIndices queueFamilyIndices = findQueueFamilies(physicalDevice);VkCommandPoolCreateInfo poolInfo = &#123;&#125;;poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;poolInfo.queueFamilyIndex = queueFamilyIndices.graphicsFamily.value();poolInfo.flags = 0; // Optional 命令缓冲区需要通过在其中一个设备队列上提交他们来执行，就像我们之前检索的图形和表示队列一样。每个命令池只能分配给提交到同一类型队列的命令缓冲区。我们将记录绘图命令，所以这里需要选择图形队列簇。 命令池有两种标志： VK_COMMAND_POOL_CREATE_TRANSIENT_BIT：提示命令缓冲区非常频繁的重新记录新命令(可能会改变内存分配行为) VK_COMMAND_POOL_CREATE_TRANSIENT_BIT：允许命令缓冲区单独重新记录，没有这个标志的话，所有的命令缓冲区都必须一起重置 我们只会在程序的开头记录命令缓冲区，然后在主循环中执行多次，所以这两个标志我们都不会使用。 123if (vkCreateCommandPool(device, &amp;poolInfo, nullptr, &amp;commandPool) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create command pool!&quot;);&#125; 使用vkCreateCommandPool函数完成命令池的创建，它没有任何特殊参数。使用命令在屏幕上绘制内容将会在整个程序运行期都存在，所有需要在最后进行销毁： 12345void cleanup() &#123; vkDestroyCommandPool(device, commandPool, nullptr); ...&#125; 命令缓冲区分配我们现在可以开始分配命令缓冲区并在其中记录绘图命令了。因为有一个绘图命令涉及到需要绑定正确的VkFramebuffer，所以现在必须再次为交换链中的每个图像记录一个命令缓冲区。因此这里创建一个VkCommandBuffer对象列表作为类成员。命令缓冲区将在其命令池被销毁时自动释放，因此不需要显式清理。 1std::vector&lt;VkCommandBuffer&gt; commandBuffers; 添加一个createCommandBuffers函数，该函数为每个交换链图像分配和记录命令。 1234567891011121314151617181920void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers(); createCommandPool(); createCommandBuffers();&#125;...void createCommandBuffers() &#123; commandBuffers.resize(swapChainFramebuffers.size());&#125; 使用vkAllocateCommandBuffers函数来分配命令缓冲区，它将VkCommandBufferAllocateInfo结构作为参数来指定命令池和要分配的缓冲区数目： 123456789VkCommandBufferAllocateInfo allocInfo = &#123;&#125;;allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;allocInfo.commandPool = commandPool;allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;allocInfo.commandBufferCount = (uint32_t) commandBuffers.size();if (vkAllocateCommandBuffers(device, &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to allocate command buffers!&quot;);&#125; level参数指定分配的命令缓冲区是主命令缓冲区还是辅助命令缓冲区。 VK_COMMAND_BUFFER_LEVEL_PRIMARY：可以提交到队列执行，但不能从其他命令缓冲区调用。 VK_COMMAND_BUFFER_LEVEL_SECONDARY：无法直接提交，但可以从主命令缓冲区调用。 我们不会在这里使用辅助命令缓冲区功能，但可以预见到从主命令缓冲区重用一些常见操作是很有帮助的。 开始命令缓冲区的记录我们通过调用vkBeginCommandBuffer并使用VkCommandBufferBeginInfo结构作为参数来开始记录命令缓冲区，该参数指定了有关此特定命令缓冲区用法的一些详细信息。 12345678910for (size_t i = 0; i &lt; commandBuffers.size(); i++) &#123; VkCommandBufferBeginInfo beginInfo = &#123;&#125;; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; beginInfo.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT; beginInfo.pInheritanceInfo = nullptr; // Optional if (vkBeginCommandBuffer(commandBuffers[i], &amp;beginInfo) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to begin recording command buffer!&quot;); &#125;&#125; flags参数指定我们将如何使用命令缓冲区。可以使用以下值： VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT：执行一次后，将立即重新记录命令缓冲区。 VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT：这是一个辅助命令缓冲区，仅仅用于单个渲染过程中。 VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT：在命令缓冲区已挂起的时候可以重新提交。 我们使用了最后一个标志，因为我们可能已经为下一帧安排了绘图命令，而上一帧还没有完成。pInheritanceInfo参数仅与辅助命令缓冲区相关，它指定从调用主命令缓冲区继承的状态。 如果命令缓冲区已经记录一次，那么对vkBeginCommandBuffer的调用将隐式重置它，直接将命令附加到缓冲区中是不可能的。 开始渲染过程绘制开始于调用vkCmdBeginRenderPass开启渲染通道，使用VkRenderPassBeginInfo结构中的一些参数配置渲染过程： 1234VkRenderPassBeginInfo renderPassInfo = &#123;&#125;;renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;renderPassInfo.renderPass = renderPass;renderPassInfo.framebuffer = swapChainFramebuffers[i]; 第一个参数是渲染过程本身和要绑定的附件。我们为每个交换链图像创建了一个帧缓冲区，将其指定为颜色附件。 12renderPassInfo.renderArea.offset = &#123;0, 0&#125;;renderPassInfo.renderArea.extent = swapChainExtent; 接下来的两个参数定义渲染区域的大小，渲染区域定义了着色器加载和存储的位置。 123VkClearValue clearColor = &#123;0.0f, 0.0f, 0.0f, 1.0f&#125;;renderPassInfo.clearValueCount = 1;renderPassInfo.pClearValues = &amp;clearColor; 最后两个参数定义了用于VK_ATTACHMENT_LOAD_OP_CLEAR的清除值，我们将其用作颜色附件的加载操作。这里将清除颜色定义为仅具有100％不透明度的黑色。 1vkCmdBeginRenderPass(commandBuffers[i], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE); 渲染过程终于可以开始了。记录命令的所有相关功能都可以通过其特有的vkCmd前缀来识别。它们都返回void，因此在我们完成记录之前不会有任何错误处理。 每个命令的第一个参数始终是用于记录命令的命令缓冲区，第二个参数指定我们刚刚提供的渲染过程的详细信息，最后一个参数控制如何提供渲染过程中的绘图命令。它可以是以下两个值其中之一： VK_SUBPASS_CONTENTS_INLINE：渲染过程命令将会嵌入在主命令​​缓冲区本身中，并且不会执行辅助命令缓冲区。 VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS：渲染过程命令将从辅助命令缓冲区执行。 我们没有使用辅助命令缓冲区，因此我们将使用第一个选项。 基本绘图命令我们现在可以绑定图形管道了： 1vkCmdBindPipeline(commandBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline); 第二个参数指定管道对象是图形管道还是计算管道。我们现在告诉Vulkan哪些操作要在图形管道中执行，哪些附件要在片段着色器中使用，所以剩下的就是告诉它我们要绘制三角形了： 1vkCmdDraw(commandBuffers[i], 3, 1, 0, 0); 由于之前我们已经详细的指定了相关信息，现在vkCmdDraw的调用就显得很简单了。除命令缓冲区外，它还具有以下参数： vertexCount：即使我们没有顶点缓冲区，这里仍然有3个顶点需要绘制。 instanceCount：用于实例化渲染，如果不需要的话使用1。 firstVertex：用作顶点缓冲区的偏移量，gl_VertexIndex定义为其最低值。 firstInstance：用作实例渲染的偏移量，gl_InstanceIndex定义为其最低值。 结束渲染过程现在可以结束了： 1vkCmdEndRenderPass(commandBuffers[i]); 现在我们已经完成了命令缓冲区的录制： 123if (vkEndCommandBuffer(commandBuffers[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to record command buffer!&quot;);&#125; 在下一章中，我们将编写主循环的代码，它将从交换链中获取图像，执行正确的命令缓冲区并将完成的图像返回到交换链。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(14)-画个三角形(绘制)-帧缓冲区","slug":"学习一个vulkan-14-画个三角形-绘制-帧缓冲区","date":"2018-11-13T01:14:50.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/13/学习一个vulkan-14-画个三角形-绘制-帧缓冲区/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/13/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-14-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E7%BB%98%E5%88%B6-%E5%B8%A7%E7%BC%93%E5%86%B2%E5%8C%BA/","excerpt":"继续上一次的","text":"继续上一次的 帧缓冲区在过去的几章中我们已经讨论了很多关于帧缓冲的内容，并且我们已经设置了渲染过程并希望输出一个与交换链图像格式一致的帧缓冲区，但是我们还没有实际创建任何帧缓冲器。 在创建渲染过程的期间指定的附件可以通过将它们包装到VkFramebuffer对象中进行绑定。帧缓冲区（framebuffer）对象引用表示为附件的所有的VkImageView对象。在我们的例子中，只有一个颜色附件。但是，我们用于附件的图像取决于交换链在我们检索用于显示时返回的图像。这意味着我们必须为交换链中的所有图像创建一个帧缓冲区，并在绘制时使用与检索到的图像对应的图像缓冲区。 为此，创建另一个std :: vector类成员来保存帧缓冲区： 1std::vector&lt;VkFramebuffer&gt; swapChainFramebuffers; 我们将在initVulkan里创建图形管道之后调用新函数createFramebuffers来为此数组创建对象： 123456789101112131415161718void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline(); createFramebuffers();&#125;...void createFramebuffers() &#123;&#125; 首先调整容器大小来容纳所有帧缓冲区： 123void createFramebuffers() &#123; swapChainFramebuffers.resize(swapChainImageViews.size());&#125; 然后我们将遍历图像视图并从中创建帧缓冲区： 123456789101112131415161718for (size_t i = 0; i &lt; swapChainImageViews.size(); i++) &#123; VkImageView attachments[] = &#123; swapChainImageViews[i] &#125;; VkFramebufferCreateInfo framebufferInfo = &#123;&#125;; framebufferInfo.sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; framebufferInfo.renderPass = renderPass; framebufferInfo.attachmentCount = 1; framebufferInfo.pAttachments = attachments; framebufferInfo.width = swapChainExtent.width; framebufferInfo.height = swapChainExtent.height; framebufferInfo.layers = 1; if (vkCreateFramebuffer(device, &amp;framebufferInfo, nullptr, &amp;swapChainFramebuffers[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create framebuffer!&quot;); &#125;&#125; 可以看到，帧缓冲区的创建非常简单。我们首先需要指定帧缓冲区需要与哪个renderPass兼容。您只能将帧缓冲与其兼容的渲染过程一起使用，这也大致意味着它们会使用相同数量和类型的附件。 attachmentCount和pAttachments参数指定了VkImageView对象绑定到的渲染过程中pAttachment数组的相关说明。 width和height参数显而易见，layers指的是图像数组中的图层数，我们的交换链图像是单个图像，因此层数为1。 我们在图像视图和渲染通道渲染完毕之后，删除对应的帧缓冲区: 1234567void cleanup() &#123; for (auto framebuffer : swapChainFramebuffers) &#123; vkDestroyFramebuffer(device, framebuffer, nullptr); &#125; ...&#125; 我们现在已经达到了里程碑，我们现在有了拥有渲染所需的所有对象。在下一章中，我们将编写第一个实际的绘图命令。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(13)-画个三角形(图形管道)-总结","slug":"学习一个vulkan-13-画个三角形-图形管道-总结","date":"2018-11-12T01:18:29.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/12/学习一个vulkan-13-画个三角形-图形管道-总结/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/12/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-13-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93-%E6%80%BB%E7%BB%93/","excerpt":"继续上一次的","text":"继续上一次的 总结现在就是把之前几章创建的所有结构和对象结合起来建立图形管道了。先简单回顾一下： 着色器阶段（Shader stages）：着色器模块定义了图形管道的可编程阶段的功能 固定功能阶段（Fixed-function state）：所有定义了管道固定功能阶段的结构，如输入组件，光栅化器，视口和颜色混合 管道布局（Pipeline layout）：着色器引用的统一值和推送值（the uniform and push values），可以在绘制时更新 渲染过程（Render pass）：管道阶段引用的附件及其相关用法 以上这些一同定义了完整的图形管道的功能，因此我们现在可以在createGraphicsPipeline函数的vkDestroyShaderModule之前进行填充，因为这些东西仍然在创建过程中需要使用的： 1234VkGraphicsPipelineCreateInfo pipelineInfo = &#123;&#125;;pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;pipelineInfo.stageCount = 2;pipelineInfo.pStages = shaderStages; 我们首先引用VkPipelineShaderStageCreateInfo结构数组。 12345678pipelineInfo.pVertexInputState = &amp;vertexInputInfo;pipelineInfo.pInputAssemblyState = &amp;inputAssembly;pipelineInfo.pViewportState = &amp;viewportState;pipelineInfo.pRasterizationState = &amp;rasterizer;pipelineInfo.pMultisampleState = &amp;multisampling;pipelineInfo.pDepthStencilState = nullptr; // OptionalpipelineInfo.pColorBlendState = &amp;colorBlending;pipelineInfo.pDynamicState = nullptr; // Optional 然后我们引用用来描述固定功能阶段的所有结构。 1pipelineInfo.layout = pipelineLayout; 之后是管道布局，它是一个Vulkan句柄而不是结构指针。 12pipelineInfo.renderPass = renderPass;pipelineInfo.subpass = 0; 最后，我们引用了渲染过程以及将使用此图形管道的子过程的索引。除开这个特定的实例之外也可以使用这个管道的其他渲染过程，但是它们必须与renderPass兼容。这里描述了兼容性要求，但我们不会在本教程中用到这个特性。 12pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; // OptionalpipelineInfo.basePipelineIndex = -1; // Optional 实际上还有两个参数：basePipelineHandle和basePipelineIndex。Vulkan允许通过从现有管道派生来创建新的图形管道，派生管道的想法在于，当它们具有与现有管道相同的许多功能时，设置管道的成本更低，而且同一父管道的多个子管道切换速度会更快。您可以使用basePipelineHandle来指定现有管道的句柄，也可以引用通过basePipelineIndex的索引创建的另外的管道。现在只有一个管道，所以我们只需指定一个空句柄和一个无效的索引。只有在VkGraphicsPipelineCreateInfo的flags字段中指定了VK_PIPELINE_CREATE_DERIVATIVE_BIT标志时，才需要使用这些值。 现在准备最后一步，创建一个类成员保存VkPipeline对象: 1VkPipeline graphicsPipeline; 最后创建图形管道： 123if (vkCreateGraphicsPipelines(device, VK_NULL_HANDLE, 1, &amp;pipelineInfo, nullptr, &amp;graphicsPipeline) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create graphics pipeline!&quot;);&#125; vkCreateGraphicsPipelines函数比Vulkan中通常的对象创建函数多几个参数，这旨在获取多个VkGraphicsPipelineCreateInfo对象，并在一次调用中创建多个VkPipeline对象。 我们引用VK_NULL_HANDLE的第二个参数，作为可选的VkPipelineCache对象的引用。管道缓存可用于存储和重用与多个vkCreateGraphicsPipelines调用相关的管道创建相关数据，如果这些缓存存储在文件中的话，甚至可以用来跨程序使用，这使得可以在以后显着加速管道创建的过程。我们将在之后的管道缓存章节中来讨论这个问题。 所有常见的绘图操作都需要图形管道，因此它也在程序结束时才进行销毁： 12345void cleanup() &#123; vkDestroyPipeline(device, graphicsPipeline, nullptr); vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ...&#125; 现在运行您的程序以确认所作的这些工作可以成功创建管道。现在距离在屏幕上看到某些东西只有一步之遥了。在接下来的几章中，我们将从交换链图像中设置实际的帧缓冲区并准备绘图命令。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(12)-画个三角形(图形管道)-渲染过程","slug":"学习一个vulkan-12-画个三角形-图形管道-渲染过程","date":"2018-11-10T01:30:19.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/10/学习一个vulkan-12-画个三角形-图形管道-渲染过程/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/10/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-12-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/","excerpt":"继续上一次的","text":"继续上一次的 构建在我们完成管道创建之前，我们需要告诉Vulkan渲染时将使用的帧缓冲附件。我们需要指定将有多少颜色和深度缓冲区，每个缓冲区要使用多少个样本以及在整个渲染操作中如何处理它们的内容。所有的这些信息都包含在一个渲染过程（render pass）对象中，我们将为此创建一个createRenderPass函数。在initVulkan中的createGraphicsPipeline的前面调用： 1234567891011121314151617void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createRenderPass(); createGraphicsPipeline();&#125;...void createRenderPass() &#123;&#125; 附件描述在我们的例子中只有一个颜色缓冲附件，由交换链中的一个图像表示： 12345void createRenderPass() &#123; VkAttachmentDescription colorAttachment = &#123;&#125;; colorAttachment.format = swapChainImageFormat; colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;&#125; 颜色附件的format参数应该与交换链图像的格式相匹配，而且我们还没有做任何多重采样方面的事情，所以我们这里使用1个样本。 12colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE; loadOp和storeOp设置在渲染之前和渲染之后如何处理附件中的数据。对loadOp有如下几个选择： VK_ATTACHMENT_LOAD_OP_LOAD：保留附件的现有内容 VK_ATTACHMENT_LOAD_OP_CLEAR：在开始时以一个常量清理附件内容 VK_ATTACHMENT_LOAD_OP_DONT_CARE：现有内容未定义，忽略它们 在我们的例子中，我们将使用clear操作在绘制新帧之前将帧缓冲区清除为黑色。storeOp只有两种选择： VK_ATTACHMENT_STORE_OP_STORE：渲染内容将存储在内存中，方便之后读取 VK_ATTACHMENT_STORE_OP_DONT_CARE：渲染操作后，帧缓冲区的内容变为undefined 我们希望在屏幕上看到渲染后的三角形，所以我们在这里进行store操作。 12colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE; loadOp和storeOp适用于颜色和深度数据，stencilLoadOp&#x2F;stencilStoreOp适用于模板数据。我们的应用程序不会对模板缓冲区执行任何操作，因此相应的加载和存储结果都无关紧要。 12colorAttachment.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;colorAttachment.finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR; Vulkan中的纹理和帧缓冲区由具有特定像素格式的VkImage对象表示，但是内存中像素的布局会根据您对图像执行的操作而改变。 一些常用的布局: VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL：图像用作颜色附件 VK_IMAGE_LAYOUT_PRESENT_SRC_KHR：图像在交换链中呈现 VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL：图像作为目标，用于内存复制操作 我们将在纹理章节中更深入地讨论这个主题，现在最重要的是为需要转变的图像指定合适的布局进行操作。 initialLayout指定了渲染通道开始之前图像将具有的布局，finalLayout指定在渲染过程完成时自动转换到的布局。对initialLayout使用VK_IMAGE_LAYOUT_UNDEFINED意味着我们不关心图像之前的布局。这个特殊的值是说图像的内容不能保证会被保留，但这并不重要，因为我们都要清除它的。我们希望在图像渲染完毕后使用交换链呈现，所以finalLayout设置为VK_IMAGE_LAYOUT_PRESENT_SRC_KHR。 子通道和附件参考单个渲染过程可以包含多个子过程。子通道是一系列的渲染操作，其取决于先前传递中的帧缓冲器的内容，比如说后处理效果的序列通常每一步都依赖之前的操作。如果将这些渲染操作分组到一个渲染通道中，那么Vulkan能够重新排序操作并节省内存带宽，从而获得更好的性能。然而，对于我们的三角形，我们将使用单个子通道就够了。 每个子通道都引用了我们前面的结构中描述的一个或多个附件。这些引用本身就是VkAttachmentReference结构，如下所示： 123VkAttachmentReference colorAttachmentRef = &#123;&#125;;colorAttachmentRef.attachment = 0;colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL; attachment参数通过附件描述数组中的索引来指定引用哪个附件。我们的数组由单个的VkAttachmentDescription组成，因此其索引为0。layout参数指定在使用此引用的子通道期间我们希望附件具有哪种布局，在启动子通道时，Vulkan会自动将附件转换为此布局。我们打算将附件用作颜色缓冲区，这里VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL布局将为我们提供最好的性能。 子通道需要使用VkSubpassDescription结构来描述： 12VkSubpassDescription subpass = &#123;&#125;;subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS; Vulkan也可能在未来支持计算子通道，因此我们必须明确将其指定为图形子通道。接下来，我们指定对颜色附件的引用： 12subpass.colorAttachmentCount = 1;subpass.pColorAttachments = &amp;colorAttachmentRef; 附件在数组中的索引直接从片段着色器引用，也就是layout(location &#x3D; 0) out vec4 outColor这个指令了。 子通道还可以引用以下其他类型的附件： pInputAttachments：从着色器读取附件 pResolveAttachments：用于多重采样颜色附件的附件 pDepthStencilAttachment：用于深度和模板数据的附件 pPreserveAttachments：此子通道未使用但必须保留数据的附件 渲染过程现在已经描述了附件和引用它的基本子通道，我们可以创建渲染通道了。创建一个新的类成员变量，将VkRenderPass对象保存在pipelineLayout变量的正上方： 12VkRenderPass renderPass;VkPipelineLayout pipelineLayout; 然后可以通过使用附件和子通道数组填充VkRenderPassCreateInfo结构来创建渲染过程对象，VkAttachmentReference对象也是通过使用这个数组的索引来引用附件的。 12345678910VkRenderPassCreateInfo renderPassInfo = &#123;&#125;;renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;renderPassInfo.attachmentCount = 1;renderPassInfo.pAttachments = &amp;colorAttachment;renderPassInfo.subpassCount = 1;renderPassInfo.pSubpasses = &amp;subpass;if (vkCreateRenderPass(device, &amp;renderPassInfo, nullptr, &amp;renderPass) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create render pass!&quot;);&#125; 就像管道布局一样，渲染过程将在整个程序中被引用，因此它也在最后清理： 12345void cleanup() &#123; vkDestroyPipelineLayout(device, pipelineLayout, nullptr); vkDestroyRenderPass(device, renderPass, nullptr); ...&#125; 现在已经做了很多工作了，在下一章里，他们将会一起构成最终的图形管道对象。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(11)-画个三角形(图形管道)-固定功能","slug":"学习一个vulkan-11-画个三角形-图形管道-固定功能","date":"2018-11-09T01:22:18.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/09/学习一个vulkan-11-画个三角形-图形管道-固定功能/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/09/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-11-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93-%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD/","excerpt":"继续上一次的","text":"继续上一次的 较旧的图形API都会为图形管道的大多数阶段提供一个默认状态。在Vulkan中，您必须明确指定所有内容，从视口大小到颜色混合功能都需要。在本章中，我们将填写配置这些固定功能操作的所有结构。 输入顶点VkPipelineVertexInputStateCreateInfo结构描述了用于传递给顶点着色器的顶点数据的格式。一般会从下面两个方面来说明： Bindings：数据之间的间距以及数据是顶点还是实例（请参阅instancing）。 Attribute descriptions：描述将要进行绑定及加载属性的顶点着色器中的相关属性类型。 因为我们在顶点着色器中是直接对顶点数据进行硬编码的，所以我们在填充此结构的时候需要指定现在没有要加载的顶点数据，我们之后将在顶点缓冲区章节中回来修改： 123456VkPipelineVertexInputStateCreateInfo vertexInputInfo = &#123;&#125;;vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;vertexInputInfo.vertexBindingDescriptionCount = 0;vertexInputInfo.pVertexBindingDescriptions = nullptr; // OptionalvertexInputInfo.vertexAttributeDescriptionCount = 0;vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional pVertexBindingDescriptions和pVertexAttributeDescriptions成员指向一个结构数组，用于描述上述加载顶点数据的细节。将这个结构添加到createGraphicsPipeline函数中shaderStages数组后面。 输入组件VkPipelineInputAssemblyStateCreateInfo结构描述了两件事：将从顶点绘制什么样的几何体以及是否开启图元重构（primitive restart）。前者在topology成员中指定，可以具有如下值： VK_PRIMITIVE_TOPOLOGY_POINT_LIST：顶点到点 VK_PRIMITIVE_TOPOLOGY_LINE_LIST：两点成线，顶点不重复使用 VK_PRIMITIVE_TOPOLOGY_LINE_STRIP：每条线的结束顶点用作下一行的起始顶点 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST：三个点成为一个三角形，顶点不重复使用 VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP：每个三角形的第二个和第三个顶点用作下一个三角形的前两个顶点 通常，顶点会按顺序索引从顶点缓冲区加载，但是使用元素缓冲区（element buffer）也可以指定要自定义的索引，这允许您执行重用顶点等优化方式。如果将primitiveRestartEnable成员设置为VK_TRUE，则可以通过使用特殊索引0xFFFF或0xFFFFFFFF来分解_STRIP拓扑模式中的线和三角形。 我们打算在本教程中绘制三角形，因此将使用下面的结构数据： 1234VkPipelineInputAssemblyStateCreateInfo inputAssembly = &#123;&#125;;inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;inputAssembly.primitiveRestartEnable = VK_FALSE; 视口和裁剪视口简单描述了将用于渲染输出的的帧缓冲区域。基本上都是(0, 0)到(width, height)，在本教程中也是如此： 1234567VkViewport viewport = &#123;&#125;;viewport.x = 0.0f;viewport.y = 0.0f;viewport.width = (float) swapChainExtent.width;viewport.height = (float) swapChainExtent.height;viewport.minDepth = 0.0f;viewport.maxDepth = 1.0f; 请记住，交换链及其图像的大小可能与窗口的WIDTH和HEIGHT不同。交换链图像将在以后用作帧缓冲区，因此我们应该坚持它们的大小不变。 minDepth和maxDepth值指定用于帧缓冲区的深度值的范围。这些值必须在[0.0f，1.0f]范围内，minDepth也是可能高于maxDepth的。如果没有特殊需求的话，使用标准的0.0f和1.0f就行了。 视口定义了从图像到帧缓冲的转换方式，裁剪矩形定义了实际存储像素的区域。裁剪矩形外的任何像素都将在光栅化阶段丢弃。在功能上它们更加类似于过滤而不是转换。差异如下图所示。请注意，对于图像比视口尺寸大的情况下，左侧的裁剪矩形只是众多可能方式其中一个表现。在本教程中，我们只想绘制整个帧缓冲区，因此我们将指定一个完全覆盖它的剪刀矩形： 123VkRect2D scissor = &#123;&#125;;scissor.offset = &#123;0, 0&#125;;scissor.extent = swapChainExtent; 现在，需要使用VkPipelineViewportStateCreateInfo结构将此视口和裁剪矩形组合到一起。由于某些显卡上支持使用多个视口和裁剪矩形，因此这里的成员是引用它们的数组的，要使用这个特性（多个视口和裁剪矩阵同时组合）需要启用相应的GPU功能（请参阅创建逻辑设备章节）： 123456VkPipelineViewportStateCreateInfo viewportState = &#123;&#125;;viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;viewportState.viewportCount = 1;viewportState.pViewports = &amp;viewport;viewportState.scissorCount = 1;viewportState.pScissors = &amp;scissor; 光栅化光栅化器使用由顶点着色器的顶点组成的几何体，并将其转换为片段着色器着色的片段。它还可以执行深度测试，面部剔除和裁剪测试，并且为输出来选择配置是填充整个多边形还是仅仅填充边缘的片段（线框渲染）。所有的这些都是使用VkPipelineRasterizationStateCreateInfo结构来配置的。 123VkPipelineRasterizationStateCreateInfo rasterizer = &#123;&#125;;rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;rasterizer.depthClampEnable = VK_FALSE; 如果depthClampEnable设置为VK_TRUE，那么超出近平面和远平面的片段将会收敛它们来使用而不是丢弃。这在阴影贴图等特殊情况下很有用，使用此功能需要开启相应的GPU功能。 1rasterizer.rasterizerDiscardEnable = VK_FALSE; 如果rasterizerDiscardEnable设置为VK_TRUE，则几何体永远不会通过光栅化器阶段。这基本上禁用了帧缓冲的所有输出。 1rasterizer.polygonMode = VK_POLYGON_MODE_FILL; polygonMode设置如何为几何生成片段。有以下几个选项可供选择： VK_POLYGON_MODE_FILL：用片段填充多边形的区域 VK_POLYGON_MODE_LINE：多边形边缘绘制为线条 VK_POLYGON_MODE_POINT：多边形顶点绘制为点 使用除填充之外的任何模式都需要启用相应的GPU功能。 1rasterizer.lineWidth = 1.0f; lineWidth成员很简单，它根据片段数目描述线的粗细。支持的最大线宽取决于硬件，任何厚度大于1.0f的线都要求启用wideLines的GPU功能。 12rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE; cullMode变量确定要使用的面部剔除的类型，可以选择禁用剔除，剔除正面，剔除背面或都剔除。frontFace变量指定面向前面的面的顶点顺序，可以是顺时针或逆时针。 1234rasterizer.depthBiasEnable = VK_FALSE;rasterizer.depthBiasConstantFactor = 0.0f; // Optionalrasterizer.depthBiasClamp = 0.0f; // Optionalrasterizer.depthBiasSlopeFactor = 0.0f; // Optional 光栅化器可以通过添加常量值或根据片段的斜率更改偏置来更改深度值。这个方法有时用于阴影贴图，但我们在这里不会使用，只需将depthBiasEnable设置为VK_FALSE即可。 多重采样VkPipelineMultisampleStateCreateInfo结构用来配置多重采样，这是消除锯齿的方法之一。它会将光栅化后位于同一像素的点经过片段着色器进行处理后得到的结果来进行组合。这主要发生在边缘，这也是最明显的锯齿出现的地方。如果只有一个多边形映射到一个像素，是不需要多次运行片段着色器，它比简单地渲染到更高的分辨率然后再缩小尺寸开销要低得多。开启这个功能也需要开启相应的gpu功能： 12345678VkPipelineMultisampleStateCreateInfo multisampling = &#123;&#125;;multisampling.sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;multisampling.sampleShadingEnable = VK_FALSE;multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;multisampling.minSampleShading = 1.0f; // Optionalmultisampling.pSampleMask = nullptr; // Optionalmultisampling.alphaToCoverageEnable = VK_FALSE; // Optionalmultisampling.alphaToOneEnable = VK_FALSE; // Optional 我们将在后面的章节中重新进行多重采样，现在先禁用它。 深度测试和模板测试如果使用深度或模板缓冲区，则还需要使用VkPipelineDepthStencilStateCreateInfo来配置深度和模板测试。我们现在没有用到，所以我们简单地传递一个nullptr而不是指向这样一个结构的指针。之后将在深度缓冲章节回来进行配置。 颜色混合片段着色器返回颜色后，需要将其与帧缓冲区中已有的颜色组合。这种转换称为颜色混合（混色），有两种方式： 混合旧值和新值以生成新的颜色 使用位运算来组合旧值和新值 有两种类型的结构来配置颜色混合。第一个结构，VkPipelineColorBlendAttachmentState包含了每个附加帧缓冲区的配置。第二个结构，VkPipelineColorBlendStateCreateInfo包含全局的颜色混合设置。在我们的例子中，我们只有一个帧缓冲区： 123456789VkPipelineColorBlendAttachmentState colorBlendAttachment = &#123;&#125;;colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT;colorBlendAttachment.blendEnable = VK_FALSE;colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; // OptionalcolorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; // OptionalcolorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; // OptionalcolorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; // OptionalcolorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; // OptionalcolorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; // Optional 这个per-framebuffer结构允许你配置首选的颜色混合方式。使用以下伪代码可以最好地演示将要执行的操作： 12345678if (blendEnable) &#123; finalColor.rgb = (srcColorBlendFactor * newColor.rgb) &lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb); finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt; (dstAlphaBlendFactor * oldColor.a);&#125; else &#123; finalColor = newColor;&#125;finalColor = finalColor &amp; colorWriteMask; 如果将blendEnable设置为VK_FALSE，则片段着色器中的新颜色直接使用原始的颜色不做任何改变，否则将会执行两个混合操作来计算新颜色。生成的颜色与colorWriteMask进行AND运算，来决定实际传递的通道。 颜色混合的最常用方法是alpha混合，新颜色会根据其不透明度与旧颜色混合。finalColor会按如下方式计算： 12finalColor.rgb = newAlpha * newColor + (1 - newAlpha) * oldColor;finalColor.a = newAlpha.a; 这也可以通过以下参数来完成： 1234567colorBlendAttachment.blendEnable = VK_TRUE;colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA;colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA;colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD;colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE;colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO;colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; 可以查询文档中的VkBlendFactor和VkBlendOp枚举值中找到所有可能的操作。 第二个结构引用所有帧缓冲区的结构数组，并允许您设置混合常量，您可以看成在上述计算中所用的混合因子。 12345678910VkPipelineColorBlendStateCreateInfo colorBlending = &#123;&#125;;colorBlending.sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO;colorBlending.logicOpEnable = VK_FALSE;colorBlending.logicOp = VK_LOGIC_OP_COPY; // OptionalcolorBlending.attachmentCount = 1;colorBlending.pAttachments = &amp;colorBlendAttachment;colorBlending.blendConstants[0] = 0.0f; // OptionalcolorBlending.blendConstants[1] = 0.0f; // OptionalcolorBlending.blendConstants[2] = 0.0f; // OptionalcolorBlending.blendConstants[3] = 0.0f; // Optional 如果要使用第二种混合方法（按位组合），则应将logicOpEnable设置为VK_TRUE，然后可以在logicOp字段中指定按位操作的方式。请注意，这将自动禁用第一个方法，这和把每个连接的帧缓冲区的blendEnable设置为VK_FALSE是一样的效果。colorWriteMask也将在此模式下用于确定帧缓冲区中的哪些通道实际受影响。也可以禁用这两种模式，就像我们在这里做的这样样，在这种情况下，片段颜色将被无修改地写入帧缓冲区。 动态我们在之前的结构中指定的有限数量的状态实际上可以在不重新创建管道的情况下进行更改，比如是视口的大小，线宽以及混合常量。如果你想这样做，那么你必须填充VkPipelineDynamicStateCreateInfo结构，如下所示： 123456789VkDynamicState dynamicStates[] = &#123; VK_DYNAMIC_STATE_VIEWPORT, VK_DYNAMIC_STATE_LINE_WIDTH&#125;;VkPipelineDynamicStateCreateInfo dynamicState = &#123;&#125;;dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;dynamicState.dynamicStateCount = 2;dynamicState.pDynamicStates = dynamicStates; 这将导致现在忽略这些值的配置，之后需要在绘图的时候来指定。我们将在之后的章节中回来修改。如果没有任何动态状态，则可以使用nullptr替换此结构。 管道布局您可以在着色器中使用uniform，这种类型值是类似于动态状态变量的全局变量，可以在绘制时更改这些变量以更改着色器的行为，而无需重新创建它们。它们通常用于将变换矩阵传递到顶点着色器，或者在片段着色器中创建纹理采样器。 需要在管道创建期间通过创建VkPipelineLayout对象来指定这些uniform值。即使我们在之后的章节中不会用到它们，仍然需要创建一个空的管道布局。 创建一个类成员来保存这个对象，因为我们之后会从其他函数中引用它： 1VkPipelineLayout pipelineLayout; 然后在createGraphicsPipeline函数中创建对象： 12345678910VkPipelineLayoutCreateInfo pipelineLayoutInfo = &#123;&#125;;pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;pipelineLayoutInfo.setLayoutCount = 0; // OptionalpipelineLayoutInfo.pSetLayouts = nullptr; // OptionalpipelineLayoutInfo.pushConstantRangeCount = 0; // OptionalpipelineLayoutInfo.pPushConstantRanges = nullptr; // Optionalif (vkCreatePipelineLayout(device, &amp;pipelineLayoutInfo, nullptr, &amp;pipelineLayout) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create pipeline layout!&quot;);&#125; 该结构还指定了推送常量（push constants），这是将动态值传递给着色器的另一种方式，我们可能会在将来的章节中介绍这些方法。管道布局将在整个程序的生命周期中被引用，因此它应该在最后被销毁： 1234void cleanup() &#123; vkDestroyPipelineLayout(device, pipelineLayout, nullptr); ...&#125; 总结这就是所有固定功能了。从头开始设置所有这些看起来非常麻烦，但优点是我们现在几乎完全了解了图形管道中正在发生的一切。这减少了遇到意外行为的可能性，因为某些组件的默认状态不是我们所期望的。 然而，在我们最终创建图形管道之前还有一个要创建的对象，那就是渲染过程。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(10)-画个三角形(图形管道)-着色器模块","slug":"学习一个vulkan-10-画个三角形-图形管道-着色器模块","date":"2018-11-08T01:38:21.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/08/学习一个vulkan-10-画个三角形-图形管道-着色器模块/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/08/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-10-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93-%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9D%97/","excerpt":"继续上一次的","text":"继续上一次的 与早期的API不同，Vulkan中的着色器代码必须以字节码格式，而不是像GLSL和HLSL这样的比较有可读性的语法。这种字节码格式称为SPIR-V，旨在与Vulkan和OpenCL（两种都是Khronos API）一起使用，这是一种可用于编写图形和计算着色器的格式，但我们将重点介绍本教程中Vulkan图形管道中使用的着色器。 使用字节码格式的优点是GPU供应商编写的将着色器代码转换为本机代码的编译器要没那么复杂。过去的经验表明，使用像GLSL这样的人类可读语法，一些GPU供应商对标准的解释太灵活了。如果您碰巧使用其中一个供应商的GPU编写非平凡着色器，那么由于语法错误，您将面临其他供应商的驱动程序拒绝您的代码的风险，更糟的是由于编译器错误，着色器的运行方式可能完全不同。使用像SPIR-V这样简单的字节码格式，希望可以避免这种局面。 但是，这也不意味着我们需要手动编写这个字节码。Khronos发布了自己独立于供应商的编译器，可以将GLSL编译为SPIR-V。此编译器旨在验证着色器代码是否完全符合标准，并生成一个可与程序一起使用的SPIR-V二进制文件。 您还可以将此编译器作为库包含项目中，这样可以在运行时同时生成SPIR-V，但在本教程中我们不会这样做。编译器已包含在LunarG SDK中，即glslangValidator.exe，因此无需额外下载任何内容。 GLSL是一种带有C风格语法的着色语言。写在程序中的main函数会对为每个对象进行调用。GLSL使用全局变量来处理输入和输出，而不是使用输入参数和返回值作为输出，这个语言包括许多有助于图形编程的功能，如内置的向量和矩阵基元，还有求叉积，矩阵向量积以及反射向量等函数。矢量类型称为vec，然后使用一个数字来表示其中元素的数量，例如，一个3D坐标将存储在vec3中。可以通过.x等成员访问单个成员，也可以同时获取多个成员来创建新的向量。例如，表达式vec3（1.0,2.0,3.0）.xy将生成一个vec2向量。向量的构造函数也可以采用向量对象和标量值的组合。例如，vec3可以用vec3（vec2（1.0,2.0），3.0）来构建。 如前一章所述，我们需要编写顶点着色器和片段着色器以在屏幕上获得三角形。接下来的两节将介绍每个部分的GLSL代码，之后我将向您展示如何生成两个SPIR-V二进制文件并将它们加载到程序中。 顶点着色器顶点着色器处理每个传入的顶点，它将其属性（世界位置，颜色，法线和纹理坐标等等）作为输入。输出是裁剪坐标中的最终位置以及需要传递到片段着色器的属性，如颜色和纹理坐标。然后，光栅化阶段将这些值插入片段中，来产生平滑的梯度。裁剪坐标（clip coordinate）是顶点着色器产生的四维向量，在之后通过将整个向量除以其最后一个成员变化为标准化的设备坐标。标准化的设备坐标是齐次坐标，它将帧缓冲区映射到[-1,1]乘[-1,1]坐标系，如下所示：如果您之前涉足过计算机图形学，那么您应该已经熟悉了这些了。如果您之前使用过OpenGL，那么您会注意到Y坐标的符号现在被翻转了，现在用到的Z坐标的范围与Direct3D中相同，从0到1。 对于我们的第一个三角形，我们不会应用任何变换，只需将三个顶点的位置直接指定为规范化设备坐标即可创建以下形状： 我们可以直接输出归一化的设备坐标，方法是将它们作为顶点着色器的裁剪坐标输出，其中的最后一个组件设置为1。这样之后，将裁剪坐标转化为标准化的设备坐标时将不会有任何改变。 通常的做法是将这些坐标存储在顶点缓冲区中，但在Vulkan中创建顶点缓冲区以及用数据进行填充并不简单。所以我决定推迟这一步，直到我们可以看到屏幕上出现一个满意的三角形。我们将做一些非一般流程的事情：直接在顶点着色器中包含坐标。代码如下所示： 12345678910111213141516#version 450#extension GL_ARB_separate_shader_objects : enableout gl_PerVertex &#123; vec4 gl_Position;&#125;;vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5));void main() &#123; gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);&#125; main函数将会作用于每个顶点，内置的gl_VertexIndex变量包含当前顶点的索引。这通常是顶点缓冲区的索引，但在我们的例子中，它是硬编码顶点数据数组的索引。从着色器中的常量数组访问每个顶点的位置，并与虚拟的z坐标和w组合来生成裁剪坐标中的位置，内置变量gl_Position用作输出。Vulkan着色器需要GL_ARB_separate_shader_objects扩展才能工作。 片段着色器由顶点着色器的生成的位置形成的三角形将用片段（fragments，候选像素）填充屏幕上的区域。在这些片段上调用片段着色器来为帧缓冲区（单个或多个）生成颜色和深度。为整个三角形输出红色的简单片段着色器如下所示： 12345678#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) out vec4 outColor;void main() &#123; outColor = vec4(1.0, 0.0, 0.0, 1.0);&#125; 就像顶点着色器中的main函数会作用于每个顶点一样，这里的main函数将会作用于每个片段。GLSL中的颜色是4个分量的矢量，其中R，G，B和α通道的值都在[0,1]范围内。与顶点着色器中的gl_Position不同，这里没有内置变量来输出当前片段的颜色。您必须为每个帧缓冲区指定自己的输出变量，其中layout（location &#x3D; 0）这里的0就是指定了帧缓冲区的索引。这里将红色写入了outColor变量，这个变量链接到索引为0的第一个（也是唯一的）帧缓冲区。 逐个顶点着色（Per-vertex colors）整个三角形都是红色的太无趣了，下面这个看起来好多了： 我们必须对两个着色器进行一些更改才能实现这个目标。首先，我们需要为每一个顶点都指定不同的颜色。顶点着色器现在应该包含一个颜色数组，就像它们的位置一样： 12345vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0)); 现在我们只需要将每个顶点的颜色传递给片段着色器，这样它就可以将它们的插值输出到帧缓冲区了。将颜色输出变量添加到顶点着色器并在main函数中写入： 123456layout(location = 0) out vec3 fragColor;void main() &#123; gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex];&#125; 接下来需要在片段着色器中添加匹配的输入： 12345layout(location = 0) in vec3 fragColor;void main() &#123; outColor = vec4(fragColor, 1.0);&#125; 这里的输入变量并不需要使用相同的名称（fragColor），它们将使用location指令指定的索引链接在一起。main函数的功能已被修改，现在会输出颜色和alpha值。如上图所示，fragColor的值将自动插入三个顶点之间的片段，从而产生平滑的渐变。 编译着色器在项目的根目录中创建一个名为shaders的目录，并将顶点着色器存储在名为shader.vert的文件中，将片段着色器存储名为shader.frag的文件中。GLSL着色器没有官方扩展来说明，但这两个名字通常用于区分它们。 shader.vert的应该如下所示： 12345678910111213141516171819202122232425#version 450#extension GL_ARB_separate_shader_objects : enableout gl_PerVertex &#123; vec4 gl_Position;&#125;;layout(location = 0) out vec3 fragColor;vec2 positions[3] = vec2[]( vec2(0.0, -0.5), vec2(0.5, 0.5), vec2(-0.5, 0.5));vec3 colors[3] = vec3[]( vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));void main() &#123; gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0); fragColor = colors[gl_VertexIndex];&#125; shader.frag的内容应该是： 12345678910#version 450#extension GL_ARB_separate_shader_objects : enablelayout(location = 0) in vec3 fragColor;layout(location = 0) out vec4 outColor;void main() &#123; outColor = vec4(fragColor, 1.0);&#125; 我们现在要使用glslangValidator程序将它们编译成SPIR-V字节码。Windows创建一个compile.bat文件，写入以下内容： 123C:/VulkanSDK/1.1.85.0/Bin32/glslangValidator.exe -V shader.vertC:/VulkanSDK/1.1.85.0/Bin32/glslangValidator.exe -V shader.fragpause 将glslangValidator.exe的路径替换为你安装Vulkan SDK的路径，双击文件并运行。Linux创建一个compile.bat文件，写入以下内容： 12/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslangValidator -V shader.vert/home/user/VulkanSDK/x.x.x.x/x86_64/bin/glslangValidator -V shader.frag 将glslangValidator.exe的路径替换为你安装Vulkan SDK的路径，使用chmod + x compile.sh使脚本可以执行然后运行。有关特定平台的说明这两个命令都使用了使用-V标志进行调用，这个标志用于将GLSL源文件编译为SPIR-V字节码。运行编译脚本后，可以看到创建了两个SPIR-V二进制文件：vert.spv和frag.spv。名称是根据着色器的类型自动派生，但您可以随意更改。在编译着色器时，可能会收到有关某些缺失功能的警告，但您可以放心地忽略它。 如果着色器包含语法错误，则编译器会告诉您行号和问题。例如，可以试一下省略分号并再次运行编译脚本。也可以可以尝试在没有任何参数的情况下运行编译器，以查看它支持的标志。例如，它还可以将字节码输出为人类可读的格式，这样就可以准确地看到着色器正在做什么以及在此阶段应用的优化。 在命令行上编译着色器是最直接的选则之一，这也是我们将在本教程中使用的方式。你也可以直接从代码中来编译着色器，Vulkan SDK包含libshaderc，它是一个库，用于从程序中将GLSL代码编译为SPIR-V。 加载着色器现在我们有了生成SPIR-V着色器的方法，现在是时候将它们加载到我们的程序中，以便在之后将它们插入到图形管道中了。我们首先编写一个简单的辅助函数来从文件中加载二进制数据。 1234567891011#include &lt;fstream&gt;...static std::vector&lt;char&gt; readFile(const std::string&amp; filename) &#123; std::ifstream file(filename, std::ios::ate | std::ios::binary); if (!file.is_open()) &#123; throw std::runtime_error(&quot;failed to open file!&quot;); &#125;&#125; readFile函数将读取指定文件中的所有字节，并将它们返回到由std::vector管理的字节数组中。我们首先用这两个标志来打开的文件： ate： 从文件末尾开始阅读 binary：将文件读取为二进制文件（避免文本转换） 从文件末尾开始读取的优点是我们可以利用读取位置来确定文件的大小并分配缓冲区： 12size_t fileSize = (size_t) file.tellg();std::vector&lt;char&gt; buffer(fileSize); 之后，我们可以回到文件的开头重新读取所有字节： 12file.seekg(0);file.read(buffer.data(), fileSize); 最后关闭文件并返回字节： 123file.close();return buffer; 现在将从createGraphicsPipeline调用此函数来加载两个着色器的字节码： 1234void createGraphicsPipeline() &#123; auto vertShaderCode = readFile(&quot;shaders/vert.spv&quot;); auto fragShaderCode = readFile(&quot;shaders/frag.spv&quot;);&#125; 通过打印缓冲区的大小并检查它们是否与实际文件大小（以字节为单位）匹配，可以确保正确加载着色器。 创建着色器模块在我们将代码传递给管道之前，我们必须将它包装在VkShaderModule对象中。创建一个辅助函数createShaderModule来做这件事： 123VkShaderModule createShaderModule(const std::vector&lt;char&gt;&amp; code) &#123;&#125; 该函数将使用字节缓冲区作为参数的，并从中创建一个VkShaderModule。 创建着色器模块很简单，我们只需要指定一个指向缓冲区的指针，其中包含字节码及其长度。这个信息在VkShaderModuleCreateInfo结构中指定。有个问题是字节码的大小是以字节为单位指定的，但字节码指针是uint32_t类型指针而不是char指针。因此，我们需要使用reinterpret_cast指针进行转换，如下所示。当您执行此类转换时，还需要确保数据满足uint32_t的对齐要求。幸运的是，存储在std::vector中的数据，默认分配器已经确保数据满足最坏情况的对齐要求了： 1234VkShaderModuleCreateInfo createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;createInfo.codeSize = code.size();createInfo.pCode = reinterpret_cast&lt;const uint32_t*&gt;(code.data()); 然后可以通过调用vkCreateShaderModule来创建VkShaderModule： 1234VkShaderModule shaderModule;if (vkCreateShaderModule(device, &amp;createInfo, nullptr, &amp;shaderModule) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create shader module!&quot;);&#125; 参数与之前对象创建函数中的参数相同：逻辑设备，信息结构的指针，可选的自定义分配器指针和处理后的输出变量。创建着色器模块后会立即释放相应代码的缓冲区。最后不要忘记返回创建的着色器模块： 1return shaderModule; 只有在管道创建过程中才需要着色器模块对象，因此我们不会将它们声明为类成员，而是在createGraphicsPipeline函数中创建局部变量： 12VkShaderModule vertShaderModule;VkShaderModule fragShaderModule; 调用我们创建的辅助函数来加载着色器模块： 12vertShaderModule = createShaderModule(vertShaderCode);fragShaderModule = createShaderModule(fragShaderCode); 创建图形管道并返回createGraphicsPipeline后，需要清除它们，因此请确保在函数末尾删除它们： 1234 ... vkDestroyShaderModule(device, fragShaderModule, nullptr); vkDestroyShaderModule(device, vertShaderModule, nullptr);&#125; 创建着色器阶段VkShaderModule对象只是字节码缓冲区的一个很蠢的包装器（dumb wrapper）。着色器尚未相互链接，它们甚至还没有被赋予一个目标。将着色器模块分配给管道中的顶点或片段着色器阶段是通过VkPipelineShaderStageCreateInfo结构进行的，该结构是实际管道创建过程的一部分。 我们将首先在createGraphicsPipeline函数中填充顶点着色器的结构： 123VkPipelineShaderStageCreateInfo vertShaderStageInfo = &#123;&#125;;vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT; 除了必须设置的sType成员之外，第一步是告诉Vulkan将在哪个管道阶段使用着色器。在前一章中描述的每个可编程阶段都有一个对应枚举值。 12vertShaderStageInfo.module = vertShaderModule;vertShaderStageInfo.pName = &quot;main&quot;; 接下来的两个成员指定包含代码的着色器模块和要调用的函数。这意味着可以将多个片段着色器组合到一个着色器模块中，并使用不同的入口点来区分它们的行为。在这里，我们将坚持使用标准的main函数。 还有一个（可选的）成员pSpecializationInfo，我们将不会在这里使用，但会说明一下。它允许您指定着色器常量的值，您可以使用单个的着色器模块，通过为其中使用的常量指定不同的值，就能实现在创建管道的时候配置其行为。这比在渲染时使用变量配置着色器更有效，因为编译器可以执行优化，例如消除依赖于这些值的if语句。如果没有这样的常量，那么你可以将成员设置为nullptr，相应的struct自动进行初始化。 把结构修改为适合片段着色器的形式很简单： 12345VkPipelineShaderStageCreateInfo fragShaderStageInfo = &#123;&#125;;fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;fragShaderStageInfo.module = fragShaderModule;fragShaderStageInfo.pName = &quot;main&quot;; 最后定义一个包含这两个结构的数组，我们稍后将在实际的管道创建步骤中引用它们。 1VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfo, fragShaderStageInfo&#125;; 这就是描述管道的可编程的阶段的全部内容。在下一章中，我们将讨论固定功能的阶段。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(9)-画个三角形(图形管道)-简介","slug":"学习一个vulkan-9-画个三角形-图形管道-简介","date":"2018-11-07T01:23:19.000Z","updated":"2022-07-23T03:12:46.275Z","comments":true,"path":"2018/11/07/学习一个vulkan-9-画个三角形-图形管道-简介/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/07/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-9-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E5%9B%BE%E5%BD%A2%E7%AE%A1%E9%81%93-%E7%AE%80%E4%BB%8B/","excerpt":"继续上一次的","text":"继续上一次的 简介在接下来的几章中，我们将设置一个图形管道，用来配置绘制的第一个三角形。图形管道是一系列操作，它们将网格的顶点和纹理来渲染目标中的像素点。一个简化的流程如下所示：The input assembler从指定的缓冲区收集原始顶点数据，也可以使用索引缓冲区重复使用某些元素，而不必复制顶点数据本身。 The vertex shader是针对每个顶点的着色器，而且可以完成将顶点位置从模型空间转换到屏幕空间的转换，同时也能沿着管道传输顶点数据。 The tessellation shaders 允许根据特定规则来细分几何体以提高网格质量。这通常用于使砖墙和楼梯等表面在附近时看起来不那么平坦。 The geometry shader 可以对每一个基元（三角形，点，线）进行操作，而且能够破坏和创建基元，这一点和曲面细分着色器（tessellation shader）很像，但是会更加灵活。但是，它在今天的应用程序中并没有得到太多应用，因为除了英特尔的集成GPU之外，他在大多数显卡的表现都不是很好。 The rasterization 将图元离散化为候选像素（fragments），这是用来填充到帧缓冲区的像素。任何落在屏幕之外的候选像素都将被丢弃，顶点着色器输出的属性将在候选像素之间进行插值，如上图所示。由于深度测试，通常在这里也丢弃其他原始候选像素之后的一段。 The fragment shader 将作用于存活的候选像素，决定它们的颜色，深度以及将写入那一个帧缓冲区。它可以使用来自顶点着色器的插值数据来完成此操作，其中包括纹理坐标和法线照明等。 The color blending 用于将帧缓冲区中映射为相同像素的不同候选像素混合到一起。候选像素可以简单地相互覆盖，相加或基于透明度进行混合。 上图中绿色的阶段称为fixed-function。这些阶段允许您使用参数来调整其中的操作，但它们的工作方式是预定义的。 黄色的阶段称为programmable，这意味着可以使用自己的代码来操作显卡，这样就可以完全应用您所想要的操作了。The fragment shader就是这样，可以自由实现从纹理和照明到光线追踪器的任何事情。这些程序可以同时在多个GPU内核上运行，；来处理多个对象，比如并行的顶点和候选像素。 如果您之前使用过比较旧的API，如OpenGL和Direct3D，您可能会习惯于能够通过glBlendFunc和OMSetBlendState等函数随意更改任何管道设置。Vulkan中的图形管道几乎完全不可变，因此如果要更改着色器，绑定不同的帧缓冲区或更改混合函数，则必须从头开始重新创建管道，这个的缺点是必须创建许多管道，这些管道代表要在渲染操作中使用的所有状态组合，但是，因为在管道中进行的所有操作都是已预先知道了，所以驱动程序也可以更好地优化它。 根据不同的工作要求，某些可编程的阶段是可选的。例如，如果只是绘制简单几何体，则可以禁用曲面细分和几何着色器阶段。如果只对深度值感兴趣，则可以禁用片段着色器阶段，这对阴影贴图生成很有用。 在下一章中，我们将首先创建将绘制三角形的两个可编程阶段：顶点着色器（the vertex shader）和片段着色器（fragment shader）。 混合模式，视口，光栅化等固定功能配置将在此后的章节中设置。在Vulkan中设置图形管道的最后一部分将涉及输入和输出帧缓冲区的规范。 在initVulkan中紧接着createImageViews的后面创建一个createGraphicsPipeline函数。我们将在之后的章节中来实现此功能： 12345678910111213141516void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews(); createGraphicsPipeline();&#125;...void createGraphicsPipeline() &#123;&#125;","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(8)-画个三角形(显示)-图像视图","slug":"学习一个vulkan-8-画个三角形-显示-图像视图","date":"2018-11-06T01:11:35.000Z","updated":"2022-07-23T03:12:46.275Z","comments":true,"path":"2018/11/06/学习一个vulkan-8-画个三角形-显示-图像视图/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/06/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-8-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%98%BE%E7%A4%BA-%E5%9B%BE%E5%83%8F%E8%A7%86%E5%9B%BE/","excerpt":"继续上一次的","text":"继续上一次的 图像视图要在渲染管道中使用任何VkImage，包括交换链中的，我们必须创建一个VkImageView对象。图像视图实际上是图像的视图。它描述了如何访问图像以及要访问的图像的哪一部分，例如决定是否被作为2D纹理而不使用任何Mip贴图（MipMapping）来处理。 在本章中，我们将编写一个createImageViews函数，为交换链中的每个图像创建一个基本图像视图，以便我们以后可以将它们用作着色目标。 首先添加一个类成员来存储图像视图： 1std::vector&lt;VkImageView&gt; swapChainImageViews; 创建createImageViews函数并在创建交换链后立即调用： 12345678910111213void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain(); createImageViews();&#125;void createImageViews() &#123;&#125; 我们需要做的第一件事是调整列表大小以适应我们将要创建的所有图像视图： 1234void createImageViews() &#123; swapChainImageViews.resize(swapChainImages.size());&#125; 接下来，设置循环来遍历所有交换链图像： 123for (size_t i = 0; i &lt; swapChainImages.size(); i++) &#123;&#125; 创建图像视图的参数在VkImageViewCreateInfo结构中指定。前几个参数很简单： 123VkImageViewCreateInfo createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;createInfo.image = swapChainImages[i]; viewType和format参数指定应以何种方式解析图像数据。viewType参数允许您将图像设置为一维纹理，二维纹理，三维纹理或者立方体贴图： 12createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;createInfo.format = swapChainImageFormat; components参数设置对应的颜色通道。例如，您可以将所有通道映射到红色通道以获得单色纹理，还可以将常量值0和1映射到通道。在本例中，我们将使用默认映射。 1234createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY; subresourceRange参数将描述图像用于何种用途以及访问图像的哪个部分。我们的图像将用于着色目的，没有任何mipmapping级别或多图层： 12345createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;createInfo.subresourceRange.baseMipLevel = 0;createInfo.subresourceRange.levelCount = 1;createInfo.subresourceRange.baseArrayLayer = 0;createInfo.subresourceRange.layerCount = 1; 如果您正在处理立体3D应用程序，那么将创建一个包含多个图层的交换链。然后，您可以通过访问不同的图层为每个图像创建多个图像视图，以表示左眼和右眼的视图。 现在，创建图像视图就只需要调用vkCreateImageView了： 123if (vkCreateImageView(device, &amp;createInfo, nullptr, &amp;swapChainImageViews[i]) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create image views!&quot;);&#125; 与图像不同，图像视图是由我们显式创建的，因此我们需要添加一个类似的循环以在程序结束时再次销毁它们： 1234567void cleanup() &#123; for (auto imageView : swapChainImageViews) &#123; vkDestroyImageView(device, imageView, nullptr); &#125; ...&#125; 图像视图已经足够作为将图像用作纹理功能的开端了，但它现在还不能用于渲染目标。还需要一个称为帧缓冲的间接步骤。但首先我们必须设置图形管道。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(7)-画个三角形(显示)-交换链","slug":"学习一个vulkan-7-画个三角形-显示-交换链","date":"2018-11-05T00:56:13.000Z","updated":"2022-07-23T03:12:46.259Z","comments":true,"path":"2018/11/05/学习一个vulkan-7-画个三角形-显示-交换链/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/05/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-7-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%98%BE%E7%A4%BA-%E4%BA%A4%E6%8D%A2%E9%93%BE/","excerpt":"继续上一次的","text":"继续上一次的 Vulkan中没有“默认帧缓冲区（default framebuffer）”的概念，因此，还需要一个基本结构，在我们将相应的渲染显示到屏幕上此前存储在这个缓冲区中。这个基本结构称为交换链，是Vulkan程序中必须创建的。交换链本质上是一个等待呈现给屏幕的图像队列，我们的应用程序获取相应的图像进行绘制，然后将其返回到队列中。虽然队列的工作原理以及从队列中显示图像的条件也取决于交换链的设置方式，但交换链的原本目的是使图像的显示与屏幕的刷新率同步。 检查交换链支持并非所有的显卡都能够直接将图像呈现给屏幕，如果是为服务器设计的显卡，可能就没有任何显示输出的功能。其次，由于图像的显示严重依赖于窗口系统和与窗口的surface，所以他并不是Vulkan核心功能的一部分。在查询是否支持这个功能后，就能启用VK_KHR_swapchain这个设备扩展了。 为此，我们首先扩展isDeviceSuitable函数来检查是否支持此扩展。我们之前已经了解了如何列出VkPhysicalDevice支持的扩展，所以这一步也相当简单。注意，Vulkan头文件提供了一个宏VK_KHR_SWAPCHAIN_EXTENSION_NAME，定义就是VK_KHR_swapchain。使用这个宏可以避免拼写错误。 首先声明所需设备扩展的列表，类似于要启用的验证层列表。 123const std::vector&lt;const char*&gt; deviceExtensions = &#123; VK_KHR_SWAPCHAIN_EXTENSION_NAME&#125;; 接下来，创建一个新函数checkDeviceExtensionSupport，在isDeviceSuitable中添加这个函数的调用作为附加检查： 1234567891011bool isDeviceSuitable(VkPhysicalDevice device) &#123; QueueFamilyIndices indices = findQueueFamilies(device); bool extensionsSupported = checkDeviceExtensionSupport(device); return indices.isComplete() &amp;&amp; extensionsSupported;&#125;bool checkDeviceExtensionSupport(VkPhysicalDevice device) &#123; return true;&#125; 枚举所有扩展并检查是否所有需要的扩展都在里面： 123456789101112131415bool checkDeviceExtensionSupport(VkPhysicalDevice device) &#123; uint32_t extensionCount; vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, nullptr); std::vector&lt;VkExtensionProperties&gt; availableExtensions(extensionCount); vkEnumerateDeviceExtensionProperties(device, nullptr, &amp;extensionCount, availableExtensions.data()); std::set&lt;std::string&gt; requiredExtensions(deviceExtensions.begin(), deviceExtensions.end()); for (const auto&amp; extension : availableExtensions) &#123; requiredExtensions.erase(extension.extensionName); &#125; return requiredExtensions.empty();&#125; 这里用一组set来存储还没有检查的扩展，这样的话在枚举所有扩展，找到相对应的时候可以简单的剔除已经检验好的。当然，也可以使用checkValidationLayerSupport中嵌套循环的形式来验证，这里的性能差异无关紧要。现在运行代码并验证的显卡确实能够支持交换链。值得注意的是，正如我们在前一章中所检查的那样，显示队列的可用意味着他已经支持了交换链的扩展。但是，明确的表达依然很重要，所以这里也需要明确的启用扩展。 启用扩展只需要对逻辑设备创建结构进行少量更改： 12createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(deviceExtensions.size());createInfo.ppEnabledExtensionNames = deviceExtensions.data(); 查询交换链支持的详细信息仅仅检查交换链是否可用是不够的，因为实际上它可能与窗口surface不兼容。创建交换链比实例和设备创建需要更多的设置，因此需要在下一步之前查询更多细节。 基本上有三个属性需要检查： 基本表面功能（交换链中的最小&#x2F;最大图像数，图像的最小&#x2F;最大宽度和高度） 表面格式（像素格式，色彩空间） 可用的显示模式与findQueueFamilies类似，我们将使用结构体在查询后传递这些信息。上述三种属性在结构体中的表现形式如下：12345struct SwapChainSupportDetails &#123; VkSurfaceCapabilitiesKHR capabilities; std::vector&lt;VkSurfaceFormatKHR&gt; formats; std::vector&lt;VkPresentModeKHR&gt; presentModes;&#125;; 我们现在将创建一个新函数querySwapChainSupport，它将填充此结构：12345SwapChainSupportDetails querySwapChainSupport(VkPhysicalDevice device) &#123; SwapChainSupportDetails details; return details;&#125; 本节只会介绍如何查询包含这些信息的结构，相应的含义以及它们包含的确切数据将在下一节中讨论。 从基本的表面功能开始。这些属性很容易查询并返回到单个VkSurfaceCapabilitiesKHR结构中： 1vkGetPhysicalDeviceSurfaceCapabilitiesKHR(device, surface, &amp;details.capabilities); 这个函数需要接受VkPhysicalDevice和VkSurfaceKHR的窗口surface参数来确定支持的功能。所有的支持查询功能都会将这两个参数作为首要的参数，因为它们是交换链的核心组件。 下一步是查询支持的表面格式。因为这是同一个结构体的列表，所以同样和之前很多相似的函数一样调用（先查询个数，在查询每个的值）： 1234567uint32_t formatCount;vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, nullptr);if (formatCount != 0) &#123; details.formats.resize(formatCount); vkGetPhysicalDeviceSurfaceFormatsKHR(device, surface, &amp;formatCount, details.formats.data());&#125; 确保调整矢量的大小来容纳所有可用格式。最后，使用vkGetPhysicalDeviceSurfacePresentModesKHR来查询支持的现实模式与，与之前的方式完全相同： 1234567uint32_t presentModeCount;vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, nullptr);if (presentModeCount != 0) &#123; details.presentModes.resize(presentModeCount); vkGetPhysicalDeviceSurfacePresentModesKHR(device, surface, &amp;presentModeCount, details.presentModes.data());&#125; 现在所有的细节都填充到结构体中了，让我们再次扩展isDeviceSuitable，利用这个函数来验证交换链的支持是否可用。如果在我们现在拥有的窗口surface下至少有一种支持的图像格式和一种支持的显示模式，则交换链的支持对于本教程就足够用了。 12345bool swapChainAdequate = false;if (extensionsSupported) &#123; SwapChainSupportDetails swapChainSupport = querySwapChainSupport(device); swapChainAdequate = !swapChainSupport.formats.empty() &amp;&amp; !swapChainSupport.presentModes.empty();&#125; 重要的一点，在验证层扩展可用后，我们只尝试查询交换链支持就行了。函数的最后一行更改为： 1return indices.isComplete() &amp;&amp; extensionsSupported &amp;&amp; swapChainAdequate; 为交换链选择正确的设置如果满足swapChainAnequate条件，那么交换链的支持肯定就足够了，但可能仍有许多不同的设置不是最优的。我们现在将编写一些函数来找到正确的设置来使交换链变成最优的形式。有三种类型可供选择的设置： 表面格式（颜色深度） 显示模式（将图像“交换”到屏幕的条件） 交换范围（交换链中图像的分辨率）对于这些设置中的每一个，我们都会有一个理想的值，如果它可用，我们将继续使用，否则我们将创建一些逻辑来找到下一个最好的设置。 表面格式这个设置将从下面这个函数开始，我们稍后会将SwapChainSupportDetails结构的formats成员作为参数传递： 123VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats) &#123;&#125; 每个VkSurfaceFormatKHR都包含一个format和一个colorSpace成员。format成员指定了颜色通道和类型，例如，VK_FORMAT_B8G8R8A8_UNORM意味着我们以8位无符号整数的顺序存储B，G，R和alpha通道，每个像素占用32位。colorSpace成员使用VK_COLOR_SPACE_SRGB_NONLINEAR_KHR标志说明是否支持SRGB色彩空间，请注意，在旧版本中，此标志是VK_COLORSPACE_SRGB_NONLINEAR_KHR。 对于色彩空间，我们将使用SRGB（如果可用的话），因为它可以产生更准确的感知颜色。直接使用SRGB颜色有点困难，因此我们将使用标准的RGB作为颜色格式，其中最常见的一种是VK_FORMAT_B8G8R8A8_UNORM 最好的情况是Vulkan只返回一个VkSurfaceFormatKHR条目，其格式成员设置为VK_FORMAT_UNDEFINED的时候，这样surface是没有首选格式的，我们可以自由选择： 123if (availableFormats.size() == 1 &amp;&amp; availableFormats[0].format == VK_FORMAT_UNDEFINED) &#123; return &#123;VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR&#125;;&#125; 如果我们无法自由选择任何格式，那么我们将遍历列表的所有项并检测首选组合是否可用： 12345for (const auto&amp; availableFormat : availableFormats) &#123; if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123; return availableFormat; &#125;&#125; 如果这也失败了，那么我们可以根据它们的好坏程度对可用格式进行排名，但在大多数情况下，只需使用指定的第一种格式即可： 12345678910111213VkSurfaceFormatKHR chooseSwapSurfaceFormat(const std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats) &#123; if (availableFormats.size() == 1 &amp;&amp; availableFormats[0].format == VK_FORMAT_UNDEFINED) &#123; return &#123;VK_FORMAT_B8G8R8A8_UNORM, VK_COLOR_SPACE_SRGB_NONLINEAR_KHR&#125;; &#125; for (const auto&amp; availableFormat : availableFormats) &#123; if (availableFormat.format == VK_FORMAT_B8G8R8A8_UNORM &amp;&amp; availableFormat.colorSpace == VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123; return availableFormat; &#125; &#125; return availableFormats[0];&#125; 显示模式显示模式可以说是交换链中最重要的设置，因为它代表了向屏幕显示图像的实质条件。Vulkan有四种可用的模式： VK_PRESENT_MODE_IMMEDIATE_KHR：应用程序提交的图像会立即传输到屏幕上，这可能会导致撕裂。 VK_PRESENT_MODE_FIFO_KHR: 交换链是一个队列，当屏幕显示刷新并且程序在队列的后面插入渲染图像时，从队列的前面获取图像。如果队列已满，则程序必须等待。这与现代游戏中的垂直同步很相似，刷新显示的时刻称为“垂直空白”。 VK_PRESENT_MODE_FIFO_RELAXED_KHR: 该模式与上一个模式略有不同的地方为，如果应用程序存在延迟，即接受最后一个垂直同步信号时队列空了，将不会等待下一个垂直同步信号，而是将图像直接传送。这样做可能导致可见的撕裂效果。 VK_PRESENT_MODE_MAILBOX_KHR: 这是第二种模式的另一种变化，当队列已满时，队列中的图像将被替换为较新的图像，而不是阻塞。此模式可用于实现三重缓冲，与使用双缓冲的标准垂直同步相比，可以通过减少延时来避免因此导致的图像撕裂。只需要保证VK_PRESENT_MODE_FIFO_KHR时可用的就行了，同样，再次编写一个函数来查找可用的最佳模式：123VkPresentModeKHR chooseSwapPresentMode(const std::vector&lt;VkPresentModeKHR&gt; availablePresentModes) &#123; return VK_PRESENT_MODE_FIFO_KHR;&#125; 我个人认为三重缓冲是一个非常好的模式。它允许我们通过渲染尽可能新的图像直到垂直空白来避免撕裂，同时仍然可以保持相当低的延迟。所以这里可以检测一下它是否可用：123456789VkPresentModeKHR chooseSwapPresentMode(const std::vector&lt;VkPresentModeKHR&gt; availablePresentModes) &#123; for (const auto&amp; availablePresentMode : availablePresentModes) &#123; if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123; return availablePresentMode; &#125; &#125; return VK_PRESENT_MODE_FIFO_KHR;&#125; 遗憾的是，某些驱动程序目前不能正确支持VK_PRESENT_MODE_FIFO_KHR，因此如果VK_PRESENT_MODE_MAILBOX_KHR不可用，可以使用VK_PRESENT_MODE_IMMEDIATE_KHR:12345678910111213VkPresentModeKHR chooseSwapPresentMode(const std::vector&lt;VkPresentModeKHR&gt; availablePresentModes) &#123; VkPresentModeKHR bestMode = VK_PRESENT_MODE_FIFO_KHR; for (const auto&amp; availablePresentMode : availablePresentModes) &#123; if (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) &#123; return availablePresentMode; &#125; else if (availablePresentMode == VK_PRESENT_MODE_IMMEDIATE_KHR) &#123; bestMode = availablePresentMode; &#125; &#125; return bestMode;&#125; 交换范围现在为最后的一个设置添加函数： 123VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities) &#123;&#125; 交换范围是交换链图像的分辨率，它几乎总是等于绘制的窗口的分辨率。可能的分辨率范围在VkSurfaceCapabilitiesKHR结构中定义。Vulkan告诉我们可以在currentExtent成员中设置宽度和高度来匹配窗口的分辨率。但是，一些窗口管理器也允许我们在这里有不同的设置，可以通过将currentExtent中的宽度和高度设置为特殊值来进行指定：设置为uint32_t的最大值。在这种情况下，我们将选择在minImageExtent和maxImageExtent范围内与窗口最匹配的方案： 123456789101112VkExtent2D chooseSwapExtent(const VkSurfaceCapabilitiesKHR&amp; capabilities) &#123; if (capabilities.currentExtent.width != std::numeric_limits&lt;uint32_t&gt;::max()) &#123; return capabilities.currentExtent; &#125; else &#123; VkExtent2D actualExtent = &#123;WIDTH, HEIGHT&#125;; actualExtent.width = std::max(capabilities.minImageExtent.width, std::min(capabilities.maxImageExtent.width, actualExtent.width)); actualExtent.height = std::max(capabilities.minImageExtent.height, std::min(capabilities.maxImageExtent.height, actualExtent.height)); return actualExtent; &#125;&#125; 这里使用max和min函数来将WIDTH和HEIGHT的值设定在支持的最小和最大范围之间。需要#include 来使用它们。 创建交换链现在我们已经拥有了所有这些辅助函数来帮助我们在运行时做出选择，现在有了创建交换链所需的所有信息。 创建一个createSwapChain函数，确保在initVulkan中的创建逻辑设备的函数之后调用他。在这个函数中首先获取之前辅助函数得到的所有值： 12345678910111213141516void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice(); createSwapChain();&#125;void createSwapChain() &#123; SwapChainSupportDetails swapChainSupport = querySwapChainSupport(physicalDevice); VkSurfaceFormatKHR surfaceFormat = chooseSwapSurfaceFormat(swapChainSupport.formats); VkPresentModeKHR presentMode = chooseSwapPresentMode(swapChainSupport.presentModes); VkExtent2D extent = chooseSwapExtent(swapChainSupport.capabilities);&#125; 实际上还有一些小东西需要设定，但它们很简单，不值得创建单独的函数。第一个是交换链中的图像数量，基本上就是队列长度。这个实现指定了正常运行时的最小图像数量，我们将尝试使用其中一个以正确实现三重缓冲： 1234uint32_t imageCount = swapChainSupport.capabilities.minImageCount + 1;if (swapChainSupport.capabilities.maxImageCount &gt; 0 &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123; imageCount = swapChainSupport.capabilities.maxImageCount;&#125; maxImageCount的值为0表示除了内存要求之外没有任何限制，所以这里需要进行额外的检查。 与Vulkan对象一样，创建交换链对象也需要填充大型结构。我们现在已经非常熟悉这种形式了： 123VkSwapchainCreateInfoKHR createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;createInfo.surface = surface; 指定交换链应该绑定的surface后，还需要指定交换链中有关图像的详细信息： 123456createInfo.minImageCount = imageCount;createInfo.imageFormat = surfaceFormat.format;createInfo.imageColorSpace = surfaceFormat.colorSpace;createInfo.imageExtent = extent;createInfo.imageArrayLayers = 1;createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT; imageArrayLayers指定每个图像所包含的图层数量，除非是正在开发3D应用程序，否则始终为1。imageUsage指定将使用交换链中的图像进行哪种操作，在本教程中，我们将直接渲染它们，这意味着它们被用作颜色附件（color attachment）。当然也可以先单独渲染图像，之后在进行后续的操作。在这种情况下，可以使用VK_IMAGE_USAGE_TRANSFER_DST_BIT，并使用内存操作将渲染图像传输到交换链图像。 123456789101112QueueFamilyIndices indices = findQueueFamilies(physicalDevice);uint32_t queueFamilyIndices[] = &#123;indices.graphicsFamily.value(), indices.presentFamily.value()&#125;;if (indices.graphicsFamily != indices.presentFamily) &#123; createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT; createInfo.queueFamilyIndexCount = 2; createInfo.pQueueFamilyIndices = queueFamilyIndices;&#125; else &#123; createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE; createInfo.queueFamilyIndexCount = 0; // Optional createInfo.pQueueFamilyIndices = nullptr; // Optional&#125; 接下来，如上，我们需要指定如何处理将在多个队列簇中使用的交换链图像。如果图形队列簇与显示队列簇，就是多个队列簇的情况了。我们将从图形队列中绘制交换链中的图像，然后在显示队列中提交它们。有两种方法可以处理从多个队列访问的图像： VK_SHARING_MODE_EXCLUSIVE：图像一次只能由一个队列簇拥有，并且必须在将其用于另一个队列簇之前显式的转移所有权。此选项提供最佳性能。 VK_SHARING_MODE_CONCURRENT：图像可以在多个队列簇中使用，而无需显式所有权转移。如果队列簇不同，那么我们将在本教程中使用并发模式，以避免必须执行所有权的转移，因为这些涉及了一些在以后更好解释的概念。并发模式要求使用queueFamilyIndexCount和pQueueFamilyIndi​​ces参数预先指定将共享哪些队列簇的所有权。如果图形队列簇和显示队列簇是相同的（大多数硬件都是这种情况），那么我们应该坚持独占模式，因为并发模式要求指定至少两个不同的队列簇：1createInfo.preTransform = swapChainSupport.capabilities.currentTransform; 如果某个转换被支持的话（capabilities中的supportedTransforms），我们可以指定这个转换来应用于交换链中的图像，例如顺时针旋转90度或水平翻转。如果不需要任何转换，如上所示，只需指定为当前转换即可。1createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR; compositeAlpha指定是否使用alpha通道与窗口系统中的其他窗口进行混合，基本上都会忽略alpha通道，使用VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR就行了。12createInfo.presentMode = presentMode;createInfo.clipped = VK_TRUE; presentMode这个参数的名字一看就知道要设置为presentMode了。如果clipped设置为VK_TRUE，那么这意味着我们不关心被遮挡的像素的颜色，例如因为另一个窗口位于它们前面。除非真的需要能够读回这些像素并获得可预测的结果，否则这样设置能够获得最佳的性能。1createInfo.oldSwapchain = VK_NULL_HANDLE; 现在只剩下最后一个参数oldSwapchain了。使用Vulkan时，您的交换链可能会在您的应用程序运行时变成无效的或未优化的状态，比如窗口调整大小时就会这样。在这种情况下，需要从头开始重新创建交换链，并且必须在此字段中指定对旧交换链的引用。这是一个复杂的问题，我们将在以后的章节中详细介绍。这里我们只会创建一个交换链。 现在添加一个类成员来存储VkSwapchainKHR对象： 1VkSwapchainKHR swapChain; 现在创建交换链就像调用vkCreateSwapchainKHR一样简单了： 123if (vkCreateSwapchainKHR(device, &amp;createInfo, nullptr, &amp;swapChain) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create swap chain!&quot;);&#125; 参数分别是逻辑设备，交换链信息，可选的自定义分配器和指向存储句柄的变量的指针。同时还需要在清理设备之前使用vkDestroySwapchainKHR进行清理： 1234void cleanup() &#123; vkDestroySwapchainKHR(device, swapChain, nullptr); ...&#125; 现在运行应用程序以确保成功创建了交换链。如果此时在vkCreateSwapchainKHR中遇到访问冲突错误，或者得到了Failed to find ‘vkGetInstanceProcAddress’ in layer SteamOverlayVulkanLayer.dll的错误消息，可以查看有关Steam覆盖层的FAQ entry。 如果在启用验证层的时候删除createInfo.imageExtent &#x3D; extent;这一行，您将看到其中一个验证层立即捕获到错误并打印了一条有用的消息：（这里或许需要system(“pause”)，不然抛出异常后就直接退出了，看不到这个信息） 检索交换链图像交换链现在已经创建，所以剩下的就是检索其中的VkImages的句柄了。我们将在后面章节中的渲染操作中用到。添加一个类成员来存储句柄： 1std::vector&lt;VkImage&gt; swapChainImages; 图像是由交换链的实现创建的，一旦交换链被销毁，它们将自动清理，因此我们不需要添加任何清理代码。 现在在createSwapChain的vkCreateSwapchainKHR后面添加代码用于检索句柄，检索它们与在Vulkan中查找一组对象的过程非常相似。首先通过调用vkGetSwapchainImagesKHR查询交换链中的图像数量，然后调整容器大小，最后再次调用它以检索句柄。 123vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, nullptr);swapChainImages.resize(imageCount);vkGetSwapchainImagesKHR(device, swapChain, &amp;imageCount, swapChainImages.data()); 请注意，当我们创建交换链时，我们将所需图像的数量传递了名为minImageCount的字段。这样的实现方式允许可以创建更多的图像，这也是我们需要再次查询数目的原因。 最后一件事，存储我们为成员变量中的交换链图像选择的格式和范围。我们将在之后的章节中用到它们： 123456789VkSwapchainKHR swapChain;std::vector&lt;VkImage&gt; swapChainImages;VkFormat swapChainImageFormat;VkExtent2D swapChainExtent;...swapChainImageFormat = surfaceFormat.format;swapChainExtent = extent; 现在我们有了一组可以绘制并呈现给窗口的图像。下一章将开始介绍如何将图像设置为渲染目标，然后我们会开始研究实际的图形管道和绘图命令。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个erlang-afile","slug":"学习一个erlang-afile","date":"2018-11-03T07:25:12.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/11/03/学习一个erlang-afile/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/03/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAerlang-afile/","excerpt":"学习一个erlang，参考《Erlang程序设计》-Joe Armstrong","text":"学习一个erlang，参考《Erlang程序设计》-Joe Armstrong 一个书中的示例，简单的文件服务器。分为两个部分，客户端和服务端。书里实现了ls和get_file功能，还有作为习题之类的put_file功能首先看客户端的实现，首先是3个函数，参数分别是1,2,3： 1-export([ls/1,get_file/2,put_file/3]). 对于ls功能，就是查看当前服务器目录下的所有文件了，有： 123456ls(Server) -&gt; Server ! &#123;self(), list_dir&#125;, receive &#123;Server, FileList&#125; -&gt; FileList end. 很好理解，接受的参数就是Server了，Server ! {self(), list_dir}表示发送一个{self(),list_dir}消息给Server然后接收一个来自于Server的FileList消息，打印出来对于其他两个功能同理。get_file需要添加参数文件名用来查找put_file需要添加参数文件名和插入的字符串对于服务端，有两个函数，start和loop： 1start(Dir) -&gt; spawn(afile_server, loop, [Dir]). 接收一个Dir参数作为文件服务器目录，然后创建服务端进程。对于loop函数有： 123456789101112loop(Dir) -&gt; receive &#123;Client, list_dir&#125; -&gt; Client ! &#123;self(), file:list_dir(Dir)&#125;; &#123;Client, &#123;get_file, File&#125;&#125; -&gt; Full = filename:join(Dir,File), Client ! &#123;self(), file:read_file(Full)&#125;; &#123;Client, &#123;put_file, File, String&#125;&#125; -&gt; Full = filename:join(Dir,File), Client ! &#123;self(), file:write_file(Full,String,[append])&#125; end, loop(Dir). 不停循环监听消息。这里按客户端的消息分为3类：接收到客户端ls后发送的消息之后向其发送file:list_dir(Dir)作为结果。其余的则是发送相应处理结果后的返回值，一般就是成功或者失败。大概长这样： code","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"erlang","slug":"erlang","permalink":"http://gloriaswaterpool.com/tags/erlang/"}]},{"title":"学习一个vulkan(6)-画个三角形(显示)-Window surface","slug":"学习一个vulkan-6-画个三角形-显示-Window-surface","date":"2018-11-03T01:35:05.000Z","updated":"2022-07-23T03:12:46.259Z","comments":true,"path":"2018/11/03/学习一个vulkan-6-画个三角形-显示-Window-surface/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/03/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-6-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%98%BE%E7%A4%BA-Window-surface/","excerpt":"继续上一次的","text":"继续上一次的 由于Vulkan是一个与平台特性无关联的API集合，不能直接与窗口系统进行交互。为了在Vulkan和窗口系统之间建立连接来显示结果，这里需要WSI（窗口系统集成）扩展。在本章中将讨论其中的第一个，即VK_KHR_surface。它使用VkSurfaceKHR对象，这个对象是一个表示呈现渲染图像surface的抽象类型。本程序中的surface将由使用GLFW打开的窗口来支持。 VK_KHR_surface扩展是一个实例级扩展，我们实际上在之前已经启用了它，因为它包含在glfwGetRequiredInstanceExtensions返回的列表中了，该列表还包括我们将在接下来的几章中使用的一些其他WSI扩展。 窗口surface需要在实例创建后创建，因为它实际上可以影响物理设备的选择。现在才说这个是因为这个主题太大了，之前说可能引起混乱。值得注意的是，如果不需要屏幕渲染的话，窗口surface在vulkan中是完全可选的。Vulkan允许这样做，不需要同OpenGL一样必须要创建窗体。 创建窗体surface在callback成员下面添加一个新的成员变量： 1VkSurfaceKHR surface; 虽然VkSurfaceKHR对象及其用法与平台无关，但创建过程需要依赖具体的窗体系统的细节。例如在Windows中就需要需要HWND和HMODULE句柄。因此针对特定平台会提供相应的扩展，在Windows上为VK_KHR_win32_surface，它自动包含在glfwGetRequiredInstanceExtensions列表中。 我将演示如何使用这个特定于平台的扩展在Windows上的创建方法，但是并不会在这个程序中使用。使用像GLFW这样的库然后继续使用特定于平台的代码是没有意义的。GLFW实际上有glfwCreateWindowSurface来处理平台之间的差异，不过在使用他之前，还是要知道背后的原理。 因为窗口surface 是Vulkan对象，所以它也需要一个填充好的VkWin32SurfaceCreateInfoKHR结构来构建。它有两个重要参数：hwnd和hinstance，分别是窗口和进程的句柄： 1234VkWin32SurfaceCreateInfoKHR createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;createInfo.hwnd = glfwGetWin32Window(window);createInfo.hinstance = GetModuleHandle(nullptr); glfwGetWin32Window函数用于从GLFW窗口对象获取原始HWND,GetModuleHandle返回当前进程的HINSTANCE句柄。 之后就可以使用VkWin32SurfaceCreateInfoKHR来创建，同样需要显示加载。调用很简单，参数分别是实例，surface的创建细节，自定义分配器和要存储的surface句柄的变量： 12345auto CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) vkGetInstanceProcAddr(instance, &quot;vkCreateWin32SurfaceKHR&quot;);if (!CreateWin32SurfaceKHR || CreateWin32SurfaceKHR(instance, &amp;createInfo, nullptr, &amp;surface) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create window surface!&quot;);&#125; 这个过程在Linux等其他平台也是类似的，使用X11界面窗体系统，可以通过vkCreateXcbSurfaceKHR函数建立连接。 glfwCreateWindowSurface函数正好可以实现这种操作，并在每个平台下执行不同的实现，我们现在将它集成到我们的程序中，在initVulkan中添加createSurface函数，在setupDebugCallback后面调用： 1234567891011void initVulkan() &#123; createInstance(); setupDebugCallback(); createSurface(); pickPhysicalDevice(); createLogicalDevice();&#125;void createSurface() &#123;&#125; GLFW的调用采用简单的参数而不是结构，这使得函数的使用非常简单： 12345void createSurface() &#123; if (glfwCreateWindowSurface(instance, window, nullptr, &amp;surface) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create window surface!&quot;); &#125;&#125; 参数分别是VkInstance，GLFW窗口指针，自定义分配器和指向VkSurfaceKHR类型的指针变量。它只是通过相关平台传递调用VkResult。GLFW不提供清理surface的相关功能，可以通过原始API轻松完成： 123456void cleanup() &#123; ... vkDestroySurfaceKHR(instance, surface, nullptr); vkDestroyInstance(instance, nullptr); ...&#125; 确保在销毁实例之前销毁surface 查询显示（presentation）支持虽然Vulkan支持窗口系统集成的功能，但这不代表系统中的设备都支持。因此，我们需要扩展isDeviceSuitable以确保设备可以将图像呈现给我们创建的surface。由于显示是专用队列（queue-specific）的功能，问题就变成了找到一个支持在surface上进行显示功能的队列簇。 支持绘图命令的队列簇和支持显示的队列簇可能不是一个，考虑到可能存在的不同的表示队列，所以需要对QueueFamilyIndices结构进行修改： 12345678struct QueueFamilyIndices &#123; std::optional&lt;uint32_t&gt; graphicsFamily; std::optional&lt;uint32_t&gt; presentFamily; bool isComplete() &#123; return graphicsFamily.has_value() &amp;&amp; presentFamily.has_value(); &#125;&#125;; 接下来，需要修改find​​QueueFamilies函数来查找具有在窗口surface进行显示功能的队列簇。相关的查找函数是vkGetPhysicalDeviceSurfaceSupportKHR，参数分别是物理设备，队列簇索引和surface。将这个函数添加到VK_QUEUE_GRAPHICS_BIT所在的循环体中： 12VkBool32 presentSupport = false;vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &amp;presentSupport); 之后需检查返回的布尔值并存储显示功能队列簇的索引： 123if (queueFamily.queueCount &gt; 0 &amp;&amp; presentSupport) &#123; indices.presentFamily = i;&#125; 值得注意的，支持绘图命令的队列簇和支持显示的队列簇可能是相同的队列簇，在程序中这两种情况会有统一的处理方式（当成不同的队列簇）。不过，可以添加逻辑来优先选择同时支持这两个功能的物理设备以提高性能。 创建显示队列现在要做的就是修改逻辑设备的创建过程，创建显示队列并获取VkQueue句柄，添加句柄成员变量： 1VkQueue presentQueue; 接下来，我们需要多个VkDeviceQueueCreateInfo结构来创建不同功能的队列。一个优雅的方式是set集合来保存需要的所有队列簇，这样就可以保证唯一性了: 123456789101112131415161718#include &lt;set&gt;...QueueFamilyIndices indices = findQueueFamilies(physicalDevice);std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;std::set&lt;uint32_t&gt; uniqueQueueFamilies = &#123;indices.graphicsFamily.value(), indices.presentFamily.value()&#125;;float queuePriority = 1.0f;for (uint32_t queueFamily : uniqueQueueFamilies) &#123; VkDeviceQueueCreateInfo queueCreateInfo = &#123;&#125;; queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; queueCreateInfo.queueFamilyIndex = queueFamily; queueCreateInfo.queueCount = 1; queueCreateInfo.pQueuePriorities = &amp;queuePriority; queueCreateInfos.push_back(queueCreateInfo);&#125; 同时还需要修改VkDeviceCreateInfo指向的队列集合： 12createInfo.queueCreateInfoCount = static_cast&lt;uint32_t&gt;(queueCreateInfos.size());createInfo.pQueueCreateInfos = queueCreateInfos.data(); 如果队列簇相同，那么我们只需要传递一次索引。最后，添加一个函数来检索队列句柄： 1vkGetDeviceQueue(device, indices.presentFamily.value(), 0, &amp;presentQueue); 如果队列簇相同，则两个句柄很可能具有相同的值。在下一章中，我们将讨论交换链以及如何使用他来在surface上呈现图像。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(5)-画个三角形(构建)-逻辑设备和队列","slug":"学习一个vulkan-5-画个三角形-构建-逻辑设备和队列","date":"2018-11-02T01:19:22.000Z","updated":"2022-07-23T03:12:46.259Z","comments":true,"path":"2018/11/02/学习一个vulkan-5-画个三角形-构建-逻辑设备和队列/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/02/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-5-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9E%84%E5%BB%BA-%E9%80%BB%E8%BE%91%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97/","excerpt":"继续上一次的","text":"继续上一次的 介绍选择好了要使用的物理设备后，现在需要设置一个逻辑设备和他对接。逻辑设备的创建过程和实例的创建类似，同样需要描述想要使用的功能。这里还需要指定现在要创建的队列，不过在之前​​已经查询过了哪些队列系列可用。如果有不同的需求，也可以从同一物理设备创建多个逻辑设备。 首先添加一个新的类成员来存储逻辑设备句柄。 1VkDevice device; 接下来，在initVulkan添加createLogicalDevice函数： 12345678910void initVulkan() &#123; createInstance(); setupDebugCallback(); pickPhysicalDevice(); createLogicalDevice();&#125;void createLogicalDevice() &#123;&#125; 指定要创建的队列创建逻辑设备同样需要在结构中设定一堆细节，第一个需要知道的就是VkDeviceQueueCreateInfo了。这个结构描述了单个队列簇所需的队列数目。目前只需要具有图形功能的相关队列： 123456QueueFamilyIndices indices = findQueueFamilies(physicalDevice);VkDeviceQueueCreateInfo queueCreateInfo = &#123;&#125;;queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;queueCreateInfo.queueFamilyIndex = indices.graphicsFamily.value();queueCreateInfo.queueCount = 1; 当前可用的驱动程序只允许在每个队列簇中创建少量队列，虽然现在也并不不需要多个队列。这是因为可以在多个线程上创建所有的命令缓冲，然后使用一个低开销的调用在主线程上一次性提交。 Vulkan允许为队列分配优先级，使用介于0.0和1.0之间的浮点数来影响命令缓冲区执行的调度顺序。即使只有一个队列，也必需要设置的： 12float queuePriority = 1.0f;queueCreateInfo.pQueuePriorities = &amp;queuePriority; 指定使用的设备功能第二个需要设定的是我们将要使用的设备的功能，这个就是之前已经使用vkPhysicalDevice查询过的支持的功能，比如几何着色器。所以这里不需要另外指定什么，简单定义一下就行，其他的就自动变成VK_FALSE了，同样，之后添加更多Vulkan功能时会回到这里进行更改。 1VkPhysicalDeviceFeatures deviceFeatures = &#123;&#125;; 创建逻辑设备有了前两个结构之后，现在可以用来填充VkDeviceCreateInfo结构了： 12VkDeviceCreateInfo createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; 首先添加指向队列创建信息和设备功能结构的指针： 1234createInfo.pQueueCreateInfos = &amp;queueCreateInfo;createInfo.queueCreateInfoCount = 1;createInfo.pEnabledFeatures = &amp;deviceFeatures; 其余信息与VkInstanceCreateInfo结构相似，需要指定扩展和验证层，不同之处在于这次指定的是针对于设备的。 举个例子，有一个针对设备的扩展是VK_KHR_swapchain，它允许将该设备的渲染图像呈现给窗口。系统中可能存在只支持计算而缺乏这个功能的Vulkan设备。之后将在交换链的章节讨论这个扩展。 如验证层的章节中所说的一样，这里会为设备启用与实例相同的验证层。暂时不需要任何特定于设备的扩展： 12345678createInfo.enabledExtensionCount = 0;if (enableValidationLayers) &#123; createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data();&#125; else &#123; createInfo.enabledLayerCount = 0;&#125; 现在可以通过vkCreateDevice来实例化逻辑设备了： 123if (vkCreateDevice(physicalDevice, &amp;createInfo, nullptr, &amp;device) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create logical device!&quot;);&#125; 参数分别是和他接口的物理设备，刚才填充的队列和使用信息，一个可选的分配回调指针和指向存储逻辑设备句柄的指针。与创建实例的函数类似，这个函数也会由于启用了不存在的扩展或指定了不支持的功能的返回错误信息。 最后同样需要在cleanup函数中添加清理方法vkDestroyDevice： 1234void cleanup() &#123; vkDestroyDevice(device, nullptr); ...&#125; 逻辑设备不直接与实例交互，所以参数里没有它。 检索队列句柄队列将会和逻辑设备一同被创建，但是现在还没有与之相对应的接口句柄，首先添加一个类成员来存储图形队列的句柄： 1VkQueue graphicsQueue; 当设备被销毁时，会隐式清除设备队列，所以并不需要在cleanup中添加什么 可以使用vkGetDeviceQueue函数来检索每个队列系列的队列句柄，参数分别是逻辑设备，队列簇，队列索引和指向存储队列句柄的指针。因为我们只是从这个簇中创建了一个队列，所以用索引0就行了： 1vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &amp;graphicsQueue); 有了逻辑设备和队列句柄，现在终于可以开始使用显卡了，在接下来的几章中，我们将设置资源以向窗口系统进行显示。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(4)-画个三角形(构建)-物理设备和队列簇","slug":"学习一个vulkan-4-画个三角形-构建-物理设备和队列簇","date":"2018-11-01T01:49:28.000Z","updated":"2022-07-23T03:12:46.259Z","comments":true,"path":"2018/11/01/学习一个vulkan-4-画个三角形-构建-物理设备和队列簇/","link":"","permalink":"http://gloriaswaterpool.com/2018/11/01/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-4-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9E%84%E5%BB%BA-%E7%89%A9%E7%90%86%E8%AE%BE%E5%A4%87%E5%92%8C%E9%98%9F%E5%88%97%E7%B0%87/","excerpt":"继续上一次的","text":"继续上一次的 选择物理设备在通过VkInstance初始化Vulkan库之后，我们需要在系统中查找并选择支持我们所需功能的显卡，事实上，我们可以选择任意数量的显卡并同时使用它们，但在本教程中，将使用第一个适合需求的显卡。添加一个函数pickPhysicalDevice并在initVulkan函数中添加对它的调用： 123456789void initVulkan() &#123; createInstance(); setupDebugCallback(); pickPhysicalDevice();&#125;void pickPhysicalDevice() &#123;&#125; 我们最终选择的显卡设备将存储在VkPhysicalDevice类型的新成员中。当VkInstance被销毁时，该对象将被隐式销毁，因此不需要在cleanup函数中做任何新的操作。 1VkPhysicalDevice physicalDevice = VK_NULL_HANDLE; 查询显卡和查询扩展类似，首先需要查找设备的数目。 12uint32_t deviceCount = 0;vkEnumeratePhysicalDevices(instance, &amp;deviceCount, nullptr); 如果没有设备（0个）支持Vulkan的话，就没有必要进行之后的工作了： 123if (deviceCount == 0) &#123; throw std::runtime_error(&quot;failed to find GPUs with Vulkan support!&quot;);&#125; 否则,分配一个数组来保存所有VkPhysicalDevice句柄： 12std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount);vkEnumeratePhysicalDevices(instance, &amp;deviceCount, devices.data()); 现在需要检查每一个是否适合我们想要执行的操作，因为并非所有的显卡都是相同的。为此，需要一个新功能： 123bool isDeviceSuitable(VkPhysicalDevice device) &#123; return true;&#125; 这里将检查是否有物理设备符合我们的需要的功能： 12345678910for (const auto&amp; device : devices) &#123; if (isDeviceSuitable(device)) &#123; physicalDevice = device; break; &#125;&#125;if (physicalDevice == VK_NULL_HANDLE) &#123; throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;);&#125; 下一节将介绍我们将在isDeviceSuitable函数中检查的第一个要求。随着之后使用更多Vulkan功能后，也会在这里添加更多检查。 基础设备适用性检查为了评估设备的适用性，我们可以通过查询一些细节来开始，可以使用vkGetPhysicalDeviceProperties查询基本设备属性，如名称，类型和支持的Vulkan版本： 12VkPhysicalDeviceProperties deviceProperties;vkGetPhysicalDeviceProperties(device, &amp;deviceProperties); 可以使用vkGetPhysicalDeviceFeatures查询对纹理压缩，64位浮点和多视口渲染（对VR有用）等可选功能的支持： 12VkPhysicalDeviceFeatures deviceFeatures;vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures); 当然也有更多的细节可以查询到，这些将在之后讨论设备内存和队列的时候谈到。 举个例子，假设我们认为我们的应用程序仅适用于支持几何着色器的独立显卡，那么isDeviceSuitable函数将如下所示： 123456789bool isDeviceSuitable(VkPhysicalDevice device) &#123; VkPhysicalDeviceProperties deviceProperties; VkPhysicalDeviceFeatures deviceFeatures; vkGetPhysicalDeviceProperties(device, &amp;deviceProperties); vkGetPhysicalDeviceFeatures(device, &amp;deviceFeatures); return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &amp;&amp; deviceFeatures.geometryShader;&#125; 除了仅仅挑选第一个适合的设备之外，也可以对每一个设备打一个分数然后挑选最高的一个，这样做的话，可以给独立显卡赋予一个更高的分数，如果没有的话，就会挑选到集成显卡上了。实现起来大概是这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;map&gt;...void pickPhysicalDevice() &#123; ... // Use an ordered map to automatically sort candidates by increasing score std::multimap&lt;int, VkPhysicalDevice&gt; candidates; for (const auto&amp; device : devices) &#123; int score = rateDeviceSuitability(device); candidates.insert(std::make_pair(score, device)); &#125; // Check if the best candidate is suitable at all if (candidates.rbegin()-&gt;first &gt; 0) &#123; physicalDevice = candidates.rbegin()-&gt;second; &#125; else &#123; throw std::runtime_error(&quot;failed to find a suitable GPU!&quot;); &#125;&#125;int rateDeviceSuitability(VkPhysicalDevice device) &#123; ... int score = 0; // Discrete GPUs have a significant performance advantage if (deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) &#123; score += 1000; &#125; // Maximum possible size of textures affects graphics quality score += deviceProperties.limits.maxImageDimension2D; // Application can&#x27;t function without geometry shaders if (!deviceFeatures.geometryShader) &#123; return 0; &#125; return score;&#125; 这些其实并不需要全部实现，只是为了更加了解如何设计设备的选择功能。当然，也可以列出相应的名称让用户来选择。 因为这里才刚刚起步，Vulkan支持是当前唯一的需求，所以现在任何GPU都可行： 123bool isDeviceSuitable(VkPhysicalDevice device) &#123; return true;&#125; 在下一节中，我们将讨论要检查的第一个真正需要的功能。 队列簇（Queue families）之前简要介绍过Vulkan中的几乎所有操作，从绘图到上传纹理，都需要将相关的命令提交到队列。不同的队列簇都会有各种不同类型的队列，而且一个队列中只支持一个命令中的一个子集。举个例子，一个队列簇要不就只能处理计算命令，要不就只能处理内存传输相关命令。 我们需要检查设备支持哪些队列簇，以及哪一个支持我们要使用的命令。因此，为此，我们将添加一个新函数findQueueFamilies，用于查找我们需要的所有队列簇。现在只需要查找支持图形命令的队列，在之后可能会扩展此功能以便在查找更多内容。 此函数将返回满足某些所需属性的队列系列的索引。最好的方法是使用一个结构，可以使用std :: optional来跟踪是否找到了索引： 1234567struct QueueFamilyIndices &#123; std::optional&lt;uint32_t&gt; graphicsFamily; bool isComplete() &#123; return graphicsFamily.has_value(); &#125;&#125;; 这里需要#include ，现在可以实现findQueueFamilies了： 1234567QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) &#123; QueueFamilyIndices indices; ... return indices;&#125; 队列的查找还是和之前一样，这里使用vkGetPhysicalDeviceQueueFamilyProperties： 12345uint32_t queueFamilyCount = 0;vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, nullptr);std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);vkGetPhysicalDeviceQueueFamilyProperties(device, &amp;queueFamilyCount, queueFamilies.data()); VkQueueFamilyProperties结构包含有关队列簇的一些详细信息，包括支持的操作类型以及可以基于该系列创建的队列数目。我们需要找到至少一个支持VK_QUEUE_GRAPHICS_BIT的队列簇： 123456789101112int i = 0;for (const auto&amp; queueFamily : queueFamilies) &#123; if (queueFamily.queueCount &gt; 0 &amp;&amp; queueFamily.queueFlags &amp; VK_QUEUE_GRAPHICS_BIT) &#123; indices.graphicsFamily = i; &#125; if (indices.isComplete()) &#123; break; &#125; i++;&#125; 这个函数实现完毕了，我们可以将它用于isDeviceSuitable函数中，来确保设备可以处理我们想要使用的命令： 12345bool isDeviceSuitable(VkPhysicalDevice device) &#123; QueueFamilyIndices indices = findQueueFamilies(device); return indices.isComplete();&#125; 找到了合适的物理设备之后，下一步就是创建一个对应的逻辑设备了。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(3)-画个三角形(构建)-验证层","slug":"学习一个vulkan-3-画个三角形-构建-验证层","date":"2018-10-31T07:04:41.000Z","updated":"2022-07-23T03:12:46.228Z","comments":true,"path":"2018/10/31/学习一个vulkan-3-画个三角形-构建-验证层/","link":"","permalink":"http://gloriaswaterpool.com/2018/10/31/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-3-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9E%84%E5%BB%BA-%E9%AA%8C%E8%AF%81%E5%B1%82/","excerpt":"继续上一次的","text":"继续上一次的 有关验证层Vulkan API设计的初衷是让相关的驱动程序开销最小，为了达到这个目标，对API的错误检查的部分就十分有限了即使是将枚举设置为不正确的值或将空指针传递给所需参数这样简单的错误通常也不会被显式处理，只会导致崩溃或未定义的行为由于Vulkan要求对所做的一切都非常了解，所以很容易犯很多小错误，比如使用新的GPU功能而忘记在逻辑设备创建时请求但是，这并不意味着无法将这些错误检查添加到API中 Vulkan使用了叫做验证层的方式来实现，验证层是可选的组件，它钩（hook）到Vulkan其他的函数上来实现额外的操作常见操作如下： 根据规范检查参数值以检测是否误用 跟踪对象的创建和销毁以检测资源泄漏 通过跟踪调用父线程来检查线程安全性 将每个调用及其参数记录到标准输出 跟踪Vulkan的函数调用进行性能分析和重现下面是一个验证层中函数实现的示例：123456789101112VkResult vkCreateInstance( const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* instance) &#123; if (pCreateInfo == nullptr || instance == nullptr) &#123; log(&quot;Null pointer passed to required parameter!&quot;); return VK_ERROR_INITIALIZATION_FAILED; &#125; return real_vkCreateInstance(pCreateInfo, pAllocator, instance);&#125; 这些验证层可以自由堆叠所有你想用到的各种功能，也可以只为调试版本启用验证层，并在发布版本完全禁用它们Vulkan没有内置任何验证层，但是LunarG Vulkan SDK提供了一组很好的层来检查常见错误。它们也是完全开源的，因此可以自由查看相关代码的功能以及贡献代码使用验证层是避免应用程序由于未定义的行为在不同驱动程序上崩溃的最佳方法了 验证层只有在已安装到系统上时才能使用，例如，LunarG的验证层仅适用于安装了Vulkan SDK的PC以前在Vulkan里有两种不同类型的验证层，实例（instance）和特定设备（device specific）的这个想法是实例层只会检查与实例等全局Vulkan对象相关的调用，特定设备的层只会检查与特定GPU相关的调用现在已弃用特定设备的层，这意味着实例验证层适用于所有Vulkan调用。 规范文档仍然建议在设备级别启用验证层以及实现某些功能所需的兼容性设置，这只需要在逻辑设备级别指定与实例相同的层，之后就会看到如何实现这一点 使用验证层在本节中，将了解如何启用Vulkan SDK提供的标准诊断层。就像扩展一样，需要通过指定其名称来启用验证层。SDK不需要显式指定所有有用的层，直接使用VK_LAYER_LUNARG_standard_validation层就可以隐式的启用一系列有用的诊断层了 首先向程序添加两个用来配置的变量，以指定要启用的层以及是否启用它们。这里选择将该值仅仅在程序在调试模式下编译使用为true，NDEBUG宏是C ++标准的一部分，意味着“不调试” 123456789101112const int WIDTH = 800;const int HEIGHT = 600;const std::vector&lt;const char*&gt; validationLayers = &#123; &quot;VK_LAYER_LUNARG_standard_validation&quot;&#125;;#ifdef NDEBUG const bool enableValidationLayers = false;#else const bool enableValidationLayers = true;#endif 之后添加一个新函数checkValidationLayerSupport，用于检查所有请求的层是否都可用首先使用vkEnumerateInstanceLayerProperties函数列出所有可用图层，它的用法与之前说到的vkEnumerateInstanceExtensionProperties的用法相同。 123456789bool checkValidationLayerSupport() &#123; uint32_t layerCount; vkEnumerateInstanceLayerProperties(&amp;layerCount, nullptr); std::vector&lt;VkLayerProperties&gt; availableLayers(layerCount); vkEnumerateInstanceLayerProperties(&amp;layerCount, availableLayers.data()); return false;&#125; 接下来，检查验证层中的所有图层是否都存在于可用的pLayers列表中，这里的strcmp函数需要#include 。 12345678910111213141516for (const char* layerName : validationLayers) &#123; bool layerFound = false; for (const auto&amp; layerProperties : availableLayers) &#123; if (strcmp(layerName, layerProperties.layerName) == 0) &#123; layerFound = true; break; &#125; &#125; if (!layerFound) &#123; return false; &#125;&#125;return true; 现在将这个函数添加到createInstance里： 1234567void createInstance() &#123; if (enableValidationLayers &amp;&amp; !checkValidationLayerSupport()) &#123; throw std::runtime_error(&quot;validation layers requested, but not available!&quot;); &#125; ...&#125; 现在以调试模式运行程序并确保不会发生错误，如果有错误，检查是否正确安装了Vulkan SDK。如果没有显示任何图层，或者显示的极少，或许是碰到了这个问题，可以按照他的方法来修正 最后，修改VkInstanceCreateInfo结构的实例化来包含验证层： 123456if (enableValidationLayers) &#123; createInfo.enabledLayerCount = static_cast&lt;uint32_t&gt;(validationLayers.size()); createInfo.ppEnabledLayerNames = validationLayers.data();&#125; else &#123; createInfo.enabledLayerCount = 0;&#125; 如果检查成功，那么vkCreateInstance就不会返回VK_ERROR_LAYER_NOT_PRESENT，但是最好还是运行一下来确保正确 消息回调不幸的是，只是启用图层并没有多大是的帮助，因为他们目前无法将调试消息返回我们的程序。要接收这些消息，需要设置一个回调，这里需要VK_EXT_debug_utils扩展。首先创建一个getRequiredExtensions函数，该函数将根据是否启用验证层返回所需的扩展列表： 12345678910111213std::vector&lt;const char*&gt; getRequiredExtensions() &#123; uint32_t glfwExtensionCount = 0; const char** glfwExtensions; glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount); std::vector&lt;const char*&gt; extensions(glfwExtensions, glfwExtensions + glfwExtensionCount); if (enableValidationLayers) &#123; extensions.push_back(VK_EXT_DEBUG_UTILS_EXTENSION_NAME); &#125; return extensions;&#125; GLFW指定的扩展始终是必需的，但调试报告扩展可以根据条件来添加。注意在这里使用了VK_EXT_DEBUG_UTILS_EXTENSION_NAME宏，这个和文字字符串“VK_EXT_debug_utils”是一样的，但是使用这个宏可以避免拼写错误。 现在可以在createInstance中使用此函数了： 123auto extensions = getRequiredExtensions();createInfo.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());createInfo.ppEnabledExtensionNames = extensions.data(); 运行该程序来确保没有VK_ERROR_EXTENSION_NOT_PRESENT错误。实际上不需要检查此扩展的存在，因为这个在验证层的可用性检查时已经包含了。 现在来实现一下回调函数，使用PFN_vkDebugUtilsMessengerCallbackEXT原型来添加一个名为debugCallback的新静态成员函数，VKAPI_ATTR和VKAPI_CALL确保这个函数具有正确的签名可以让Vulkan来调用它。 12345678910static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback( VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData, void* pUserData) &#123; std::cerr &lt;&lt; &quot;validation layer: &quot; &lt;&lt; pCallbackData-&gt;pMessage &lt;&lt; std::endl; return VK_FALSE;&#125; 第一个参数表示消息的严重性，它可以是以下几个标志之一： VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT：诊断消息 VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT：信息性消息，如创建资源 VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT：有关行为的消息，不一定是错误（error），但很可能是某个的错误（bug，这个实在不知道怎么表达区别了） VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT：有关无效行为的消息，可能导致崩溃这个枚举的值的设置方式让我们可以使用比较操作来检查消息是否与某个严重级别相等或更差，例如：123if (messageSeverity &gt;= VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) &#123; // Message is important enough to show&#125; messageType参数可以是以下几个标志之一： VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT：发生了一些与规范或性能无关的事件 VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT：发生了违反规范或表明可能存在错误的事情 VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT：Vulkan的潜在非最佳使用pCallbackData参数是一个VkDebugUtilsMessengerCallbackDataEXT结构，其中包含消息本身的详细信息，比较重要的成员有以下几个： pMessage：以null结尾的调试消息字符串 pObjects：与消息相关的Vulkan对象句柄的数组 objectCount：数组中的对象个数最后，pUserData参数是一个在回调设置期间指定的指针，并允许将自身的数据传递给它。 回调函数返回一个布尔值，指示是否应该中止触发验证层消息的Vulkan调用。如果回调返回true，则调用将因VK_ERROR_VALIDATION_FAILED_EXT错误而中止，这个通常仅用于测试验证层本身，所以应始终返回VK_FALSE。 现在剩下的就是把回调函数告知Vulkan了。有些令人惊讶的是，Vulkan中的调试回调也是通过需要显式创建和销毁的句柄来管理的。这样的回调称为信使（messenger），可以根据需要随意添加。在instance下面添加这个句柄的类成员： 1VkDebugUtilsMessengerEXT callback; 添加函数setupDebugCallback，在initVulkan中的createInstance之后调用： 123456789void initVulkan() &#123; createInstance(); setupDebugCallback();&#125;void setupDebugCallback() &#123; if (!enableValidationLayers) return;&#125; 接下来使用回调的相关信息来填充一个结构： 123456VkDebugUtilsMessengerCreateInfoEXT createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT;createInfo.messageSeverity = VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT;createInfo.messageType = VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT | VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT;createInfo.pfnUserCallback = debugCallback;createInfo.pUserData = nullptr; // Optional messageSeverity字段指定要为其调用回调的所有类型的严重性。这里设定为除了VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT之外的所有类型，来接收有关可能出现的问题的通知，同时省略大量的一般调试信息。messageType字段设置通知回调的消息类型。在这里启用了所有类型，可以根据实际情况随时禁用它们。最后，pfnUserCallback字段指定回调函数的指针。同时可以选择将指针传递给pUserData字段，该字段将通过pUserData参数传递给回调函数。例如，可以使用它来传递指向HelloTriangleApplication类的指针。 注意，有许多方法可以配置验证层消息和调试回调，但这里说明的只是入门的一个很好的配置。如果想了解更多相关信息，可以参阅这里 这时候将这个结构传递给vkCreateDebugUtilsMessengerEXT函数来创建VkDebugUtilsMessengerEXT对象。不幸的是，因为此函数是扩展函数，所以它不会自动加载。这里还必须使用vkGetInstanceProcAddr查找其地址，我们将创建自己的代理函数，在后台处理它，这里将它添加到HelloTriangleApplication类定义的正上方： 12345678VkResult CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pCallback) &#123; auto func = (PFN_vkCreateDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkCreateDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; return func(instance, pCreateInfo, pAllocator, pCallback); &#125; else &#123; return VK_ERROR_EXTENSION_NOT_PRESENT; &#125;&#125; 如果无法加载函数，vkGetInstanceProcAddr将返回nullptr。我们现在可以调用这个函数来创建扩展对象（如果可用）： 123if (CreateDebugUtilsMessengerEXT(instance, &amp;createInfo, nullptr, &amp;callback) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to set up debug callback!&quot;);&#125; 倒数第二个参数同样也是可选的分配器回调指针，设为nullptr就行，其他参数就很直接了。由于调试回调函数是根据特定Vulkan实例及其层来选择的，因此需要将其明确指定为第一个参数，在之后还能看到其他相关的子对象。现在可以观察这样是否有效了。运行程序并关闭窗口可以看到以下消息打印到命令提示符： 现在就已经有个错误了。需要通过调用vkDestroyDebugUtilsMessengerEXT来清理VkDebugUtilsMessengerEXT对象，与vkCreateDebugUtilsMessengerEXT类似，这个函数也需要显式加载注意，此消息多次打印是正常的。发生这种情况是因为多个验证层都检查到了调试信使的缺失。 在CreateDebugUtilsMessengerEXT下创建另一个代理函数： 123456void DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT callback, const VkAllocationCallbacks* pAllocator) &#123; auto func = (PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(instance, &quot;vkDestroyDebugUtilsMessengerEXT&quot;); if (func != nullptr) &#123; func(instance, callback, pAllocator); &#125;&#125; 确保这个函数是静态类函数或类外的函数。然后我们可以在cleanup函数中调用它： 1234567891011void cleanup() &#123; if (enableValidationLayers) &#123; DestroyDebugUtilsMessengerEXT(instance, callback, nullptr); &#125; vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate();&#125; 当再次运行该程序时，可以将看到错误消息没有了。如果要查看哪个调用触发了消息，可以在消息回调中添加断点并查看堆栈并跟踪调试。 布局除了VkDebugUtilsMessengerCreateInfoEXT结构中指定的标志，验证层还有很多设置。浏览到Vulkan SDK的Config目录。在那里，可以将找到一个vk_layer_settings.txt文件，该文件解释了如何配置图层。要为自己的应用程序配置图层设置，请将该文件复制到项目的“Debug”和“Release”目录中，然后按照说明设置所需的配置。但是对于本教程的后文讲直接采用默认的配置。在本教程中，将做一些故意的错误，用来展示验证层对捕获它们的巨大帮助，并明确的解释正在使用Vulkan做的事情。下一部分将查看系统中的Vulkan设备了。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(2)-画个三角形(构建)-实例","slug":"学习一个vulkan-2-画个三角形-构建-实例","date":"2018-10-30T07:08:16.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/10/30/学习一个vulkan-2-画个三角形-构建-实例/","link":"","permalink":"http://gloriaswaterpool.com/2018/10/30/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-2-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9E%84%E5%BB%BA-%E5%AE%9E%E4%BE%8B/","excerpt":"继续上一次的","text":"继续上一次的 创建一个实例最开始需要做的事是通过创建实例（initialize）来初始化Vulkan库。这个实例是应用程序与Vulkan库之间联系，创建它的时候需要向驱动程序指定一些有关应用程序的详细信息。首先在initVulkan里添加一个createInstance函数 123void initVulkan() &#123; createInstance();&#125; 同时还要添加一个类成员来保存实例的句柄： 12private:VkInstance instance; 为了创建这个实例，必须用一些应用程序的信息来填充相关结构，这个过程当然也可以不做，但是明确的提供了特定的信息时候，我们也能对这个特定的程序进行优化，就像某些有特殊功能的图形引擎一样。这个用来填充的结构叫做VkApplicationInfo： 1234567VkApplicationInfo appInfo = &#123;&#125;;appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;appInfo.pApplicationName = &quot;Hello Triangle&quot;;appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);appInfo.pEngineName = &quot;No Engine&quot;;appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);appInfo.apiVersion = VK_API_VERSION_1_0; Vulkan中的许多结构都需要在sType成员中明确的说明其类型，上面这个也是其中一个，同时他也有一个pNext成员用来指向扩展的信息，这个在以后会说明这里用默认的就行，会自动设置为nullptrVulkan中的很多信息都是通过结构而不是函数参数传递的，我们必须填充结构来为创建实例提供足够的信息。之后的这个结构是必须要的，它告诉Vulkan驱动程序我们想要使用哪些全局扩展和验证层。全局在这里意味着它们适用于整个程序 123VkInstanceCreateInfo createInfo = &#123;&#125;;createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;createInfo.pApplicationInfo = &amp;appInfo; 这两个参数很简单，一看就知道了。下面的两个会用来明确的指向需要的全局扩展。Vulkan是一个与平台无关的API，这意味着需要一个扩展接口与窗口系统联系。GLFW有一个方便的内置函数可以直接返回需要的扩展，可以把这个扩展传递给结构： 12345uint32_t glfwExtensionCount = 0;const char** glfwExtensions;glfwExtensions = glfwGetRequiredInstanceExtensions(&amp;glfwExtensionCount);createInfo.enabledExtensionCount = glfwExtensionCount;createInfo.ppEnabledExtensionNames = glfwExtensions; 结构的最后两个成员用来确定要启用的全局验证层，之后在讨论个问题，这里先简单的留空就行： 1createInfo.enabledLayerCount = 0; 现在已经完成了构建这个实例需要的东西，现在可以进行vkCreateInstance的调用了： 1VkResult result = vkCreateInstance(&amp;createInfo, nullptr, &amp;instance); 简单看来，构建Vulkan对象的三个参数一般如下：1、指向有构建信息的指针（createInfo）2、自定义分配器的回调指针，一般就设为nullptr3、指向存储新对象句柄的变量的指针（instance）如果一切顺利，那么实例的句柄就会存储在VkInstance类成员中。基本上所有Vulkan函数都返回VkResult类型的值，即VK_SUCCESS或错误代码。要检查实例是否已成功创建，我们不需要存储结果，只需检查返回的值： 123if (vkCreateInstance(&amp;createInfo, nullptr, &amp;instance) != VK_SUCCESS) &#123; throw std::runtime_error(&quot;failed to create instance!&quot;);&#125; 现在可以运行该程序来确认是否无误了。 检查扩展的支持如果查看vkCreateInstance的文档，可以看到其中一个可能的错误代码是VK_ERROR_EXTENSION_NOT_PRESENT如果出现这个错误的话，可以的手动指定需要的扩展，这对于窗口系统界面等基本扩展很有意义如果我们想检查支持的扩展该怎么办呢？要在创建实例之前查看支持的扩展列表，可以使用vkEnumerateInstanceExtensionProperties函数。它需要一个指向扩展数量的变量的指针和一个VkExtensionProperties数组作为参数来存储扩展的详细信息，它的第一个参数是可选的，允许我们通过设定特定的验证层来过滤某些扩展，这里直接不管。要分配一个数组来保存各个扩展的细节，我们首先需要知道扩展的数目。可以通过将后一个参数留空来得到扩展的数量： 12uint32_t extensionCount = 0;vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, nullptr); 现在分配一个数组来保存扩展细节（需要#include ）： 1std::vector&lt;VkExtensionProperties&gt; extensions(extensionCount); 最终得到了相应扩展的细节： 1vkEnumerateInstanceExtensionProperties(nullptr, &amp;extensionCount, extensions.data()); 每个VkExtensionProperties结构都包含了对应扩展的名称和版本。可以用简单的for打印查看（\\t是缩进）： 12345std::cout &lt;&lt; &quot;available extensions:&quot; &lt;&lt; std::endl;for (const auto&amp; extension : extensions) &#123; std::cout &lt;&lt; &quot;\\t&quot; &lt;&lt; extension.extensionName &lt;&lt; std::endl;&#125; 如果想查看有关Vulkan支持的一些详细信息，可以将这个代码添加到createInstance函数中。作为挑战，也可以尝试创建一个函数，检查glfwGetRequiredInstanceExtensions返回的所有扩展是否都包含在支持的扩展列表中。 清理VkInstance应该在程序退出之前销毁掉，可以使用vkDestroyInstance函数在clean中销毁： 1234567void cleanup() &#123; vkDestroyInstance(instance, nullptr); glfwDestroyWindow(window); glfwTerminate();&#125; vkDestroyInstance函数的参数很简单，Vulkan中的分配和释放函数有一个可选的allocator回调，这里直接也设为nullptr不管。以后创建的所有其他Vulkan资源需要在实例销毁之前进行清理。在进行更复杂的步骤之前，需要通过检查验证层来评估调试的选项。","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"学习一个vulkan(1)-画个三角形(构建)-基础代码","slug":"学习一个vulkan-1-画个三角形-构建-基础代码","date":"2018-10-29T08:17:34.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/10/29/学习一个vulkan-1-画个三角形-构建-基础代码/","link":"","permalink":"http://gloriaswaterpool.com/2018/10/29/%E5%AD%A6%E4%B9%A0%E4%B8%80%E4%B8%AAvulkan-1-%E7%94%BB%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2-%E6%9E%84%E5%BB%BA-%E5%9F%BA%E7%A1%80%E4%BB%A3%E7%A0%81/","excerpt":"学习一个vlkan，基本就是照着教程敲了。参考这个。","text":"学习一个vlkan，基本就是照着教程敲了。参考这个。 大致结构第一步的目标就是画一个简单三角形。首先确保已经正确安装了Vulkan和GLFW。首先构造一个大概的框架，大概这样： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;vulkan/vulkan.h&gt;#include &lt;iostream&gt;#include &lt;stdexcept&gt;#include &lt;functional&gt;#include &lt;cstdlib&gt;class HelloTriangleApplication &#123;public: void run() &#123; initVulkan(); mainLoop(); cleanup(); &#125;private: void initVulkan() &#123; &#125; void mainLoop() &#123; &#125; void cleanup() &#123; &#125;&#125;;int main() &#123; HelloTriangleApplication app; try &#123; app.run(); &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; return EXIT_FAILURE; &#125; return EXIT_SUCCESS;&#125; 用到头文件的相关功能大概就是：Vulkan：这个就是学习的东西，当然是要用到的stdexcept和iostream用来打印相关信息和错误functional：用到了其中的lambda表达式cstdlib：用到了其中的EXIT_SUCCESS和EXIT_FAILURE宏这里将Vulkan的对象封装到这个类里，然后设置一个函数来初始化他们，就是initVulkan了这些都完成之后就可以进入主循环来渲染帧了可以在mainLoop中一直循环直到窗口关闭当窗口关闭之后，还需要在cleanup里清除相关用过的资源一旦在运行过程中产生任何异常都会抛出std::runtime_error的异常，之后传回main函数打印到控制台上为了捕获相对详尽的异常，这里需要使用std::exception后面有个例子就是用这个发现了有个需要的扩展不支持的错误每一次实现什么新功能后基本都会在initVulkan初始化新的对象，以及在cleanup里进行释放 资源管理就像每次使用一个内存块都需要malloc和free一样，每一个Vulkan对象在用完之后也需要被销毁现代C++中，可以通过中的各种方法来进行自动内存管理，但是在本教程中会明确的说明中的各种方法来进行自动内存管理毕竟Vulkan的宗旨就是明确自己的每一个操作来避免错误，因此最好能明确对象的生命周期来更好的了解相关API在本教程之外，可以通过重载std :: shared_ptr来实现自动的内存管理，使用RAII是实现大型Vulkan推荐的方式，但是对于学习来说，最好还是要知道背后发生的详细信息Vulkan对象可以使用vkCreateXXX这种函数直接创建，也可以通过其他具有vkAllocateXXX功能的对象进行分配，确保对象不再在任何地方使用后，您需要使用对应的vkDestroyXXX和vkFreeXXX销毁它。这些函数的参数通常因不同类型的对象而异，但是它们共享一个参数：pAllocator。这是一个可选参数，允许为自定义内存分配器指定回调。我们将在教程中忽略此参数，并始终将nullptr作为参数传递。 整合GLFW在不使用窗口，只是单单进行屏幕外渲染时，Vulkan是非常好的，但能显示当然是更好了，所以使用下文替换掉#include &lt;vulkan&#x2F;vulkan.h&gt;： 12#define GLFW_INCLUDE_VULKAN#include &lt;GLFW/glfw3.h&gt; 这样GLFW将包含自己的定义并自动加载Vulkan标头。添加一个initWindow函数，并在run函数其他调用函数之前执行他。我们将使用该函数初始化GLFW并创建一个窗口。 1234567891011void run() &#123; initWindow(); initVulkan(); mainLoop(); cleanup();&#125;private: void initWindow() &#123; &#125; initWindow中的第一个调用应该是glfwInit()，这个函数是用来初始化GLFW库的，因为GLFW最初是为创建OpenGL上下文而设计的，所以我们需要告诉它不要在后续调用中创建OpenGL上下文： 1glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); 因为处理调整大小的窗口需要特别小心，之后才会使用到，现在需要设置一下来禁用它： 1glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); 现在的就是创建真正的窗口了。添加GLFWwindow *window;存储为私有类的对象，并初始化窗口： 1window = glfwCreateWindow(800, 600, &quot;Vulkan&quot;, nullptr, nullptr); 前三个参数指定窗口的宽度，高度和标题。第四个参数选择指定监视器来打开窗口，最后一个参数与OpenGL相关，设为nullptr就行。使用常量而不是使用简单的数字来定义宽度和高度会比较好，因为之后会多次使用这些值。在HelloTriangleApplication的类定义的上面添加以下行： 12const int WIDTH = 800;const int HEIGHT = 600; 并用下文来替换之前窗口创建的方法： 1window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Vulkan&quot;, nullptr, nullptr); 现在initWindow函数应该长这样子： 12345678void initWindow() &#123; glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE); window = glfwCreateWindow(WIDTH, HEIGHT, &quot;Vulkan&quot;, nullptr, nullptr);&#125; 为了使应用程序一直运行直到发生错误或窗口关闭，我们需要向mainLoop函数添加一个事件循环，如下所示： 12345void mainLoop() &#123; while (!glfwWindowShouldClose(window)) &#123; glfwPollEvents(); &#125;&#125; 这段代码很简单的。它一直循环并检查事件，例如按下关闭的时候，直到用户关闭窗口才会停止循环。这也是我们稍后用来渲染单个帧的循环。窗口关闭后，我们需要通过销毁资源并终止GLFW来清理资源。我们的第一个清理代码如下所示： 12345void cleanup() &#123; glfwDestroyWindow(window); glfwTerminate();&#125; 现在运行该程序时，可以看到一个标题为Vulkan的窗口，在关闭窗口之前都会一直存在。现在已经构造好了Vulkan应用程序的大致框架，下一步就是创建第一个Vulkan对象了","categories":[{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"}],"tags":[{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"}]},{"title":"How to Write a Lisp Interpreter in Python(翻译)","slug":"How-to-Write-a-Lisp-Interpreter-in-Python-翻译","date":"2018-09-26T11:32:41.000Z","updated":"2022-07-23T03:12:46.197Z","comments":true,"path":"2018/09/26/How-to-Write-a-Lisp-Interpreter-in-Python-翻译/","link":"","permalink":"http://gloriaswaterpool.com/2018/09/26/How-to-Write-a-Lisp-Interpreter-in-Python-%E7%BF%BB%E8%AF%91/","excerpt":"翻译一个How to Write a (Lisp) Interpreter (in Python)原文地址-&gt;How to Write a (Lisp) Interpreter (in Python)","text":"翻译一个How to Write a (Lisp) Interpreter (in Python)原文地址-&gt;How to Write a (Lisp) Interpreter (in Python) 这边文章有两个目标，是描述如何实现一个一般程序语言的解释器，然后利用python3实现一个scheme(lisp的一个方言)的解释器，作者把它称为Lispy(lis.py)。多年前，作者曾用java和common Lisp写过一个半实用的Scheme解释器。这次的目标在于尽可能简单的展示Alan Kay所说的Maxwell’s Equations of Software. 这有什么意义呢？正如Steve Yegge所说的那样，如果不知道编译器如何工作，那你也不知道计算机是如何工作的。Yegge描述了编译器能够解决的8个问题(出于Yegge严重的犬儒主义，或许解释器也是一样的)。 Scheme程序的语法(syntax)和语义(Semantics) 语言的语法是指能够形成正确表达形式的字符排列方式；语义是指这种表达形式的意思。举个例子，在数学表达式（和大多数程序语言）中，1加2的语法就是”1+2”，语义就是将加法操作应用到这两个数字上，产生值3。我们将确定某个表达式的值称为对其求值(evaluate);比如，对”1+2”求值得到3，写下来就是”1+2”=&gt;3。 Scheme的语法和大多数语言不同，比如:Java:1234if (x.val() &gt; 0) &#123; return fn(A[i] + 3 * i, new String[] &#123;\"one\", \"two\"&#125;);&#125; Scheme:123(if (&gt; (val x) 0) (fn (+ (aref A i) (* 3 i)) (quote (one two))) Java有大量的语法规定（关键字，中缀运算符，三种括号，运算符优先级，点号，引号，逗号，分号），但Scheme的语法非常简单： Scheme程序完全是由表达式组成(expressions)的，并没有声明和表达(statement/expression)的区别。 数字(Numbers)(e.g. 1)和符号(symbols)(e.g. A)称为原子表达式，他们不能被分为更小的单元，这些在Java中也是这样的，另外在Scheme中，像+,&gt;这样的操作符也是符号，与A和fn以相同发的方式来处理。 其他的所有东西都是列表表达式(list expression)：一个”(“，然后后面加上一个0或更多表达式，最后再加一个”)”。列表中的一个元素决定了他的含义: 以关键字开始的列表，e.g.(if …)，是一种特殊形式;其意思取决于关键字 以非关键字开始的列表，e.g.(fn …)，是一个函数调用 Scheme的优雅体现在整个语言只需要5个关键字和8种语法格式。作为对比，python有33个关键字和110种语法，java有50个关键字和133种语法。虽然这些括号看起来很可怕，但Scheme的语法也因此显得非常的简明一致。（很多人认为”lisp”代表着”一大堆烦人的括号”，但我认为他表示”Lisp的语法是纯粹的”。）这篇文章将涵盖Scheme中所有重要的点及其解释（将省略一点小细节），我们将通过两个步骤完成，首先定义一个简单的语言，然后完成一个接近完备的Scheme语言。 语言1：Lispy Calculator Lispy Calculator是一个仅含5种语法形式（两种原子，两种特殊形式，以及一个调用）的Scheme语言子集。如果你能适应前缀表达式，Lispy Calculator将能做任何经典计算器能做到的运算，同时，你也能做到在经典计算器上不存在的两种表达：”if”表达式以及定义一个新的变量。下面是一个示例程序，使用公式πr^2计算半径为10的圆的面积。12(define r 10)(* pi (* r r)) 这里是一个包含可用表达式的表格: 表达式(Expression)语法(Syntax)语义及示例(Semantics and Example)引用变量(variable reference)符号(symbol)一个符号将被解释为变量名;它的值就是变量的值。 示例:r ⇒ 10 (假设r先前被定为为10)字面常量(constant literal)数字(number)一个值为自身的数字。示例:12 ⇒ 12 或 -3.45e+6 ⇒ -3.45e+6条件表达式(conditional)(if test conseq alt)判断test，如果为True，求值并返回conseq；否则求值并返回alt。示例:(if (&gt; 10 20) (+ 1 1) (+ 3 3)) ⇒ 6定义(definition)(define symbol exp)定义一个新变量，并将表达式exp的值赋予它。示例:(define r 10)过程调用(definition)(proc arg…)如果proc不是符号if, define或 quote，则将其当作一个过程。对proc和args求值，将这个过程应用于args列表。示例: (sqrt (* 2 8)) ⇒ 4.0&gt;在这个表格的语法这一栏中，符号(symbol)必须是符号，数字(number)必须是整数或浮点数，而其他斜体字可以是任何表达式，符号arg …表示arg可以重复零次或多次。 语言解释器的作用 一个语言解释器有两部分： 解析(Parsing)：解析组件获取以字符序列作为输入的程序，根据该语言的语法规则判断是否正确，然后将程序翻译为内部表示。一个小型解释器的内部表示通常是一个树状结构(称为抽象语法树(abstract syntax tree))，能够紧密的反映程序中各种表达式或语句的嵌套结构。在称为编译器的语言翻译器中经常包含一系列的的内部表示，从一个抽象语法树开始，演变到一个计算机可以直接执行的一系列指令。Lispy解析器是由函数parse实现的。 执行(Execution)：根据语言的语义规则处理内部表示，从而执行计算。Lispy执行器是由函数eval实现的。(注意：这里的eval和python的内建方法eval重名了)以下是一个解释器工作的流程:program ➡ parse ➡ abstract-syntax-tree ➡ eval ➡ result 下面是一个期望中parse和eval工作的例子（begin依次对之后的表达式求值，并返回最终结果）：12345&gt;&gt;&gt; program = \"(begin (define r 10) (* pi (* r r)))\"&gt;&gt;&gt; parse(program)['begin', ['define', 'r', 10], ['*', 'pi', ['*', 'r', 'r']]]&gt;&gt;&gt; eval(parse(program))314.1592653589793 类型定义(Type Definitions) 对Scheme中的对象进行明确的表示:1234567Symbol = str # 通过python中的str对Symbol进行实现Number = (int, float) # 通过python中的int或float对Symbol进行实现Atom = (Symbol, Number) # Scheme中的Atom是一个Symbol或NumberList = list # 通过python中的list对List进行实现Exp = (Atom, List) # Scheme中的Exp是一个Atom或ListEnv = dict # Scheme中的environment(将在之后定义) # 是一个&#123;variable: value&#125;的字典 解析器：parse,tokenize以及read_from_tokens 按照传统，解析器分为两个部分：词法分析(lexical analysis)，将输入字符串分为一个词例(token)序列；语法分析(syntactic analysis)，将词例组装为抽象语法树。Lispy的词例包含括号(parentheses)，符号(symbols)，以及数字(numbers)，现在已经有很多词法分析工具了（如Mike Lesk和Eric Schmidt的lex），但是现在我们只用一个非常简单的工具：python中的str.split。函数tokenize接受一个字符串作为输入，在每一个括号的两边添加空格，然后调用str.split得到一个词例序列:123def tokenize(chars: str) -&gt; list: \"将字符串转换成词例序列\" return chars.replace('(', ' ( ').replace(')', ' ) ').split() 这里在示例中调用一下tokenize:123&gt;&gt;&gt; program = \"(begin (define r 10) (* pi (* r r)))\"&gt;&gt;&gt; tokenize(program)['(', 'begin', '(', 'define', 'r', '10', ')', '(', '*', 'pi', '(', '*', 'r', 'r', ')', ')', ')'] 函数parse将接受一个表示目标程序的字符串作为输入，调用tokenize得到一个词例序列，然后调用read_from_tokens来组装一个抽象语法树。read_from_tokens首先观察第一个词例，如果是’)’，显然是一个语法错误，如果是’(‘，就开始组装一个子表达式，直到遇到’)’为止。任何非括号的词例都必须是一个符号或数字。利用python来进行区分：对一个非括号的词例，首先尝试解释为int，之后尝试解释为float，如果都不属于的话，它就必须是一个符号。以下是parse的实现：123456789101112131415161718192021222324252627def parse(program: str) -&gt; Exp: \"从字符串中读取Scheme表达式\" return read_from_tokens(tokenize(program))def read_from_tokens(tokens: list) -&gt; Exp: \"从词条序列中获取一个表达式\" if len(tokens) == 0: raise SyntaxError('unexpected EOF') token = tokens.pop(0) if token == '(': L = [] while tokens[0] != ')': L.append(read_from_tokens(tokens)) tokens.pop(0) # pop off ')' return L elif token == ')': raise SyntaxError('unexpected )') else: return atom(token)def atom(token: str) -&gt; Atom: \"数字解释为数字(Number)，其他词例解释为符号\" try: return int(token) except ValueError: try: return float(token) except ValueError: return Symbol(token) parse的效果如下：123&gt;&gt;&gt; program = \"(begin (define r 10) (* pi (* r r)))\"&gt;&gt;&gt; parse(program)['begin', ['define', 'r', 10], ['*', 'pi', ['*', 'r', 'r']]] 在定义eval之前先要明确一个概念。 环境(Environments) 一个环境指一组变量名到变量值的映射。在默认情况下，eval将会使用一个包含有一堆标准函数（比如sqrt，max，还有类似与*的操作符）名称的全局环境。环境也能通过使用表达式（define，symbol，value）来增加一些用户定义的变量。123456789101112131415161718192021222324252627282930313233343536import mathimport operator as opdef standard_env() -&gt; Env: \"包含一些Scheme标准过程的环境\" env = Env() env.update(vars(math)) # sin, cos, sqrt, pi, ... env.update(&#123; '+':op.add, '-':op.sub, '*':op.mul, '/':op.truediv, '&gt;':op.gt, '&lt;':op.lt, '&gt;=':op.ge, '&lt;=':op.le, '=':op.eq, 'abs': abs, 'append': op.add, 'apply': lambda proc, args: proc(*args), 'begin': lambda *x: x[-1], 'car': lambda x: x[0], 'cdr': lambda x: x[1:], 'cons': lambda x,y: [x] + y, 'eq?': op.is_, 'expt': pow, 'equal?': op.eq, 'length': len, 'list': lambda *x: List(x), 'list?': lambda x: isinstance(x, List), 'map': map, 'max': max, 'min': min, 'not': op.not_, 'null?': lambda x: x == [], 'number?': lambda x: isinstance(x, Number), 'print': print, 'procedure?': callable, 'round': round, 'symbol?': lambda x: isinstance(x, Symbol), &#125;) return envglobal_env = standard_env() 求值(Evaluation)：eval 现在可以准备实现eval了。作为复习，这里重复一下Lispy表达式的表格： 表达式(Expression)语法(Syntax)语义及示例(Semantics and Example)引用变量(variable reference)符号(symbol)一个符号将被解释为变量名;它的值就是变量的值。 示例:r ⇒ 10 (假设r先前被定为为10)字面常量(constant literal)数字(number)一个值为自身的数字。示例:12 ⇒ 12 或 -3.45e+6 ⇒ -3.45e+6条件表达式(conditional)(if test conseq alt)判断test，如果为True，求值并返回conseq；否则求值并返回alt。示例:(if (&gt; 10 20) (+ 1 1) (+ 3 3)) ⇒ 6定义(definition)(define symbol exp)定义一个新变量，并将表达式exp的值赋予它。示例:(define r 10)过程调用(definition)(proc arg…)如果proc不是符号if, define或 quote，则将其当作一个过程。对proc和args求值，将这个过程应用于args列表。示例: (sqrt (* 2 8)) ⇒ 4.0&gt;以下是eval的实现：1234567891011121314151617def eval(x: Exp, env=global_env) -&gt; Exp: \"在环境中对一个表达式求值\" if isinstance(x, Symbol): # variable reference return env[x] elif isinstance(x, Number): # constant number return x elif x[0] == 'if': # conditional (_, test, conseq, alt) = x exp = (conseq if eval(test, env) else alt) return eval(exp, env) elif x[0] == 'define': # definition (_, symbol, exp) = x env[symbol] = eval(exp, env) else: # procedure call proc = eval(x[0], env) args = [eval(arg, env) for arg in x[1:]] return proc(*args) 完成~可以看到如下所示的结果：12&gt;&gt;&gt; eval(parse(\"(begin (define r 10) (* pi (* r r)))\"))314.1592653589793 交互：交互式解析器(REPL) 显然，一直输入eval(parse(“…”))非常繁琐。Lisp的伟大遗产之一就包含了交互式解析器这一概念：这是一种让程序员输入表达式之后能够直接显示，读取，求值，打印而不需要经过构建/编译/运行的方式。以下定义函数repl（表示交互式解析器(REPL)），函数schemestr返回一个表示Scheme对象的字符串。12345678910111213def repl(prompt='lis.py&gt; '): \"一个交互解释器\" while True: val = eval(parse(raw_input(prompt))) if val is not None: print(schemestr(val))def schemestr(exp): \"将python对象转换为可读的Scheme式对象\" if isinstance(exp, List): return '(' + ' '.join(map(schemestr, exp)) + ')' else: return str(exp) 效果如下：12345678&gt;&gt;&gt; repl()lis.py&gt; (define r 10)lis.py&gt; (* pi (* r r))314.159265359lis.py&gt; (if (&gt; (* 11 11) 120) (* 7 6) oops)42lis.py&gt; (list (+ 1 1) (+ 2 2) (* 2 3) (expt 2 3))lis.py&gt; 语言2：Full Lispy 现在将在上文的语言种添加3种特殊的语法形式，将能够得到一个更加完备的Scheme语言子集： 表达式(Expression)语法(Syntax)语义及示例(Semantics and Example)引号(quotation)(quote exp)直接返回exp；并不对其求值。 示例:(quote (+ 1 2)) ⇒ (+ 1 2) (假设r先前被定为为10)分配(assignment) (set! symbol exp)对exp求值，并将其值分配给symbol，symbol必须事先已被定义（通过define或作为一个封闭过程中的参数）示例:(set! r2 (&lowast; r r))过程(procedure)(lambda (symbol…) exp)创建一个参数为symbol…，函数体为exp的过程示例:(lambda (r) (&lowast; pi (&lowast; r r)))lambda的特殊语法形式（命名来源于Alonzo Church的lambda演算）创建了一个过程。期待中过程能如下工作：123lis.py&gt; (define circle-area (lambda (r) (* pi (* r r)))lis.py&gt; (circle-area (+ 5 5))314.159265359 这里有两步，首先，lambda表达式创建了一个过程，其中包含全局变量pi和*，接受一个称为r的单一参数，这一整个过程用来作为变量circle-area的值。之后，我们定义为circle-area的过程接受了10作为参数被调用了。我们期望r能接受10这个值，但在全局环境下是不能直接将r设置为10的，这样如果在其他地方用到r时显然会有问题，每调用一次circle-area都会改变r的值肯定是不合理的。相反，我们期望能够在这里定义一个名为r的局部变量，这样我们把r设置为10时，也不用担心会干扰到可能重名的全局变量。调用过程时将会引入这些新的局部变量，将每个参数都与对应的符号绑定到参数列表中。函数调用时将根据这个列表获取对应的值。 将Env重定义为类 为了处理局部变量，需要将Env重定义为dic子类。当我们对(circle-area (+ 5 5))求值的时候将获取到函数体( pi ( r r))，会在只有一个变量r（值为10）的环境中对其求值，同时这个类将包含outer作为全局环境，其中包含了pi和*的值。换句话说，这个环境是这样的，局部环境（蓝色）嵌套在全局环境（红色）中。 pi: 3.141592653589793&lowast;: &lt;built-in function mul&gt;…r: 10当我们在这样一个嵌套的环境中寻找一个变量时，首先在最内层中查找，没找到的话，就移动到下一个外层。过程和环境是密切相关，以下是他们的定义：1234567891011121314151617class Env(dict): \"一个环境包含一个&#123;'var': val&#125;字典和一个outer(Env)\" def __init__(self, parms=(), args=(), outer=None): self.update(zip(parms, args)) self.outer = outer def find(self, var): \"Find the innermost Env where var appears.\" return self if (var in self) else self.outer.find(var)class Procedure(object): \"一个用户自定义的Scheme过程\" def __init__(self, parms, body, env): self.parms, self.body, self.env = parms, body, env def __call__(self, *args): return eval(self.body, Env(self.parms, args, self.env))global_env = standard_env() 可以看到，每一段过程都有3个部分：参数，函数体，以及一个能够告知我们从函数体中需要访问哪些变量的环境。这个过程的顶层是全局环境，同时也可以引用它所在环境的局部变量（而不是被调函数的环境）。环境是一个dict的子类，所以它拥有所有dict拥有的方法。此外，这里还定义了另外两个方法：构造函数init通过接受参数名和对应的参数值创建了一组键值对作为内部环境，同时也可以指定外部环境。find方法用于查找变量所在的正确环境。为了将所有函数结合，这里也需要对eval有一个新的定义。注意之前引用变量的的那条语句已作更改：现在需要调用env.find(x)来得到变量所在的层数，之后才能再从那一层获取变量的值。（define的实现并没有变化，因为define总是在最内层添加一个新的变量）同时这里还实现了两个新的函数：对于set!，查找变量所在的层数并更新其值。对于lambda，利用参数，函数体和环境构建一个新的过程对象。1234567891011121314151617181920212223242526def eval(x, env=global_env): \"对环境中的表达式求值\" if isinstance(x, Symbol): # variable reference return env.find(x)[x] elif not isinstance(x, List):# constant return x op, *args = x if op == 'quote': # quotation return args[0] elif op == 'if': # conditional (test, conseq, alt) = args exp = (conseq if eval(test, env) else alt) return eval(exp, env) elif op == 'define': # definition (symbol, exp) = args env[symbol] = eval(exp, env) elif op == 'set!': # assignment (symbol, exp) = args env.find(symbol)[symbol] = eval(exp, env) elif op == 'lambda': # procedure (parms, body) = args return Procedure(parms, body, env) else: # procedure call proc = eval(op, env) vals = [eval(arg, env) for arg in args] return proc(*vals) 为了理解过程和环境是如何协同工作的，思考在对(account1 -20.00)求值时形成的环境： (define make-account &nbsp;&nbsp;(lambda (balance) &nbsp;&nbsp;&nbsp;&nbsp;(lambda (amt)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin (set! balance (+ balance amt))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance))))(define account1 (make-account 100.00))(account1 -20.00) &nbsp; +: &lt;built-in operator add&gt;make-account: &lt;a Procedure&gt; balance: 100.00 amt: -20.00account1: &lt;a Procedure&gt;每个方框代表一个环境，框的颜色与当前环境中新定义的变量颜色相同。在程序的最后两行中定义了account1并调用了(account1 -20.00)，这表示首先创建了一个有100美元余额的账户，之后取出了20美元。在对(account1 -20.00)求值的过程中，我们将需要求值的表达式用黄色来高亮表示，该表达式有3个变量。其中amt可以立即在最内层环境（绿色）中找到。但balance并不在这里，我们必须在绿色环境的外一层寻找，也就是蓝色环境中可以找到。然而，变量+号并不在这两个环境中。我们需要在往外一层，到达全局环境（红色）。这个首先在最内层查找，之后一步一步向外的过程叫做词法作用域（lexical scope）。Env.find(var)能够根据做词法作用域的规则来找到正确的环境。现在的功能如下：1234567891011121314151617181920212223242526272829303132333435363738394041&gt;&gt;&gt; repl()lis.py&gt; (define circle-area (lambda (r) (* pi (* r r))))lis.py&gt; (circle-area 3)28.274333877lis.py&gt; (define fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))lis.py&gt; (fact 10)3628800lis.py&gt; (fact 100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000lis.py&gt; (circle-area (fact 10))4.1369087198e+13lis.py&gt; (define first car)lis.py&gt; (define rest cdr)lis.py&gt; (define count (lambda (item L) (if L (+ (equal? item (first L)) (count item (rest L))) 0)))lis.py&gt; (count 0 (list 0 1 2 3 0 0))3lis.py&gt; (count (quote the) (quote (the more the merrier the bigger the better)))4lis.py&gt; (define twice (lambda (x) (* 2 x)))lis.py&gt; (twice 5)10lis.py&gt; (define repeat (lambda (f) (lambda (x) (f (f x)))))lis.py&gt; ((repeat twice) 10)40lis.py&gt; ((repeat (repeat twice)) 10)160lis.py&gt; ((repeat (repeat (repeat twice))) 10)2560lis.py&gt; ((repeat (repeat (repeat (repeat twice)))) 10)655360lis.py&gt; (pow 2 16)65536.0lis.py&gt; (define fib (lambda (n) (if (&lt; n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))lis.py&gt; (define range (lambda (a b) (if (= a b) (quote ()) (cons a (range (+ a 1) b)))))lis.py&gt; (range 0 10)(0 1 2 3 4 5 6 7 8 9)lis.py&gt; (map fib (range 0 10))(1 1 2 3 5 8 13 21 34 55)lis.py&gt; (map fib (range 0 20))(1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765) 我们现在有一个包含过程，变量，条件（if）和顺序执行（begin过程）的语言。如果您熟悉其他语言，您可能会认为需要一个while或for循环，但Scheme认为没有这些也是可以的。Scheme的报告书中提到：Scheme对于表达式语法的规定非常少，并且对他们的组成方式没有限制，但这也足以成为一个实用且高效的程序语言(Scheme demonstrates that a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language.)。在Scheme中，你可以通过递归来完成迭代操作。 Lispy的特征(How Small/Fast/Complete/Good is Lispy?) 我们可以根据以下几个标准来评判Lispy： 简短：Lispy非常简短：去除注释和空白只有117行；4k的源码量。（早期版本只有90行，但标准程序较少，有点过于简单。）而我最简短的Java版的Scheme，Jscheme，有1664行以及57k的代码量。Jscheme最初叫SILK(50k的Scheme)(Scheme in Fifty Kilobytes)，但最终我只在字节码而不是源码上达到了这个限制（50k）。Lispy做的更好，我认为它符合Alan Kay在1972声称的，你可以在“一页代码”中定义“世界上最好的代码”。（然而Alan可能不会同意这一点，他会将python编译器也作为代码的一部分，一页就不够了。） 12bash$ grep \"^\\s*[^#\\s]\" lis.py | wc 117 497 4276 快速：Lispy计算(fact 100)只需要0.003秒，对我来说是足够迅速了（虽然比大多数其他计算方式要慢）。 完备性：与标准Scheme相比，Lispy是不够完备的。主要缺陷： 语法：缺少注释(comments)，引号(quote)，逆符号(quasiquote)，’#’字符，派生表达类型（比如cond，是从if中派生而来，let从lambda中派生而来），点缀列表(dotted list)。 语义：缺少call/cc和尾递归 数据类型：缺少字符串(strings)，字符(characters)，布尔值(booleans)，端口(ports)，向量(vectors)，精确化/去精确化数字(exact/inexact numbers)。实际上python中的lisp更贴近与Scheme的向量而不是我们实现的对(pair)。 过程：缺少超过100个原有过程。 错误恢复：lispy不会去检测合理报告或从错误中恢复。lispy希望程序员是完美的。 优点：这个由读者来判断，这样显然更加有利于我说明Lisp解释器的目的。 真实的故事 这个故事对了解编译器的工作方式是非常有用的。1984年时，我正在写一篇博士论文，那个年代没有LaTeX，没有Word，那时我们用troff。不幸的是，troff没有提供符号标签的前向参照：比如如果我想写“正如我们在@theorem-x看到的那样(As we will see on page @theorem-x)”，然后就能在之后的某个地方写一些“@(set theorem-x \\n%)”这种（troff的\\n%表示页数）。我的研究生同事Tony DeRose也有相同的需求。之后我们完成了一个简单的Lisp程序用来预处理，来达到这个要求。然而，当时的Lisp仅能比较好的读取lisp表达式，但是在读取非Lisp表达式时非常慢，这使得我们的程序用起来非常不适。在这一点上Tony和我采取了两种方式。他认为让解释器来解析这些表达式太困难了，但是他知道某种方式可以写一个小的C程序来处理非Lisp的字符串，之后将其链接到Lisp程序中。我并不知道怎么链接的，但我觉得给这种小语言（仅仅包含建立变量，获取变量，字符串联）写个解释器很简单，所以我用C写了个解释器。搞笑的是，Tony写了一个Lisp程序（包含一个小的C程序），而他是一个C程序员，而我写了一个C程序因为我是一个Lisp程序员。当然，最后我们都完成了各自的论文（Tony，Peter）。 完整代码 这里是完整的程序：lis.py(译者注：好像已经挂了)。 进阶阅读 想学习更多Scheme相关的话，可以进行阅读（Friedman and Fellesein， Dybvig，Queinnec，Harvey and Wright或者Sussman and Abelson)，视频(Abelson and Sussman)，教程(Dorai，PLT，或 Neller)，或参考手册。","categories":[{"name":"translate","slug":"translate","permalink":"http://gloriaswaterpool.com/categories/translate/"}],"tags":[{"name":"lisp","slug":"lisp","permalink":"http://gloriaswaterpool.com/tags/lisp/"}]}],"categories":[{"name":"os","slug":"os","permalink":"http://gloriaswaterpool.com/categories/os/"},{"name":"learn","slug":"learn","permalink":"http://gloriaswaterpool.com/categories/learn/"},{"name":"translate","slug":"translate","permalink":"http://gloriaswaterpool.com/categories/translate/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://gloriaswaterpool.com/tags/linux/"},{"name":"vulkan","slug":"vulkan","permalink":"http://gloriaswaterpool.com/tags/vulkan/"},{"name":"erlang","slug":"erlang","permalink":"http://gloriaswaterpool.com/tags/erlang/"},{"name":"lisp","slug":"lisp","permalink":"http://gloriaswaterpool.com/tags/lisp/"}]}