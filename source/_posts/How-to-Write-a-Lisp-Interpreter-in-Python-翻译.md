---
title: How to Write a Lisp Interpreter in Python(翻译)
date: 2018-09-26 19:32:41
tags: lisp
categories: translate
thumbnail: images/apple.jpg
---
<p>翻译一个How to Write a (Lisp) Interpreter (in Python)原文地址-&gt;<a href="http://www.norvig.com/lispy.html" target="_blank" rel="external">How to Write a (Lisp) Interpreter (in Python)</a><br><a id="more"></a></p>
<!-- more -->
<p>这边文章有两个目标，是描述如何实现一个一般程序语言的解释器，然后利用python3实现一个scheme(lisp的一个方言)的解释器，作者把它称为Lispy(lis.py)。多年前，作者曾用java和common Lisp写过一个半实用的Scheme解释器。这次的目标在于尽可能简单的展示Alan Kay所说的<a href="http://www.righto.com/2008/07/maxwells-equations-of-software-examined.html" target="_blank" rel="external">Maxwell’s Equations of Software.</a></p>
<p>这有什么意义呢？正如Steve Yegge所说的那样，如果不知道编译器如何工作，那你也不知道计算机是如何工作的。Yegge描述了编译器能够解决的8个问题(出于Yegge严重的犬儒主义，或许解释器也是一样的)。</p>
<font size="5" face="黑体">Scheme程序的语法(syntax)和语义(Semantics)</font>

<p>语言的语法是指能够形成正确表达形式的字符排列方式；语义是指这种表达形式的意思。举个例子，在数学表达式（和大多数程序语言）中，1加2的语法就是”1+2”，语义就是将加法操作应用到这两个数字上，产生值3。我们将确定某个表达式的值称为对其求值(evaluate);比如，对”1+2”求值得到3，写下来就是”1+2”=&gt;3。</p>
<p>Scheme的语法和大多数语言不同，比如:<br>Java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.val() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fn(A[i] + <span class="number">3</span> * i,</span><br><span class="line">            <span class="keyword">new</span> String[] &#123;<span class="string">"one"</span>, <span class="string">"two"</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Scheme:<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&gt;</span></span> (<span class="name">val</span> x) <span class="number">0</span>)</span><br><span class="line">    (<span class="name">fn</span> (<span class="name"><span class="builtin-name">+</span></span> (<span class="name">aref</span> A i) (<span class="name"><span class="builtin-name">*</span></span> <span class="number">3</span> i))</span><br><span class="line">        (<span class="name"><span class="builtin-name">quote</span></span> (<span class="name">one</span> two)))</span><br></pre></td></tr></table></figure></p>
<p>Java有大量的语法规定（关键字，中缀运算符，三种括号，运算符优先级，点号，引号，逗号，分号），但Scheme的语法非常简单：</p>
<ul>
<li>Scheme程序完全是由表达式组成(expressions)的，并没有声明和表达(statement/expression)的区别。</li>
<li>数字(Numbers)(e.g. 1)和符号(symbols)(e.g. A)称为原子表达式，他们不能被分为更小的单元，这些在Java中也是这样的，<br>另外在Scheme中，像+,&gt;这样的操作符也是符号，与A和fn以相同发的方式来处理。</li>
<li>其他的所有东西都是列表表达式(list expression)：一个”(“，然后后面加上一个0或更多表达式，最后再加一个”)”。列表中的一个元素决定了他的含义:<ul>
<li>以关键字开始的列表，e.g.(if …)，是一种特殊形式;其意思取决于关键字</li>
<li>以非关键字开始的列表，e.g.(fn …)，是一个函数调用</li>
</ul>
</li>
</ul>
<p>Scheme的优雅体现在整个语言只需要5个关键字和8种语法格式。作为对比，python有33个关键字和110种语法，java有50个关键字和133种语法。虽然这些括号看起来很可怕，但Scheme的语法也因此显得非常的简明一致。（很多人认为”lisp”代表着”一大堆烦人的括号”，但我认为他表示”Lisp的语法是纯粹的”。）这篇文章将涵盖Scheme中所有重要的点及其解释（将省略一点小细节），我们将通过两个步骤完成，首先定义一个简单的语言，然后完成一个接近完备的Scheme语言。</p>
<font size="5" face="黑体">语言1：Lispy Calculator</font>

<p>Lispy Calculator是一个仅含5种语法形式（两种原子，两种特殊形式，以及一个调用）的Scheme语言子集。如果你能适应前缀表达式，Lispy Calculator将能做任何经典计算器能做到的运算，同时，你也能做到在经典计算器上不存在的两种表达：”if”表达式以及定义一个新的变量。下面是一个示例程序，使用公式πr^2计算半径为10的圆的面积。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(define r 10)</span><br><span class="line">(* pi (* r r))</span><br></pre></td></tr></table></figure></p>
<p>这里是一个包含可用表达式的表格:</p>
<p><table><tr><th>表达式(Expression)</th><th>语法(Syntax)</th><th>语义及示例(Semantics and Example)</th></tr><tr><th>引用变量(variable reference)</th><th><i>符号(symbol)</i></th><th>一个符号将被解释为变量名;它的值就是变量的值。<br> 示例:r ⇒ 10 (假设r先前被定为为10)</th></tr><tr><th>字面常量(constant literal)</th><th><i>数字(number)</i></th><th>一个值为自身的数字。<br>示例:12 ⇒ 12 或 -3.45e+6 ⇒ -3.45e+6</th></tr><tr><th>条件表达式(conditional)</th><th>(if <i>test conseq alt</i>)</th><th>判断test，如果为True，求值并返回conseq；否则求值并返回alt。<br>示例:(if (&gt; 10 20) (+ 1 1) (+ 3 3)) ⇒ 6</th></tr><tr><th>定义(definition)</th><th>(define <i>symbol exp</i>)</th><th>定义一个新变量，并将表达式exp的值赋予它。<br>示例:(define r 10)</th></tr><tr><th>过程调用(definition)</th><th>(<i>proc arg…</i>)</th><th>如果proc不是符号if, define或 quote，则将其当作一个过程。对proc和args求值，将这个过程应用于args列表。<br>示例: (sqrt (* 2 8)) ⇒ 4.0&gt;</th></tr></table><br>在这个表格的语法这一栏中，符号(symbol)必须是符号，数字(number)必须是整数或浮点数，而其他斜体字可以是任何表达式，符号arg …表示arg可以重复零次或多次。</p>
<font size="5" face="黑体">语言解释器的作用</font>

<p>一个语言解释器有两部分：</p>
<ol>
<li>解析(Parsing)：解析组件获取以字符序列作为输入的程序，根据该语言的语法规则判断是否正确，然后将程序翻译为内部表示。一个小型解释器的内部表示通常是一个树状结构(称为抽象语法树(abstract syntax tree))，能够紧密的反映程序中各种表达式或语句的嵌套结构。在称为编译器的语言翻译器中经常包含一系列的的内部表示，从一个抽象语法树开始，演变到一个计算机可以直接执行的一系列指令。Lispy解析器是由函数parse实现的。</li>
<li>执行(Execution)：根据语言的语义规则处理内部表示，从而执行计算。Lispy执行器是由函数eval实现的。(注意：这里的eval和python的内建方法eval重名了)<br>以下是一个解释器工作的流程:<br><br>program  ➡ <span style="border: 2px solid; padding: 4px"><tt>parse</tt></span> ➡ abstract-syntax-tree ➡ <span style="border: 2px solid; padding: 4px"><tt>eval</tt></span> ➡ result <br><br>下面是一个期望中parse和eval工作的例子（begin依次对之后的表达式求值，并返回最终结果）：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>program = <span class="string">"(begin (define r 10) (* pi (* r r)))"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parse(program)</span><br><span class="line">[<span class="string">'begin'</span>, [<span class="string">'define'</span>, <span class="string">'r'</span>, <span class="number">10</span>], [<span class="string">'*'</span>, <span class="string">'pi'</span>, [<span class="string">'*'</span>, <span class="string">'r'</span>, <span class="string">'r'</span>]]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(parse(program))</span><br><span class="line"><span class="number">314.1592653589793</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<font size="5" face="黑体">类型定义(Type Definitions)</font>

<p>对Scheme中的对象进行明确的表示:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol = str              <span class="comment"># 通过python中的str对Symbol进行实现</span></span><br><span class="line">Number = (int, float)     <span class="comment"># 通过python中的int或float对Symbol进行实现</span></span><br><span class="line">Atom   = (Symbol, Number) <span class="comment"># Scheme中的Atom是一个Symbol或Number</span></span><br><span class="line">List   = list             <span class="comment"># 通过python中的list对List进行实现</span></span><br><span class="line">Exp    = (Atom, List)     <span class="comment"># Scheme中的Exp是一个Atom或List</span></span><br><span class="line">Env    = dict             <span class="comment"># Scheme中的environment(将在之后定义)</span></span><br><span class="line">                          <span class="comment"># 是一个&#123;variable: value&#125;的字典</span></span><br></pre></td></tr></table></figure></p>
<font size="5" face="黑体">解析器：parse,tokenize以及read_from_tokens</font>

<p>按照传统，解析器分为两个部分：词法分析(lexical analysis)，将输入字符串分为一个词例(token)序列；语法分析(syntactic analysis)，将词例组装为抽象语法树。Lispy的词例包含括号(parentheses)，符号(symbols)，以及数字(numbers)，现在已经有很多词法分析工具了（如Mike Lesk和Eric Schmidt的lex），但是现在我们只用一个非常简单的工具：python中的str.split。函数tokenize接受一个字符串作为输入，在每一个括号的两边添加空格，然后调用str.split得到一个词例序列:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(chars: str)</span> -&gt; list:</span></span><br><span class="line">    <span class="string">"将字符串转换成词例序列"</span></span><br><span class="line">    <span class="keyword">return</span> chars.replace(<span class="string">'('</span>, <span class="string">' ( '</span>).replace(<span class="string">')'</span>, <span class="string">' ) '</span>).split()</span><br></pre></td></tr></table></figure></p>
<p>这里在示例中调用一下tokenize:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>program = <span class="string">"(begin (define r 10) (* pi (* r r)))"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenize(program)</span><br><span class="line">[<span class="string">'('</span>, <span class="string">'begin'</span>, <span class="string">'('</span>, <span class="string">'define'</span>, <span class="string">'r'</span>, <span class="string">'10'</span>, <span class="string">')'</span>, <span class="string">'('</span>, <span class="string">'*'</span>, <span class="string">'pi'</span>, <span class="string">'('</span>, <span class="string">'*'</span>, <span class="string">'r'</span>, <span class="string">'r'</span>, <span class="string">')'</span>, <span class="string">')'</span>, <span class="string">')'</span>]</span><br></pre></td></tr></table></figure></p>
<p>函数parse将接受一个表示目标程序的字符串作为输入，调用tokenize得到一个词例序列，然后调用read_from_tokens来组装一个抽象语法树。read_from_tokens首先观察第一个词例，如果是’)’，显然是一个语法错误，如果是’(‘，就开始组装一个子表达式，直到遇到’)’为止。任何非括号的词例都必须是一个符号或数字。利用python来进行区分：对一个非括号的词例，首先尝试解释为int，之后尝试解释为float，如果都不属于的话，它就必须是一个符号。以下是parse的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(program: str)</span> -&gt; Exp:</span></span><br><span class="line">    <span class="string">"从字符串中读取Scheme表达式"</span></span><br><span class="line">    <span class="keyword">return</span> read_from_tokens(tokenize(program))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_from_tokens</span><span class="params">(tokens: list)</span> -&gt; Exp:</span></span><br><span class="line">    <span class="string">"从词条序列中获取一个表达式"</span></span><br><span class="line">    <span class="keyword">if</span> len(tokens) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">'unexpected EOF'</span>)</span><br><span class="line">    token = tokens.pop(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> token == <span class="string">'('</span>:</span><br><span class="line">        L = []</span><br><span class="line">        <span class="keyword">while</span> tokens[<span class="number">0</span>] != <span class="string">')'</span>:</span><br><span class="line">            L.append(read_from_tokens(tokens))</span><br><span class="line">        tokens.pop(<span class="number">0</span>) <span class="comment"># pop off ')'</span></span><br><span class="line">        <span class="keyword">return</span> L</span><br><span class="line">    <span class="keyword">elif</span> token == <span class="string">')'</span>:</span><br><span class="line">        <span class="keyword">raise</span> SyntaxError(<span class="string">'unexpected )'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> atom(token)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atom</span><span class="params">(token: str)</span> -&gt; Atom:</span></span><br><span class="line">    <span class="string">"数字解释为数字(Number)，其他词例解释为符号"</span></span><br><span class="line">    <span class="keyword">try</span>: <span class="keyword">return</span> int(token)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">try</span>: <span class="keyword">return</span> float(token)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> Symbol(token)</span><br></pre></td></tr></table></figure></p>
<p>parse的效果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>program = <span class="string">"(begin (define r 10) (* pi (* r r)))"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parse(program)</span><br><span class="line">[<span class="string">'begin'</span>, [<span class="string">'define'</span>, <span class="string">'r'</span>, <span class="number">10</span>], [<span class="string">'*'</span>, <span class="string">'pi'</span>, [<span class="string">'*'</span>, <span class="string">'r'</span>, <span class="string">'r'</span>]]]</span><br></pre></td></tr></table></figure></p>
<p>在定义eval之前先要明确一个概念。</p>
<font size="5" face="黑体">环境(Environments)</font>

<p>一个环境指一组变量名到变量值的映射。在默认情况下，eval将会使用一个包含有一堆标准函数（比如sqrt，max，还有类似与*的操作符）名称的全局环境。环境也能通过使用表达式（define，symbol，value）来增加一些用户定义的变量。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> operator <span class="keyword">as</span> op</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">standard_env</span><span class="params">()</span> -&gt; Env:</span></span><br><span class="line">    <span class="string">"包含一些Scheme标准过程的环境"</span></span><br><span class="line">    env = Env()</span><br><span class="line">    env.update(vars(math)) <span class="comment"># sin, cos, sqrt, pi, ...</span></span><br><span class="line">    env.update(&#123;</span><br><span class="line">        <span class="string">'+'</span>:op.add, <span class="string">'-'</span>:op.sub, <span class="string">'*'</span>:op.mul, <span class="string">'/'</span>:op.truediv,</span><br><span class="line">        <span class="string">'&gt;'</span>:op.gt, <span class="string">'&lt;'</span>:op.lt, <span class="string">'&gt;='</span>:op.ge, <span class="string">'&lt;='</span>:op.le, <span class="string">'='</span>:op.eq,</span><br><span class="line">        <span class="string">'abs'</span>:     abs,</span><br><span class="line">        <span class="string">'append'</span>:  op.add,  </span><br><span class="line">        <span class="string">'apply'</span>:   <span class="keyword">lambda</span> proc, args: proc(*args),</span><br><span class="line">        <span class="string">'begin'</span>:   <span class="keyword">lambda</span> *x: x[<span class="number">-1</span>],</span><br><span class="line">        <span class="string">'car'</span>:     <span class="keyword">lambda</span> x: x[<span class="number">0</span>],</span><br><span class="line">        <span class="string">'cdr'</span>:     <span class="keyword">lambda</span> x: x[<span class="number">1</span>:],</span><br><span class="line">        <span class="string">'cons'</span>:    <span class="keyword">lambda</span> x,y: [x] + y,</span><br><span class="line">        <span class="string">'eq?'</span>:     op.is_,</span><br><span class="line">        <span class="string">'expt'</span>:    pow,</span><br><span class="line">        <span class="string">'equal?'</span>:  op.eq,</span><br><span class="line">        <span class="string">'length'</span>:  len,</span><br><span class="line">        <span class="string">'list'</span>:    <span class="keyword">lambda</span> *x: List(x),</span><br><span class="line">        <span class="string">'list?'</span>:   <span class="keyword">lambda</span> x: isinstance(x, List),</span><br><span class="line">        <span class="string">'map'</span>:     map,</span><br><span class="line">        <span class="string">'max'</span>:     max,</span><br><span class="line">        <span class="string">'min'</span>:     min,</span><br><span class="line">        <span class="string">'not'</span>:     op.not_,</span><br><span class="line">        <span class="string">'null?'</span>:   <span class="keyword">lambda</span> x: x == [],</span><br><span class="line">        <span class="string">'number?'</span>: <span class="keyword">lambda</span> x: isinstance(x, Number),  </span><br><span class="line">		<span class="string">'print'</span>:   <span class="keyword">print</span>,</span><br><span class="line">        <span class="string">'procedure?'</span>: callable,</span><br><span class="line">        <span class="string">'round'</span>:   round,</span><br><span class="line">        <span class="string">'symbol?'</span>: <span class="keyword">lambda</span> x: isinstance(x, Symbol),</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> env</span><br><span class="line">global_env = standard_env()</span><br></pre></td></tr></table></figure></p>
<font size="5" face="黑体">求值(Evaluation)：eval</font>

<p>现在可以准备实现eval了。作为复习，这里重复一下Lispy表达式的表格：</p>
<p><table><tr><th>表达式(Expression)</th><th>语法(Syntax)</th><th>语义及示例(Semantics and Example)</th></tr><tr><th>引用变量(variable reference)</th><th><i>符号(symbol)</i></th><th>一个符号将被解释为变量名;它的值就是变量的值。<br> 示例:r ⇒ 10 (假设r先前被定为为10)</th></tr><tr><th>字面常量(constant literal)</th><th><i>数字(number)</i></th><th>一个值为自身的数字。<br>示例:12 ⇒ 12 或 -3.45e+6 ⇒ -3.45e+6</th></tr><tr><th>条件表达式(conditional)</th><th>(if <i>test conseq alt</i>)</th><th>判断test，如果为True，求值并返回conseq；否则求值并返回alt。<br>示例:(if (&gt; 10 20) (+ 1 1) (+ 3 3)) ⇒ 6</th></tr><tr><th>定义(definition)</th><th>(define <i>symbol exp</i>)</th><th>定义一个新变量，并将表达式exp的值赋予它。<br>示例:(define r 10)</th></tr><tr><th>过程调用(definition)</th><th>(<i>proc arg…</i>)</th><th>如果proc不是符号if, define或 quote，则将其当作一个过程。对proc和args求值，将这个过程应用于args列表。<br>示例: (sqrt (* 2 8)) ⇒ 4.0&gt;</th></tr></table><br>以下是eval的实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(x: Exp, env=global_env)</span> -&gt; Exp:</span></span><br><span class="line">    <span class="string">"在环境中对一个表达式求值"</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(x, Symbol):        <span class="comment"># variable reference</span></span><br><span class="line">        <span class="keyword">return</span> env[x]</span><br><span class="line">    <span class="keyword">elif</span> isinstance(x, Number):  <span class="comment"># constant number</span></span><br><span class="line">        <span class="keyword">return</span> x                </span><br><span class="line">    <span class="keyword">elif</span> x[<span class="number">0</span>] == <span class="string">'if'</span>:               <span class="comment"># conditional</span></span><br><span class="line">        (_, test, conseq, alt) = x</span><br><span class="line">        exp = (conseq <span class="keyword">if</span> eval(test, env) <span class="keyword">else</span> alt)</span><br><span class="line">        <span class="keyword">return</span> eval(exp, env)</span><br><span class="line">    <span class="keyword">elif</span> x[<span class="number">0</span>] == <span class="string">'define'</span>:           <span class="comment"># definition</span></span><br><span class="line">        (_, symbol, exp) = x</span><br><span class="line">        env[symbol] = eval(exp, env)</span><br><span class="line">    <span class="keyword">else</span>:                            <span class="comment"># procedure call</span></span><br><span class="line">        proc = eval(x[<span class="number">0</span>], env)</span><br><span class="line">        args = [eval(arg, env) <span class="keyword">for</span> arg <span class="keyword">in</span> x[<span class="number">1</span>:]]</span><br><span class="line">        <span class="keyword">return</span> proc(*args)</span><br></pre></td></tr></table></figure></p>
<p>完成~可以看到如下所示的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(parse(<span class="string">"(begin (define r 10) (* pi (* r r)))"</span>))</span><br><span class="line"><span class="number">314.1592653589793</span></span><br></pre></td></tr></table></figure></p>
<font size="5" face="黑体">交互：交互式解析器(REPL)</font>

<p>显然，一直输入eval(parse(“…”))非常繁琐。Lisp的伟大遗产之一就包含了交互式解析器这一概念：这是一种让程序员输入表达式之后能够直接显示，读取，求值，打印而不需要经过构建/编译/运行的方式。以下定义函数repl（表示交互式解析器(REPL)），函数schemestr返回一个表示Scheme对象的字符串。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repl</span><span class="params">(prompt=<span class="string">'lis.py&gt; '</span>)</span>:</span></span><br><span class="line">    <span class="string">"一个交互解释器"</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        val = eval(parse(raw_input(prompt)))</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            print(schemestr(val))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">schemestr</span><span class="params">(exp)</span>:</span></span><br><span class="line">    <span class="string">"将python对象转换为可读的Scheme式对象"</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(exp, List):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'('</span> + <span class="string">' '</span>.join(map(schemestr, exp)) + <span class="string">')'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> str(exp)</span><br></pre></td></tr></table></figure></p>
<p>效果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>repl()</span><br><span class="line">lis.py&gt; (define r <span class="number">10</span>)</span><br><span class="line">lis.py&gt; (* pi (* r r))</span><br><span class="line"><span class="number">314.159265359</span></span><br><span class="line">lis.py&gt; (<span class="keyword">if</span> (&gt; (* <span class="number">11</span> <span class="number">11</span>) <span class="number">120</span>) (* <span class="number">7</span> <span class="number">6</span>) oops)</span><br><span class="line"><span class="number">42</span></span><br><span class="line">lis.py&gt; (list (+ <span class="number">1</span> <span class="number">1</span>) (+ <span class="number">2</span> <span class="number">2</span>) (* <span class="number">2</span> <span class="number">3</span>) (expt <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">lis.py&gt;</span><br></pre></td></tr></table></figure></p>
<font size="5" face="黑体">语言2：Full Lispy</font>

<p>现在将在上文的语言种添加3种特殊的语法形式，将能够得到一个更加完备的Scheme语言子集：</p>
<p><table><tr><th>表达式(Expression)</th><th>语法(Syntax)</th><th>语义及示例(Semantics and Example)</th></tr><tr><th>引号(quotation)</th><th>(quote <i>exp</i>)</th><th>直接返回exp；并不对其求值。<br> 示例:(quote (+ 1 2)) ⇒ (+ 1 2) (假设r先前被定为为10)</th></tr><tr><th>分配(assignment)</th><th>    (set! <i>symbol exp</i>)</th><th>对exp求值，并将其值分配给symbol，symbol必须事先已被定义（通过define或作为一个封闭过程中的参数）<br>示例:(set! r2 (&lowast; r r))</th></tr><tr><th>过程(procedure)</th><th>(lambda (<i>symbol…</i>) <i>exp</i>)</th><th>创建一个参数为symbol…，函数体为exp的过程<br>示例:(lambda (r) (&lowast; pi (&lowast; r r)))</th></tr></table><br>lambda的特殊语法形式（命名来源于Alonzo Church的lambda演算）创建了一个过程。期待中过程能如下工作：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lis.py&gt; (define circle-area (<span class="keyword">lambda</span> (r) (* pi (* r r)))</span><br><span class="line">lis.py&gt; (circle-area (+ <span class="number">5</span> <span class="number">5</span>))</span><br><span class="line"><span class="number">314.159265359</span></span><br></pre></td></tr></table></figure></p>
<p>这里有两步，首先，lambda表达式创建了一个过程，其中包含全局变量pi和*，接受一个称为r的单一参数，这一整个过程用来作为变量circle-area的值。之后，我们定义为circle-area的过程接受了10作为参数被调用了。我们期望r能接受10这个值，但在全局环境下是不能直接将r设置为10的，这样如果在其他地方用到r时显然会有问题，每调用一次circle-area都会改变r的值肯定是不合理的。相反，我们期望能够在这里定义一个名为r的局部变量，这样我们把r设置为10时，也不用担心会干扰到可能重名的全局变量。调用过程时将会引入这些新的局部变量，将每个参数都与对应的符号绑定到参数列表中。函数调用时将根据这个列表获取对应的值。</p>
<font size="5" face="黑体">将Env重定义为类</font>

<p>为了处理局部变量，需要将Env重定义为dic子类。当我们对(circle-area (+ 5 5))求值的时候将获取到函数体(<em> pi (</em> r r))，会在只有一个变量r（值为10）的环境中对其求值，同时这个类将包含outer作为全局环境，其中包含了pi和*的值。换句话说，这个环境是这样的，局部环境（蓝色）嵌套在全局环境（红色）中。</p>
<p><table style="width: 220px;border:1px double #FF0000;cellspacing:1px;cellpadding:5px"><tbody><tr><td><tt>pi: 3.141592653589793<br>&lowast;: &lt;built-in function mul&gt;<br>…<br><table style="margin: 10px;width:80px; border:1px double #0000FF;cellspacing:1px; cellpadding:5px"><tbody><tr><td>r: 10</td></tr></tbody></table></tt></td></tr></tbody></table><br>当我们在这样一个嵌套的环境中寻找一个变量时，首先在最内层中查找，没找到的话，就移动到下一个外层。过程和环境是密切相关，以下是他们的定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Env</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="string">"一个环境包含一个&#123;'var': val&#125;字典和一个outer(Env)"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parms=<span class="params">()</span>, args=<span class="params">()</span>, outer=None)</span>:</span></span><br><span class="line">        self.update(zip(parms, args))</span><br><span class="line">        self.outer = outer</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, var)</span>:</span></span><br><span class="line">        <span class="string">"Find the innermost Env where var appears."</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="keyword">if</span> (var <span class="keyword">in</span> self) <span class="keyword">else</span> self.outer.find(var)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Procedure</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"一个用户自定义的Scheme过程"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parms, body, env)</span>:</span></span><br><span class="line">        self.parms, self.body, self.env = parms, body, env</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> eval(self.body, Env(self.parms, args, self.env))</span><br><span class="line"></span><br><span class="line">global_env = standard_env()</span><br></pre></td></tr></table></figure></p>
<p>可以看到，每一段过程都有3个部分：参数，函数体，以及一个能够告知我们从函数体中需要访问哪些变量的环境。这个过程的顶层是全局环境，同时也可以引用它所在环境的局部变量（而不是被调函数的环境）。<br>环境是一个dict的子类，所以它拥有所有dict拥有的方法。此外，这里还定义了另外两个方法：构造函数<strong>init</strong>通过接受参数名和对应的参数值创建了一组键值对作为内部环境，同时也可以指定外部环境。find方法用于查找变量所在的正确环境。<br>为了将所有函数结合，这里也需要对eval有一个新的定义。注意之前引用变量的的那条语句已作更改：现在需要调用env.find(x)来得到变量所在的层数，之后才能再从那一层获取变量的值。（define的实现并没有变化，因为define总是在最内层添加一个新的变量）同时这里还实现了两个新的函数：对于set!，查找变量所在的层数并更新其值。对于lambda，利用参数，函数体和环境构建一个新的过程对象。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(x, env=global_env)</span>:</span></span><br><span class="line">    <span class="string">"对环境中的表达式求值"</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(x, Symbol):    <span class="comment"># variable reference</span></span><br><span class="line">        <span class="keyword">return</span> env.find(x)[x]</span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> isinstance(x, List):<span class="comment"># constant</span></span><br><span class="line">        <span class="keyword">return</span> x   </span><br><span class="line">    op, *args = x       </span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">'quote'</span>:            <span class="comment"># quotation</span></span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'if'</span>:             <span class="comment"># conditional</span></span><br><span class="line">        (test, conseq, alt) = args</span><br><span class="line">        exp = (conseq <span class="keyword">if</span> eval(test, env) <span class="keyword">else</span> alt)</span><br><span class="line">        <span class="keyword">return</span> eval(exp, env)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'define'</span>:         <span class="comment"># definition</span></span><br><span class="line">        (symbol, exp) = args</span><br><span class="line">        env[symbol] = eval(exp, env)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'set!'</span>:           <span class="comment"># assignment</span></span><br><span class="line">        (symbol, exp) = args</span><br><span class="line">        env.find(symbol)[symbol] = eval(exp, env)</span><br><span class="line">    <span class="keyword">elif</span> op == <span class="string">'lambda'</span>:         <span class="comment"># procedure</span></span><br><span class="line">        (parms, body) = args</span><br><span class="line">        <span class="keyword">return</span> Procedure(parms, body, env)</span><br><span class="line">    <span class="keyword">else</span>:                        <span class="comment"># procedure call</span></span><br><span class="line">        proc = eval(op, env)</span><br><span class="line">        vals = [eval(arg, env) <span class="keyword">for</span> arg <span class="keyword">in</span> args]</span><br><span class="line">        <span class="keyword">return</span> proc(*vals)</span><br></pre></td></tr></table></figure></p>
<p>为了理解过程和环境是如何协同工作的，思考在对(account1 -20.00)求值时形成的环境：</p>
<p><table><tbody><tr><td><p><table style="width: 300px;border:1px double #FF0000;cellspacing:1px;cellpadding:5px"><tbody><tr><td valign="top"><tt>(define <b style="color:red">make-account</b><table style="margin: 10px;width: 270px;border:1px double #0000FF;cellspacing:1px;cellpadding:5px">  <tbody><tr><td>&nbsp;&nbsp;(lambda (<b style="color:blue">balance</b>)<table style="margin: 10px;width: 220px;border:1px double #00FF00;cellspacing:1px;cellpadding:5px">  <tbody><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (<b style="color:green">amt</b>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(begin <b style="background-color:yellow">(set! balance (+ balance amt))</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;balance))))</td></tr></tbody></table></td></tr></tbody></table><br><tt>(define <b style="color:red">account1</b> (make-account 100.00))<br>(account1 -20.00)</tt></tt></td></tr></tbody></table></p></td><td> &nbsp; </td><td valign="top"><table style="width: 300px;border:1px double #FF0000;cellspacing:1px;cellpadding:5px"><tbody><tr><td valign="top"><b style="color:red"><tt>+</tt></b>: &lt;built-in operator add&gt;<br><tt><b style="color:red">make-account</b>: &lt;a Procedure&gt;<table style="margin: 10px;width: 270px;border:1px double #0000FF;cellspacing:1px;cellpadding:5px">  <tbody><tr><td><tt><b style="color:blue">balance</b>: 100.00<table style="margin: 10px;width: 180px;border:1px double #00FF00;cellspacing:1px;cellpadding:5px">  <tbody><tr><td><tt><b style="color:green">amt</b>: -20.00</tt></td></tr></tbody></table></tt></td></tr></tbody></table><br><tt><tt><b style="color:red">account1</b>: &lt;a Procedure&gt;</tt></tt></tt></td></tr></tbody></table></td></tr></tbody></table><br>每个方框代表一个环境，框的颜色与当前环境中新定义的变量颜色相同。在程序的最后两行中定义了account1并调用了(account1 -20.00)，这表示首先创建了一个有100美元余额的账户，之后取出了20美元。在对(account1 -20.00)求值的过程中，我们将需要求值的表达式用黄色来高亮表示，该表达式有3个变量。其中amt可以立即在最内层环境（绿色）中找到。但balance并不在这里，我们必须在绿色环境的外一层寻找，也就是蓝色环境中可以找到。然而，变量+号并不在这两个环境中。我们需要在往外一层，到达全局环境（红色）。这个首先在最内层查找，之后一步一步向外的过程叫做词法作用域（lexical scope）。Env.find(var)能够根据做词法作用域的规则来找到正确的环境。<br>现在的功能如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>repl()</span><br><span class="line">lis.py&gt; (define circle-area (<span class="keyword">lambda</span> (r) (* pi (* r r))))</span><br><span class="line">lis.py&gt; (circle-area <span class="number">3</span>)</span><br><span class="line"><span class="number">28.274333877</span></span><br><span class="line">lis.py&gt; (define fact (<span class="keyword">lambda</span> (n) (<span class="keyword">if</span> (&lt;= n <span class="number">1</span>) <span class="number">1</span> (* n (fact (- n <span class="number">1</span>))))))</span><br><span class="line">lis.py&gt; (fact <span class="number">10</span>)</span><br><span class="line"><span class="number">3628800</span></span><br><span class="line">lis.py&gt; (fact <span class="number">100</span>)</span><br><span class="line"><span class="number">9332621544394415268169923885626670049071596826438162146859296389521759999322991</span></span><br><span class="line"><span class="number">5608941463976156518286253697920827223758251185210916864000000000000000000000000</span></span><br><span class="line">lis.py&gt; (circle-area (fact <span class="number">10</span>))</span><br><span class="line"><span class="number">4.1369087198e+13</span></span><br><span class="line">lis.py&gt; (define first car)</span><br><span class="line">lis.py&gt; (define rest cdr)</span><br><span class="line">lis.py&gt; (define count (lambda (item L) (if L (+ (equal? item (first L)) (count item (rest L))) 0)))</span><br><span class="line">lis.py&gt; (count <span class="number">0</span> (list <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span>))</span><br><span class="line"><span class="number">3</span></span><br><span class="line">lis.py&gt; (count (quote the) (quote (the more the merrier the bigger the better)))</span><br><span class="line"><span class="number">4</span></span><br><span class="line">lis.py&gt; (define twice (<span class="keyword">lambda</span> (x) (* <span class="number">2</span> x)))</span><br><span class="line">lis.py&gt; (twice <span class="number">5</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line">lis.py&gt; (define repeat (<span class="keyword">lambda</span> (f) (<span class="keyword">lambda</span> (x) (f (f x)))))</span><br><span class="line">lis.py&gt; ((repeat twice) <span class="number">10</span>)</span><br><span class="line"><span class="number">40</span></span><br><span class="line">lis.py&gt; ((repeat (repeat twice)) <span class="number">10</span>)</span><br><span class="line"><span class="number">160</span></span><br><span class="line">lis.py&gt; ((repeat (repeat (repeat twice))) <span class="number">10</span>)</span><br><span class="line"><span class="number">2560</span></span><br><span class="line">lis.py&gt; ((repeat (repeat (repeat (repeat twice)))) <span class="number">10</span>)</span><br><span class="line"><span class="number">655360</span></span><br><span class="line">lis.py&gt; (pow <span class="number">2</span> <span class="number">16</span>)</span><br><span class="line"><span class="number">65536.0</span></span><br><span class="line">lis.py&gt; (define fib (<span class="keyword">lambda</span> (n) (<span class="keyword">if</span> (&lt; n <span class="number">2</span>) <span class="number">1</span> (+ (fib (- n <span class="number">1</span>)) (fib (- n <span class="number">2</span>))))))</span><br><span class="line">lis.py&gt; (define range (<span class="keyword">lambda</span> (a b) (<span class="keyword">if</span> (= a b) (quote ()) (cons a (range (+ a <span class="number">1</span>) b)))))</span><br><span class="line">lis.py&gt; (range <span class="number">0</span> <span class="number">10</span>)</span><br><span class="line">(<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>)</span><br><span class="line">lis.py&gt; (map fib (range <span class="number">0</span> <span class="number">10</span>))</span><br><span class="line">(<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span>)</span><br><span class="line">lis.py&gt; (map fib (range <span class="number">0</span> <span class="number">20</span>))</span><br><span class="line">(<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span> <span class="number">2584</span> <span class="number">4181</span> <span class="number">6765</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们现在有一个包含过程，变量，条件（if）和顺序执行（begin过程）的语言。如果您熟悉其他语言，您可能会认为需要一个while或for循环，但Scheme认为没有这些也是可以的。Scheme的报告书中提到：Scheme对于表达式语法的规定非常少，并且对他们的组成方式没有限制，但这也足以成为一个实用且高效的程序语言(Scheme demonstrates that a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language.)。在Scheme中，你可以通过递归来完成迭代操作。</p>
<font size="5" face="黑体">Lispy的特征(How Small/Fast/Complete/Good is Lispy?)</font>

<p>我们可以根据以下几个标准来评判Lispy：</p>
<ul>
<li><p>简短：Lispy非常简短：去除注释和空白只有117行；4k的源码量。（早期版本只有90行，但标准程序较少，有点过于简单。）而我最简短的Java版的Scheme，<a href="http://www.norvig.com/lispy.html" target="_blank" rel="external">Jscheme</a>，有1664行以及57k的代码量。Jscheme最初叫SILK(50k的Scheme)(Scheme in Fifty Kilobytes)，但最终我只在字节码而不是源码上达到了这个限制（50k）。Lispy做的更好，我认为它符合Alan Kay在1972声称的，你可以在“一页代码”中定义“世界上最好的代码”。（然而Alan可能不会同意这一点，他会将python编译器也作为代码的一部分，一页就不够了。）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash$ grep <span class="string">"^\s*[^#\s]"</span> lis.py | wc</span><br><span class="line">     117     497    4276</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速：Lispy计算(fact 100)只需要0.003秒，对我来说是足够迅速了（虽然比大多数其他计算方式要慢）。</p>
</li>
<li>完备性：与标准Scheme相比，Lispy是不够完备的。主要缺陷：<ul>
<li>语法：缺少注释(comments)，引号(quote)，逆符号(quasiquote)，’#’字符，派生表达类型（比如cond，是从if中派生而来，let从lambda中派生而来），点缀列表(dotted list)。</li>
<li>语义：缺少call/cc和尾递归</li>
<li>数据类型：缺少字符串(strings)，字符(characters)，布尔值(booleans)，端口(ports)，向量(vectors)，精确化/去精确化数字(exact/inexact numbers)。实际上python中的lisp更贴近与Scheme的向量而不是我们实现的对(pair)。</li>
<li>过程：缺少超过100个原有过程。</li>
<li>错误恢复：lispy不会去检测合理报告或从错误中恢复。lispy希望程序员是完美的。</li>
</ul>
</li>
<li>优点：这个由读者来判断，这样显然更加有利于我说明Lisp解释器的目的。</li>
</ul>
<font size="5" face="黑体">真实的故事</font>

<p>这个故事对了解编译器的工作方式是非常有用的。1984年时，我正在写一篇博士论文，那个年代没有LaTeX，没有Word，那时我们用troff。不幸的是，troff没有提供符号标签的前向参照：比如如果我想写“正如我们在@theorem-x看到的那样(As we will see on page @theorem-x)”，然后就能在之后的某个地方写一些“@(set theorem-x \n%)”这种（troff的\n%表示页数）。我的研究生同事Tony DeRose也有相同的需求。之后我们完成了一个简单的Lisp程序用来预处理，来达到这个要求。然而，当时的Lisp仅能比较好的读取lisp表达式，但是在读取非Lisp表达式时非常慢，这使得我们的程序用起来非常不适。<br>在这一点上Tony和我采取了两种方式。他认为让解释器来解析这些表达式太困难了，但是他知道某种方式可以写一个小的C程序来处理非Lisp的字符串，之后将其链接到Lisp程序中。我并不知道怎么链接的，但我觉得给这种小语言（仅仅包含建立变量，获取变量，字符串联）写个解释器很简单，所以我用C写了个解释器。搞笑的是，Tony写了一个Lisp程序（包含一个小的C程序），而他是一个C程序员，而我写了一个C程序因为我是一个Lisp程序员。<br>当然，最后我们都完成了各自的论文（<a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1985/6081.html" target="_blank" rel="external">Tony</a>，<a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/1987/5995.html" target="_blank" rel="external">Peter</a>）。</p>
<font size="5" face="黑体">完整代码</font>

<p>这里是完整的程序：<a href="https://github.com/norvig/pytudes/blob/master/lis.py" target="_blank" rel="external">lis.py</a>(译者注：好像已经挂了)。</p>
<font size="5" face="黑体">进阶阅读</font>

<p>想学习更多Scheme相关的话，可以进行阅读（<a href="https://books.google.com/books?id=xyO-KLexVnMC&amp;lpg=PP1&amp;dq=scheme+programming+book&amp;pg=PP1&amp;redir_esc=y&amp;hl=en#v=onepage&amp;q&amp;f=false" target="_blank" rel="external">Friedman and Fellesein</a>， <a href="https://books.google.com/books?id=wftS4tj4XFMC&amp;lpg=PA300&amp;dq=scheme+programming+book&amp;pg=PP1&amp;redir_esc=y#v=onepage&amp;q&amp;f=false" target="_blank" rel="external">Dybvig</a>，<a href="https://books.google.com/books?id=81mFK8pqh5EC&amp;lpg=PP1&amp;dq=scheme+programming+book&amp;pg=PP1&amp;redir_esc=y#v=onepage&amp;q&amp;f=false" target="_blank" rel="external">Queinnec</a>，<a href="https://people.eecs.berkeley.edu/~bh/ss-toc2.html" target="_blank" rel="external">Harvey and Wright</a>或者<a href="http://mitpress.mit.edu/sites/default/files/sicp/index.html" target="_blank" rel="external">Sussman and Abelson</a>)，视频(<a href="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/" target="_blank" rel="external">Abelson and Sussman</a>)，教程(<a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html" target="_blank" rel="external">Dorai</a>，<a href="http://docs.racket-lang.org/quick/index.html" target="_blank" rel="external">PLT</a>，或 <a href="http://cs.gettysburg.edu/~tneller/cs341/scheme-intro/index.html" target="_blank" rel="external">Neller</a>)，或<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/" target="_blank" rel="external">参考手册</a>。</p>

<!-- more -->